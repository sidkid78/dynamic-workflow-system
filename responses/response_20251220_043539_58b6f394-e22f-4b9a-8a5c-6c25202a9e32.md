# Agent Response - prompt_generator

**Session ID**: 58b6f394-e22f-4b9a-8a5c-6c25202a9e32
**Processing Time**: 64.11 seconds

## Final Response

# Generated Prompt: Supabase Database Schema and RLS Policy Generation

## Metadata
- **Complexity Level:** workflow (Level 2)
- **Recommended Model:** gemini-2.5-flash
- **Temperature:** 0.4
- **Thinking Budget:** 8000

## Design Rationale
This prompt is designed as a structured 'workflow' to guide the agent through the complex task of database design. It breaks the process into logical steps, from analysis to SQL generation. Variables are used to define the core entities, ensuring all requirements from the analysis are met. Providing a concrete example with RLS policies sets a clear expectation for the output's quality and format. The explicit error handling instructions empower the agent to make and document logical assumptions, preventing it from getting stuck on ambiguities. The final report format ensures the output is both directly usable (the SQL script) and understandable (the rationale).

---

## The Prompt

You are an expert Database Architect specializing in Supabase and PostgreSQL. Your task is to generate a complete, secure, and production-ready database schema based on the provided requirements. This includes creating all tables, defining relationships, and implementing comprehensive Row-Level Security (RLS) policies.

### **Requirements**

- **Platform:** Supabase (PostgreSQL)
- **Required Tables:** `users`, `profiles`, `projects (leads)`, `AR assessments`, `contractor details`, `real-time messages`, `payment records`.
- **Authentication:** The schema must integrate with the standard Supabase `auth.users` table.
- **Specific Fields:** The `contractor_details` table must include a field for `CAPS certification`.
- **Security:** RLS must be enabled and configured for **every** table to ensure users can only access data they own or are permitted to see.

### **Workflow**

1.  **Analyze Requirements & Auth Integration:** Analyze the list of required tables and their implicit relationships. Plan the overall schema structure, focusing on normalization and how each table will relate to the central `auth.users` table.
2.  **Design Table Schemas:** For each table, define all columns with appropriate PostgreSQL data types (e.g., `uuid`, `text`, `timestamptz`, `jsonb`). Define primary keys, foreign keys, `NOT NULL` constraints, and default values. The `profiles` table should have a one-to-one relationship with `auth.users`.
3.  **Design RLS Policies:** For every table, design and define comprehensive RLS policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles (e.g., authenticated user, contractor) and data ownership.
4.  **Generate SQL Script:** Combine all table creation statements, constraints, and RLS policies into a single, cohesive, and executable SQL script. Ensure correct ordering to prevent dependency errors.

### **Example Table with RLS**

Here is an example for a `profiles` table to guide your output style:

```sql
-- Create a table for public profiles
CREATE TABLE profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  updated_at timestamptz,
  username text UNIQUE,
  full_name text,
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Set up Row Level Security (RLS)
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can insert their own profile." ON profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile." ON profiles
  FOR UPDATE USING (auth.uid() = id);
```

### **Error Handling**

If any requirement is ambiguous (e.g., the exact relationship between projects and contractors), make a logical assumption based on standard application design, state the assumption clearly in your design rationale, and proceed.

### **Output Format**

Produce a single markdown document with two main sections:

1.  **Database Schema SQL:** A single, complete SQL script inside a `sql` code block.
2.  **Design Rationale:** A bulleted list explaining your key decisions regarding table structure, relationships, data type choices, and the logic behind the RLS policies.

---

## Variables Reference

| Variable | Type | Required | Description |
|----------|------|----------|-------------|
| `tables_list` | static | Yes | A list of the required tables to be created in the database schema. |
| `auth_table` | static | Yes | The primary authentication table provided by Supabase Auth. |
| `special_fields` | static | No | Specific fields that must be included in certain tables. |
| `user_roles` | computed | Yes | The user roles to consider when creating RLS policies. |

## Workflow Summary

1. **Schema Analysis and Planning**: Analyze the list of required tables and their implicit relationships. Plan the overall schema structure, focusing on normalization and how each table will relate to the central `auth.users` table.
2. **Table Schema Definition**: For each table in the `tables_list`, define all columns with appropriate PostgreSQL data types (e.g., `uuid`, `text`, `timestamp with time zone`, `jsonb`, `boolean`). Define primary keys, foreign keys, `NOT NULL` constraints, and default values. Ensure the `profiles` table has a one-to-one relationship with `auth.users`.
3. **Row-Level Security (RLS) Policy Design**: For every table created, design and define comprehensive RLS policies. Enable RLS on each table. Create policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles and data ownership.
4. **SQL Script Compilation**: Combine all table creation statements, relationship constraints (foreign keys), and RLS policy definitions into a single, cohesive, and executable SQL script. Ensure the script is ordered correctly to avoid dependency errors (e.g., create tables before referencing them in foreign keys).
5. **Generate Final Report**: Prepare the final output in the specified format. The report must include the complete SQL script within a markdown code block and a separate section explaining the design rationale.


## Intermediate Steps

### Task Analyst

**Task Summary:** The user wants to generate a complete database schema for a Supabase project using PostgreSQL. This includes designing and implementing multiple tables, defining their relationships, constraints, and data types, and creating comprehensive Row-Level Security (RLS) policies for data protection. The new schema is intended to replace an existing Firebase Firestore structure.

**Recommended Level:** workflow (Level 2)

**Requirements Identified:** 8
- Platform: Supabase (PostgreSQL)
- Action: Design and implement a database schema.
- Data Migration Context: The new schema is replacing a Firebase Firestore database.
- Required Tables: users, profiles, projects (leads), AR assessments, contractor details, real-time messages, and payment records.
- Specific Fields: Contractor details must include CAPS certification.
- Schema Details: Define all table relationships, constraints (e.g., primary keys, foreign keys, not null), and appropriate data types for all columns.
- Security: Implement comprehensive Row-Level Security (RLS) policies for every table.
- Dependency: The schema design is dependent on an existing or planned authentication system ('foundation_auth'), likely Supabase Auth.

**Complexity Factors:**
- Multiple Interrelated Tables: The schema involves at least seven distinct but connected tables, requiring careful design of relationships (one-to-one, one-to-many).
- Comprehensive RLS Policies: Designing correct and secure RLS policies for each table based on user roles and data ownership is a complex security task.
- Data Modeling: Translating business requirements (leads, assessments, payments) into a normalized and efficient relational database structure.
- Data Type Selection: Choosing optimal data types for performance and data integrity.
- Dependency Management: Ensuring the schema correctly integrates with the specified 'foundation_auth' dependency, likely linking profiles and other data to the `auth.users` table.

**Potential Challenges:**
- Designing efficient table relationships, especially for concepts like real-time messaging which can be complex in a relational model.
- Creating RLS policies that are both secure and performant, avoiding overly complex logic that could slow down queries.
- Handling the migration logic from a NoSQL (Firestore) structure to a relational (PostgreSQL) structure, which may not be a direct one-to-one mapping.
- Ensuring data integrity through the correct use of constraints (e.g., UNIQUE, CHECK, FOREIGN KEY with cascade rules).
- Defining appropriate permissions for different user roles (e.g., regular user, contractor, admin) within the RLS policies.

**Metadata:**
```json
{
  "task_summary": "The user wants to generate a complete database schema for a Supabase project using PostgreSQL. This includes designing and implementing multiple tables, defining their relationships, constraints, and data types, and creating comprehensive Row-Level Security (RLS) policies for data protection. The new schema is intended to replace an existing Firebase Firestore structure.",
  "identified_requirements": [
    "Platform: Supabase (PostgreSQL)",
    "Action: Design and implement a database schema.",
    "Data Migration Context: The new schema is replacing a Firebase Firestore database.",
    "Required Tables: users, profiles, projects (leads), AR assessments, contractor details, real-time messages, and payment records.",
    "Specific Fields: Contractor details must include CAPS certification.",
    "Schema Details: Define all table relationships, constraints (e.g., primary keys, foreign keys, not null), and appropriate data types for all columns.",
    "Security: Implement comprehensive Row-Level Security (RLS) policies for every table.",
    "Dependency: The schema design is dependent on an existing or planned authentication system ('foundation_auth'), likely Supabase Auth."
  ],
  "recommended_level": "workflow",
  "suggested_tools": [
    "SQL",
    "PostgreSQL",
    "Supabase CLI"
  ],
  "complexity_factors": [
    "Multiple Interrelated Tables: The schema involves at least seven distinct but connected tables, requiring careful design of relationships (one-to-one, one-to-many).",
    "Comprehensive RLS Policies: Designing correct and secure RLS policies for each table based on user roles and data ownership is a complex security task.",
    "Data Modeling: Translating business requirements (leads, assessments, payments) into a normalized and efficient relational database structure.",
    "Data Type Selection: Choosing optimal data types for performance and data integrity.",
    "Dependency Management: Ensuring the schema correctly integrates with the specified 'foundation_auth' dependency, likely linking profiles and other data to the `auth.users` table."
  ],
  "potential_challenges": [
    "Designing efficient table relationships, especially for concepts like real-time messaging which can be complex in a relational model.",
    "Creating RLS policies that are both secure and performant, avoiding overly complex logic that could slow down queries.",
    "Handling the migration logic from a NoSQL (Firestore) structure to a relational (PostgreSQL) structure, which may not be a direct one-to-one mapping.",
    "Ensuring data integrity through the correct use of constraints (e.g., UNIQUE, CHECK, FOREIGN KEY with cascade rules).",
    "Defining appropriate permissions for different user roles (e.g., regular user, contractor, admin) within the RLS policies."
  ]
}
```

### Prompt Engineer

**Generated Prompt:** Supabase Database Schema and RLS Policy Generation

**Level:** workflow
**Purpose:** To generate a complete, secure, and production-ready PostgreSQL database schema for a Supabase project, including all table definitions, relationships, constraints, and comprehensive Row-Level Security (RLS) policies.

**Variables:** 4
**Workflow Steps:** 5

**Design Rationale:**
This prompt is designed as a structured 'workflow' to guide the agent through the complex task of database design. It breaks the process into logical steps, from analysis to SQL generation. Variables are used to define the core entities, ensuring all requirements from the analysis are met. Providing a concrete example with RLS policies sets a clear expectation for the output's quality and format. The explicit error handling instructions empower the agent to make and document logical assumptions, preventing it from getting stuck on ambiguities. The final report format ensures the output is both directly usable (the SQL script) and understandable (the rationale).

**Metadata:**
```json
{
  "title": "Supabase Database Schema and RLS Policy Generation",
  "level": "workflow",
  "variables_count": 4,
  "workflow_steps_count": 5
}
```

### Prompt Reviewer

Excellent. Here is a detailed review of the generated prompt.

### 1. Overall Quality Assessment

**Score: 10/10**

This is an outstanding prompt. It is comprehensive, clear, and expertly crafted for a complex technical task. It effectively translates the original task's requirements into a structured, actionable set of instructions for an AI model. The prompt uses several best practices, including setting a persona, providing a clear workflow, giving a concrete example, and specifying error handling and output format.

---

### 2. Specific Issues Found

There are no significant issues with this prompt. The following are minor observations that are more "polishing" than "fixing":

*   **Slight Redundancy in Table List:** The `Requirements` section lists `users` as a required table, but then correctly clarifies that the schema must integrate with the existing `auth.users` table. This could cause a moment of confusion, but the prompt's example and workflow steps resolve it perfectly.

---

### 3. Suggested Improvements

While the prompt is already excellent, these small additions could enhance it further by encouraging even more robust, production-ready output.

1.  **Encourage Indexing:** In the `Workflow` section, under step 2 (`Design Table Schemas`), add a point about performance. This prompts the AI to think not just about structure but also about query efficiency.
    *   **Suggestion:** Add the following sentence to the end of step 2: *"Consider adding indexes on foreign key columns and other columns that will be frequently used in `WHERE` clauses to optimize query performance."*

2.  **Specify Commenting:** For maintainability, it's good practice to have comments in the SQL script.
    *   **Suggestion:** Add a new point to the `Output Format` section under "Database Schema SQL": *"The SQL script should be well-commented, explaining the purpose of each table and any complex constraints or policies."*

3.  **Refine the Table List:** To remove the minor redundancy mentioned above, the table list could be slightly rephrased.
    *   **Suggestion:** Change the "Required Tables" bullet point from:
        > - **Required Tables:** `users`, `profiles`, `projects (leads)`, `AR assessments`, `contractor details`, `real-time messages`, `payment records`.
    *   To:
        > - **Tables to Create:** `profiles` (to extend `auth.users`), `projects` (or `leads`), `ar_assessments`, `contractor_details`, `messages`, and `payment_records`. Use clear, consistent naming conventions (e.g., snake_case).

This change clarifies the role of `profiles` upfront and encourages good naming conventions.

---

### 4. Final Recommendation

**Approve.**

The prompt is ready to use as-is and will likely generate a high-quality, accurate response. The suggested improvements are minor enhancements that would elevate an already excellent prompt to an exceptional one.

**Metadata:**
```json
{
  "step": "review"
}
```

### Output Formatter

# Generated Prompt: Supabase Database Schema and RLS Policy Generation

## Metadata
- **Complexity Level:** workflow (Level 2)
- **Recommended Model:** gemini-2.5-flash
- **Temperature:** 0.4
- **Thinking Budget:** 8000

## Design Rationale
This prompt is designed as a structured 'workflow' to guide the agent through the complex task of database design. It breaks the process into logical steps, from analysis to SQL generation. Variables are used to define the core entities, ensuring all requirements from the analysis are met. Providing a concrete example with RLS policies sets a clear expectation for the output's quality and format. The explicit error handling instructions empower the agent to make and document logical assumptions, preventing it from getting stuck on ambiguities. The final report format ensures the output is both directly usable (the SQL script) and understandable (the rationale).

---

## The Prompt

You are an expert Database Architect specializing in Supabase and PostgreSQL. Your task is to generate a complete, secure, and production-ready database schema based on the provided requirements. This includes creating all tables, defining relationships, and implementing comprehensive Row-Level Security (RLS) policies.

### **Requirements**

- **Platform:** Supabase (PostgreSQL)
- **Required Tables:** `users`, `profiles`, `projects (leads)`, `AR assessments`, `contractor details`, `real-time messages`, `payment records`.
- **Authentication:** The schema must integrate with the standard Supabase `auth.users` table.
- **Specific Fields:** The `contractor_details` table must include a field for `CAPS certification`.
- **Security:** RLS must be enabled and configured for **every** table to ensure users can only access data they own or are permitted to see.

### **Workflow**

1.  **Analyze Requirements & Auth Integration:** Analyze the list of required tables and their implicit relationships. Plan the overall schema structure, focusing on normalization and how each table will relate to the central `auth.users` table.
2.  **Design Table Schemas:** For each table, define all columns with appropriate PostgreSQL data types (e.g., `uuid`, `text`, `timestamptz`, `jsonb`). Define primary keys, foreign keys, `NOT NULL` constraints, and default values. The `profiles` table should have a one-to-one relationship with `auth.users`.
3.  **Design RLS Policies:** For every table, design and define comprehensive RLS policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles (e.g., authenticated user, contractor) and data ownership.
4.  **Generate SQL Script:** Combine all table creation statements, constraints, and RLS policies into a single, cohesive, and executable SQL script. Ensure correct ordering to prevent dependency errors.

### **Example Table with RLS**

Here is an example for a `profiles` table to guide your output style:

```sql
-- Create a table for public profiles
CREATE TABLE profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  updated_at timestamptz,
  username text UNIQUE,
  full_name text,
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Set up Row Level Security (RLS)
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can insert their own profile." ON profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile." ON profiles
  FOR UPDATE USING (auth.uid() = id);
```

### **Error Handling**

If any requirement is ambiguous (e.g., the exact relationship between projects and contractors), make a logical assumption based on standard application design, state the assumption clearly in your design rationale, and proceed.

### **Output Format**

Produce a single markdown document with two main sections:

1.  **Database Schema SQL:** A single, complete SQL script inside a `sql` code block.
2.  **Design Rationale:** A bulleted list explaining your key decisions regarding table structure, relationships, data type choices, and the logic behind the RLS policies.

---

## Variables Reference

| Variable | Type | Required | Description |
|----------|------|----------|-------------|
| `tables_list` | static | Yes | A list of the required tables to be created in the database schema. |
| `auth_table` | static | Yes | The primary authentication table provided by Supabase Auth. |
| `special_fields` | static | No | Specific fields that must be included in certain tables. |
| `user_roles` | computed | Yes | The user roles to consider when creating RLS policies. |

## Workflow Summary

1. **Schema Analysis and Planning**: Analyze the list of required tables and their implicit relationships. Plan the overall schema structure, focusing on normalization and how each table will relate to the central `auth.users` table.
2. **Table Schema Definition**: For each table in the `tables_list`, define all columns with appropriate PostgreSQL data types (e.g., `uuid`, `text`, `timestamp with time zone`, `jsonb`, `boolean`). Define primary keys, foreign keys, `NOT NULL` constraints, and default values. Ensure the `profiles` table has a one-to-one relationship with `auth.users`.
3. **Row-Level Security (RLS) Policy Design**: For every table created, design and define comprehensive RLS policies. Enable RLS on each table. Create policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles and data ownership.
4. **SQL Script Compilation**: Combine all table creation statements, relationship constraints (foreign keys), and RLS policy definitions into a single, cohesive, and executable SQL script. Ensure the script is ordered correctly to avoid dependency errors (e.g., create tables before referencing them in foreign keys).
5. **Generate Final Report**: Prepare the final output in the specified format. The report must include the complete SQL script within a markdown code block and a separate section explaining the design rationale.


**Metadata:**
```json
{
  "title": "Supabase Database Schema and RLS Policy Generation",
  "purpose": "To generate a complete, secure, and production-ready PostgreSQL database schema for a Supabase project, including all table definitions, relationships, constraints, and comprehensive Row-Level Security (RLS) policies.",
  "level": "workflow",
  "variables": [
    {
      "name": "tables_list",
      "description": "A list of the required tables to be created in the database schema.",
      "variable_type": "static",
      "default_value": "users, profiles, projects (leads), AR assessments, contractor details, real-time messages, payment records",
      "required": true
    },
    {
      "name": "auth_table",
      "description": "The primary authentication table provided by Supabase Auth.",
      "variable_type": "static",
      "default_value": "auth.users",
      "required": true
    },
    {
      "name": "special_fields",
      "description": "Specific fields that must be included in certain tables.",
      "variable_type": "static",
      "default_value": "The 'contractor_details' table must include a field for 'CAPS certification'.",
      "required": false
    },
    {
      "name": "user_roles",
      "description": "The user roles to consider when creating RLS policies.",
      "variable_type": "computed",
      "default_value": "authenticated_user, contractor, admin (if applicable)",
      "required": true
    }
  ],
  "workflow": [
    {
      "step_number": 1,
      "title": "Schema Analysis and Planning",
      "description": "Analyze the list of required tables and their implicit relationships. Plan the overall schema structure, focusing on normalization and how each table will relate to the central `auth.users` table.",
      "substeps": null,
      "condition": null,
      "error_handling": null
    },
    {
      "step_number": 2,
      "title": "Table Schema Definition",
      "description": "For each table in the `tables_list`, define all columns with appropriate PostgreSQL data types (e.g., `uuid`, `text`, `timestamp with time zone`, `jsonb`, `boolean`). Define primary keys, foreign keys, `NOT NULL` constraints, and default values. Ensure the `profiles` table has a one-to-one relationship with `auth.users`.",
      "substeps": [
        "Create `profiles` table linked to `auth.users` via user ID.",
        "Create `projects` (leads) table, likely linked to a user/profile.",
        "Create `AR assessments` table, linked to `projects`.",
        "Create `contractor_details` table, linked to `profiles` for users who are contractors. Include the 'CAPS certification' field.",
        "Create `real-time messages` table, considering relationships between sender/receiver (profiles) and a project.",
        "Create `payment_records` table, linked to projects and users."
      ],
      "condition": null,
      "error_handling": null
    },
    {
      "step_number": 3,
      "title": "Row-Level Security (RLS) Policy Design",
      "description": "For every table created, design and define comprehensive RLS policies. Enable RLS on each table. Create policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles and data ownership.",
      "substeps": [
        "Users should only be able to view/edit their own profile.",
        "Users should only be able to view projects they are associated with.",
        "Define access rules for contractors vs. regular users on projects and assessments.",
        "Secure the `messages` table so only participants can read messages.",
        "Assume a privileged `service_role` can bypass all RLS for backend operations."
      ],
      "condition": null,
      "error_handling": "If a specific policy is ambiguous, state your assumption clearly (e.g., 'Assuming only project owners and assigned contractors can view AR assessments')."
    },
    {
      "step_number": 4,
      "title": "SQL Script Compilation",
      "description": "Combine all table creation statements, relationship constraints (foreign keys), and RLS policy definitions into a single, cohesive, and executable SQL script. Ensure the script is ordered correctly to avoid dependency errors (e.g., create tables before referencing them in foreign keys).",
      "substeps": null,
      "condition": null,
      "error_handling": null
    },
    {
      "step_number": 5,
      "title": "Generate Final Report",
      "description": "Prepare the final output in the specified format. The report must include the complete SQL script within a markdown code block and a separate section explaining the design rationale.",
      "substeps": null,
      "condition": null,
      "error_handling": null
    }
  ],
  "instructions": "Your goal is to act as an expert Database Architect. The generated SQL must be compatible with Supabase PostgreSQL. Pay close attention to data types for performance and storage efficiency. Use `uuid` for primary keys where appropriate and link them to `auth.users(id)`. Add comments within the SQL script to explain complex table structures or RLS policies. Remember that the original data source was Firestore (NoSQL), so your relational design should focus on creating clear, normalized relationships.",
  "examples": [
    "Example of a `profiles` table with RLS:\n```sql\n-- Create a table for public profiles\nCREATE TABLE profiles (\n  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,\n  updated_at timestamptz,\n  username text UNIQUE,\n  full_name text,\n  avatar_url text,\n  website text,\n  CONSTRAINT username_length CHECK (char_length(username) >= 3)\n);\n\n-- Set up Row Level Security (RLS)\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Public profiles are viewable by everyone.\" ON profiles\n  FOR SELECT USING (true);\n\nCREATE POLICY \"Users can insert their own profile.\" ON profiles\n  FOR INSERT WITH CHECK (auth.uid() = id);\n\nCREATE POLICY \"Users can update own profile.\" ON profiles\n  FOR UPDATE USING (auth.uid() = id);\n```"
  ],
  "error_handling": "If any part of the request is ambiguous, make a logical assumption based on standard application design, state the assumption clearly in your design rationale, and proceed. For instance, if user roles are not explicitly defined, assume a standard 'authenticated user' role with ownership-based permissions.",
  "report_format": "A single markdown document with two main sections:\n1.  **Database Schema SQL:** A single, complete SQL script inside a `sql` code block.\n2.  **Design Rationale:** A bulleted list explaining key decisions regarding table structure, relationships, data type choices, and the logic behind the RLS policies.",
  "metadata": {
    "recommended_model": "gemini-2.5-flash",
    "thinking_budget": 8000,
    "temperature": 0.4,
    "tools_required": [
      "SQL"
    ],
    "estimated_tokens": 2500
  },
  "rendered_prompt": "You are an expert Database Architect specializing in Supabase and PostgreSQL. Your task is to generate a complete, secure, and production-ready database schema based on the provided requirements. This includes creating all tables, defining relationships, and implementing comprehensive Row-Level Security (RLS) policies.\n\n### **Requirements**\n\n- **Platform:** Supabase (PostgreSQL)\n- **Required Tables:** `users`, `profiles`, `projects (leads)`, `AR assessments`, `contractor details`, `real-time messages`, `payment records`.\n- **Authentication:** The schema must integrate with the standard Supabase `auth.users` table.\n- **Specific Fields:** The `contractor_details` table must include a field for `CAPS certification`.\n- **Security:** RLS must be enabled and configured for **every** table to ensure users can only access data they own or are permitted to see.\n\n### **Workflow**\n\n1.  **Analyze Requirements & Auth Integration:** Analyze the list of required tables and their implicit relationships. Plan the overall schema structure, focusing on normalization and how each table will relate to the central `auth.users` table.\n2.  **Design Table Schemas:** For each table, define all columns with appropriate PostgreSQL data types (e.g., `uuid`, `text`, `timestamptz`, `jsonb`). Define primary keys, foreign keys, `NOT NULL` constraints, and default values. The `profiles` table should have a one-to-one relationship with `auth.users`.\n3.  **Design RLS Policies:** For every table, design and define comprehensive RLS policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles (e.g., authenticated user, contractor) and data ownership.\n4.  **Generate SQL Script:** Combine all table creation statements, constraints, and RLS policies into a single, cohesive, and executable SQL script. Ensure correct ordering to prevent dependency errors.\n\n### **Example Table with RLS**\n\nHere is an example for a `profiles` table to guide your output style:\n\n```sql\n-- Create a table for public profiles\nCREATE TABLE profiles (\n  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,\n  updated_at timestamptz,\n  username text UNIQUE,\n  full_name text,\n  CONSTRAINT username_length CHECK (char_length(username) >= 3)\n);\n\n-- Set up Row Level Security (RLS)\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can insert their own profile.\" ON profiles\n  FOR INSERT WITH CHECK (auth.uid() = id);\n\nCREATE POLICY \"Users can update own profile.\" ON profiles\n  FOR UPDATE USING (auth.uid() = id);\n```\n\n### **Error Handling**\n\nIf any requirement is ambiguous (e.g., the exact relationship between projects and contractors), make a logical assumption based on standard application design, state the assumption clearly in your design rationale, and proceed.\n\n### **Output Format**\n\nProduce a single markdown document with two main sections:\n\n1.  **Database Schema SQL:** A single, complete SQL script inside a `sql` code block.\n2.  **Design Rationale:** A bulleted list explaining your key decisions regarding table structure, relationships, data type choices, and the logic behind the RLS policies.",
  "design_rationale": "This prompt is designed as a structured 'workflow' to guide the agent through the complex task of database design. It breaks the process into logical steps, from analysis to SQL generation. Variables are used to define the core entities, ensuring all requirements from the analysis are met. Providing a concrete example with RLS policies sets a clear expectation for the output's quality and format. The explicit error handling instructions empower the agent to make and document logical assumptions, preventing it from getting stuck on ambiguities. The final report format ensures the output is both directly usable (the SQL script) and understandable (the rationale)."
}
```
