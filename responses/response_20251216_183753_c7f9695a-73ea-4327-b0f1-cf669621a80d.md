# Agent Response - orchestrator_workers

**Session ID**: c7f9695a-73ea-4327-b0f1-cf669621a80d
**Processing Time**: 378.71 seconds

## Final Response

Of course. Here is a comprehensive technical architecture and implementation guide for building the "Mobile Detailing Concierge" platform using the Next.js App Router and Supabase.

### **Executive Summary**

This guide outlines a complete, production-ready technical architecture for a mobile car detailing concierge service. The solution is built on a modern, scalable stack: **Next.js with the App Router** for the frontend and server-side logic, and **Supabase** as the all-in-one backend for the database, authentication, and storage.

The architecture is broken down into five phases, guiding you from initial project setup to a live, deployed application:

1. **Foundation:** Establishes the Next.js project, Supabase backend, database schema, and security rules.
2. **Authentication:** Implements a robust user management system with distinct roles for customers, detailers, and administrators.
3. **Core Features:** Builds the customer-facing landing page and the multi-step booking system.
4. **Dashboards:** Creates secure, role-specific dashboards for detailers to manage their schedules and for the concierge to manage the entire platform.
5. **Testing & Deployment:** Ensures application quality with end-to-end testing and provides a clear path to production using Vercel.

---

### **Phase 1: Project Foundation**

This phase lays the essential groundwork for the entire application.

#### **Step 1.1: Initializing the Next.js Project**

We'll begin by creating a new Next.js project using the recommended App Router and TypeScript for a robust development experience.

1. Open your terminal and run the `create-next-app` command:

    ```bash
    npx create-next-app@latest mobile-detailing-concierge
    ```

2. When prompted, select the following options for a modern setup:
    * Use TypeScript? **Yes**
    * Use ESLint? **Yes**
    * Use Tailwind CSS? **Yes**
    * Use `src/` directory? **Yes**
    * Use App Router? **Yes**
    * Customize default import alias? **No**
3. Navigate into your new project directory:

    ```bash
    cd mobile-detailing-concierge
    ```

#### **Step 1.2: Setting Up the Supabase Backend**

Next, create the Supabase project that will serve as your database and authentication provider.

1. Log in to your account at [app.supabase.com](https://app.supabase.com/) and click **"New project"**.
2. Name your project (e.g., `mobile-detailing-concierge`), generate and securely save a database password, and choose the region closest to your users.
3. Click **"Create new project"**.

#### **Step 1.3: Connecting Next.js and Supabase**

Securely connect your Next.js application to Supabase using environment variables.

1. In your Supabase project dashboard, navigate to **Project Settings > API**.
2. Copy the **Project URL** and the `anon` `public` **Project API Key**.
3. In your Next.js project root, create a file named `.env.local` and add your credentials:

    ```.env.local
    NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_PROJECT_URL
    NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
    ```

    The `NEXT_PUBLIC_` prefix is required by Next.js to expose these variables to the browser.

4. Install the Supabase client libraries, including the package specifically designed for server-side rendering (`ssr`):

    ```bash
    npm install @supabase/supabase-js @supabase/ssr
    ```

#### **Step 1.4: Database Schema & Security**

This is the blueprint for your application's data. We will create all necessary tables and secure them with Supabase's powerful Row Level Security (RLS).

Go to the **SQL Editor** in your Supabase dashboard, create a new query, and run the following script to set up your entire database structure.

**Schema Creation Script:**

```sql
-- ========= CUSTOM TYPES =========
CREATE TYPE public.user_role AS ENUM ('customer', 'detailer', 'admin');
CREATE TYPE public.booking_status AS ENUM ('pending', 'confirmed', 'completed', 'cancelled');

-- ========= TABLES =========
-- Stores public user data and links to auth.users
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name text,
  phone_number text,
  role public.user_role NOT NULL DEFAULT 'customer'
);

-- Stores detailer-specific information
CREATE TABLE public.detailers (
  id uuid NOT NULL PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  business_name text,
  service_area_description text,
  is_active boolean NOT NULL DEFAULT false
);

-- Catalog of detailing packages offered
CREATE TABLE public.services (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  name text NOT NULL,
  description text,
  price numeric(10, 2) NOT NULL,
  estimated_duration_minutes integer NOT NULL,
  is_active boolean NOT NULL DEFAULT true
);

-- The core table for appointments
CREATE TABLE public.bookings (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id),
  detailer_id uuid REFERENCES public.profiles(id),
  service_id uuid NOT NULL REFERENCES public.services(id),
  booking_time timestamp with time zone NOT NULL,
  location_address text NOT NULL,
  status public.booking_status NOT NULL DEFAULT 'pending',
  final_price numeric(10, 2) NOT NULL
);

-- Stores recurring weekly availability for detailers
CREATE TABLE public.detailer_availability (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  detailer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_of_week smallint NOT NULL CHECK (day_of_week >= 0 AND day_of_week <= 6), -- 0=Sun, 6=Sat
  start_time time NOT NULL,
  end_time time NOT NULL,
  UNIQUE (detailer_id, day_of_week)
);

-- ========= TRIGGERS =========
-- Creates a profile entry when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

**Row Level Security (RLS) Policies:**

Next, run this script in the SQL Editor to enable RLS and apply security rules. This ensures users can only access data they are permitted to see.

```sql
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detailers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detailer_availability ENABLE ROW LEVEL SECURITY;

-- POLICIES: profiles
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- POLICIES: bookings
CREATE POLICY "Customers can create their own bookings" ON public.bookings FOR INSERT WITH CHECK (auth.uid() = customer_id);
CREATE POLICY "Customers can view their own bookings" ON public.bookings FOR SELECT USING (auth.uid() = customer_id);
CREATE POLICY "Detailers can view bookings assigned to them" ON public.bookings FOR SELECT USING (auth.uid() = detailer_id);

-- POLICIES: detailer_availability
CREATE POLICY "Detailers can manage their own availability" ON public.detailer_availability FOR ALL USING (auth.uid() = detailer_id);
CREATE POLICY "Authenticated users can view availability" ON public.detailer_availability FOR SELECT USING (auth.role() = 'authenticated');

-- POLICIES: services
CREATE POLICY "Public can view active services" ON public.services FOR SELECT USING (is_active = true);

-- NOTE: Admin access is typically handled by disabling RLS for specific server-side operations using the SERVICE_ROLE_KEY, or by creating specific admin policies.
```

---

### **Phase 2: User Authentication & Authorization**

With the foundation in place, we'll build the complete authentication system.

#### **Step 2.1: Create Supabase Client Helpers**

To interact with Supabase seamlessly across client components, server components, and middleware, we create a set of helper functions.

Create a new folder `src/lib/supabase` and add the following files:

* **`src/lib/supabase/client.ts`** (For Client Components)

    ```typescript
    import { createBrowserClient } from '@supabase/ssr'
    export function createClient() {
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
    }
    ```

* **`src/lib/supabase/server.ts`** (For Server Components/Actions)

    ```typescript
    import { createServerClient, type CookieOptions } from '@supabase/ssr'
    import { cookies } from 'next/headers'
    // ... (full code provided in subtask result)
    ```

* **`src/lib/supabase/middleware.ts`** (For Middleware)

    ```typescript
    import { createServerClient, type CookieOptions } from '@supabase/ssr'
    import { type NextRequest, type NextResponse } from 'next/server'
    // ... (full code provided in subtask result)
    ```

#### **Step 2.2: Implement Login & Signup Pages**

Create pages with forms that use Next.js Server Actions to securely handle user credentials.

* **`app/signup/page.tsx`**: A form with fields for full name, email, password, and a role selector (`Car Owner` or `Detailer`). The `signUp` server action will call `supabase.auth.signUp` and update the user's role in the `profiles` table.
* **`app/login/page.tsx`**: A form with email and password fields. The `signIn` server action calls `supabase.auth.signInWithPassword`, then checks the user's role from the `profiles` table to redirect them to the correct dashboard (`/dashboard/customer`, `/dashboard/detailer`, or `/admin`).

#### **Step 2.3: Handle Authentication Callbacks**

When a user confirms their email, Supabase redirects them to a specific route. Create this route to exchange the confirmation code for a valid user session.

* **`app/auth/callback/route.ts`**: This route handler will parse the `code` from the URL, call `supabase.auth.exchangeCodeForSession`, and redirect the user to their dashboard.

#### **Step 2.4: Secure Routes with Middleware**

Middleware runs before a request is completed, making it the ideal place to protect routes. Create a `middleware.ts` file in the root of your project.

* **`middleware.ts`**: This file will:
  * Refresh the user's session on every request.
  * Redirect unauthenticated users trying to access `/dashboard` or `/admin` to the `/login` page.
  * Redirect authenticated users away from `/login` or `/signup`.
  * Check the user's role and block non-admins from accessing the `/admin` path.

---

### **Phase 3: Core Feature Implementation**

Now we'll build the primary features that customers interact with.

#### **Step 3.1: Building the Public Landing Page**

Create a visually appealing landing page to attract customers and showcase your services.

* **`app/page.tsx`**: This will be an `async` Server Component.
    1. It will use the server Supabase client to fetch all active services from the `services` table (`select * from services where is_active = true`).
    2. It will render a hero section with your value proposition.
    3. It will map over the fetched services and display each one in a `ServiceCard` component, showing the name, description, price, and a "Book Now" button.

#### **Step 3.2: Implementing the Multi-Step Booking System**

This is the core functionality of the concierge service.

1. **Create Server Actions (`app/book/actions.ts`)**:
    * `getServices()`: Fetches all active detailing services.
    * `getAvailableSlots(date, duration)`: A complex action that finds all available time slots on a given day by:
        * Fetching all active detailers and their weekly availability.
        * Fetching all existing bookings for that day.
        * Calculating potential time slots and filtering out any that conflict with existing bookings.
    * `createBooking(formData)`: The final action that:
        * Validates the selected service and time slot.
        * Assigns an available detailer to the job.
        * Inserts a new record into the `bookings` table with a `pending` status.
        * Redirects the user to their dashboard with a success message.

2. **Create the Booking Page (`app/book/page.tsx`)**:
    * This will be a client component (`'use client'`) to manage the state of the multi-step form.
    * **Step 1:** Display services fetched via the `getServices` action. The user selects one.
    * **Step 2:** Show a date picker. When a date is chosen, it calls the `getAvailableSlots` action and displays the returned time slots as clickable buttons.
    * **Step 3:** Display a confirmation summary of the selected service, date, and time. The user enters their address and submits the form, which calls the `createBooking` server action.

---

### **Phase 4: Role-Based Dashboards**

Create secure areas for detailers and the admin to manage their respective tasks.

#### **Step 4.1: Developing the Detailer Dashboard**

This dashboard is the central hub for your detailers.

* **`app/dashboard/detailer/page.tsx`**: A secure Server Component that:
    1. Verifies the logged-in user has the `detailer` role.
    2. Fetches all necessary data for that specific detailer ID in parallel:
        * Assigned bookings from the `bookings` table.
        * Current weekly availability from `detailer_availability`.
        * Completed jobs to calculate earnings.
    3. Passes this data to client components for display and interaction.
* **Components:**
  * **`EarningsSummary`**: Displays key metrics like total completed jobs and total earnings (after commission).
  * **`BookingsList`**: Shows upcoming and past jobs, including customer details and service location.
  * **`AvailabilityManager`**: A form where the detailer can set their recurring weekly work hours (e.g., Monday 9 AM - 5 PM). Submitting this form calls a server action to update their schedule in the `detailer_availability` table.

#### **Step 4.2: Building the Admin/Concierge Dashboard**

This is the control panel for the entire business, protected by the middleware to be admin-only.

* **`app/admin/layout.tsx`**: A shared layout for all admin pages with consistent navigation (Dashboard, Bookings, Detailers, Services).
* **Admin Pages (`app/admin/**/page.tsx`)**: A series of Server Components, each with a specific management function:
  * **Dashboard (`/admin`):** Displays high-level statistics like total revenue, commissions owed, and pending bookings.
  * **Bookings Management:** Shows a table of *all* bookings. The admin can view details and update the status of any booking (e.g., change from `pending` to `confirmed`).
  * **Detailer Management:** A page to view all detailers, activate/deactivate their profiles, and edit their information. Includes a form for adding new detailers to the network.
  * **Service Management:** A page to create, edit, and update the detailing packages offered on the platform.
* **Admin Server Actions (`app/admin/actions.ts`)**: A set of secure server actions for creating, updating, and deleting services and detailers, and for modifying booking statuses. These actions will use the Supabase admin client to bypass RLS policies when necessary.

---

### **Phase 5: Testing and Deployment**

The final phase ensures your application is reliable and makes it accessible to the world.

#### **Step 5.1: End-to-End Testing with Playwright**

Simulate real user journeys to validate that all parts of the application work together correctly.

1. **Setup:** Install Playwright (`npm init playwright@latest`) and configure it to use your local development server's URL (`http://localhost:3000`).
2. **Database Seeding:** Create a script (`e2e/utils/seed.ts`) that resets the database and populates it with known test users (customer, detailer, admin) and data before each test run. This ensures a consistent state for reliable testing.
3. **Write Test Scenarios:** Create test files for critical user flows:
    * **`auth.spec.ts`**: Tests user signup, login with different roles, and logout.
    * **`booking.spec.ts`**: Logs in as a customer, navigates the multi-step booking form, confirms a booking, and verifies it appears on their dashboard.
    * **`detailer.spec.ts`**: Logs in as a detailer and verifies they can see the booking created in the previous test.
    * **`admin.spec.ts`**: Logs in as an admin, navigates to the bookings page, and confirms the test booking.

#### **Step 5.2: Deploying to Production with Vercel**

Vercel provides a seamless, one-click deployment experience for Next.js applications.

1. **Push to Git:** Ensure your project code is pushed to a GitHub, GitLab, or Bitbucket repository.
2. **Import to Vercel:** Log in to Vercel, import your Git repository, and Vercel will automatically detect the Next.js framework.
3. **Configure Environment Variables:** In the Vercel project settings, add the same environment variables from your `.env.local` file (`NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY`). These are now your production credentials.
4. **Deploy:** Click the "Deploy" button. Vercel will build and deploy your application to a global CDN.
5. **Add Custom Domain:** In your Vercel project's "Domains" tab, add your custom domain and follow the instructions to update your DNS records with your domain registrar. Vercel will automatically handle SSL certificate provisioning.
6. **Final Supabase Checks:** Ensure RLS is enabled on all tables, set a strong database password, and customize the user-facing email templates in the Supabase dashboard.

## Intermediate Steps

### Task Coordinator

Task Understanding:
The user wants to build a 'Mobile Detailing Concierge' web application using Next.js and Supabase. The platform will connect car owners with mobile detailers, handling booking and coordination. The plan needs to cover the entire technical implementation from project setup to deployment.

Execution Strategy:
The project will be executed in four phases. Phase 1 (Foundation) will establish the project structure, database, and user authentication. Phase 2 (Core Feature Development) will focus on building the main application features like the landing page, booking system, and dashboards. Phase 3 (Integration & Testing) will ensure all components work together seamlessly and are bug-free. Phase 4 (Deployment) will make the application live. This phased approach ensures that foundational elements are completed before building dependent features, minimizing risks and rework.

Subtasks:

1. Project Setup and Initialization (Priority: 1, Expertise: Full-stack Development)
   Description: Initialize a new Next.js project using the App Router. Set up a new Supabase project and connect it to the Next.js application by configuring environment variables for the Supabase URL and anon key.
   Dependencies: None
2. Database Schema Design and Security (Priority: 2, Expertise: Backend Development)
   Description: Design and create the necessary database tables in Supabase. This includes tables for 'users', 'detailers', 'services' (detailing packages), 'bookings', and 'availability'. Define table relationships, columns, and data types. Implement Row Level Security (RLS) policies to ensure data privacy and security.
   Dependencies: project_setup
3. User Authentication (Priority: 3, Expertise: Full-stack Development)
   Description: Implement user registration and login functionality using Supabase Auth. Create sign-up and sign-in pages/components in the Next.js application. Handle user sessions and protect routes based on authentication status (e.g., separate dashboards for customers and detailers).
   Dependencies: db_schema_design
4. Landing Page and Service Display (Priority: 4, Expertise: Frontend Development)
   Description: Build a public-facing landing page that outlines the concierge service, its value proposition, and the available detailing packages. This page will fetch and display service information from the 'services' table in Supabase.
   Dependencies: project_setup
5. Implement Booking System (Priority: 5, Expertise: Full-stack Development)
   Description: Create a multi-step booking form for customers. Users should be able to select a service, view detailer availability, choose a date/time, and confirm their booking. This will write new records to the 'bookings' table and handle the logic for assigning a detailer.
   Dependencies: user_auth, db_schema_design
6. Detailer Dashboard (Priority: 6, Expertise: Full-stack Development)
   Description: Develop a secure dashboard for detailers to log in and view their assigned jobs, manage their weekly availability schedule, and view their earnings. This will involve fetching and displaying data related to their specific user ID.
   Dependencies: booking_system
7. Admin/Concierge Dashboard (Priority: 7, Expertise: Full-stack Development)
   Description: Build a comprehensive admin dashboard for the concierge to manage the entire platform. This includes adding and managing detailers, creating and updating service packages, viewing all bookings, and calculating commissions.
   Dependencies: booking_system
8. End-to-End Testing (Priority: 8, Expertise: QA Engineering)
   Description: Conduct end-to-end testing of the entire application. This includes testing the user registration and login flow, the booking process, the functionality of both the detailer and admin dashboards, and ensuring all data is being correctly read and written to the Supabase database.
   Dependencies: landing_page, booking_system, detailer_dashboard, admin_dashboard
9. Deployment to Production (Priority: 9, Expertise: DevOps Engineering)
   Description: Deploy the Next.js application to Vercel. Configure the production environment variables, set up a custom domain, and ensure the Supabase connection is secure and stable for production use.
   Dependencies: testing

**Metadata:**

```json
{
  "execution_strategy": "The project will be executed in four phases. Phase 1 (Foundation) will establish the project structure, database, and user authentication. Phase 2 (Core Feature Development) will focus on building the main application features like the landing page, booking system, and dashboards. Phase 3 (Integration & Testing) will ensure all components work together seamlessly and are bug-free. Phase 4 (Deployment) will make the application live. This phased approach ensures that foundational elements are completed before building dependent features, minimizing risks and rework.",
  "task_understanding": "The user wants to build a 'Mobile Detailing Concierge' web application using Next.js and Supabase. The platform will connect car owners with mobile detailers, handling booking and coordination. The plan needs to cover the entire technical implementation from project setup to deployment.",
  "subtasks": [
    {
      "priority": 1,
      "dependencies": [],
      "title": "Project Setup and Initialization",
      "required_expertise": "Full-stack Development",
      "description": "Initialize a new Next.js project using the App Router. Set up a new Supabase project and connect it to the Next.js application by configuring environment variables for the Supabase URL and anon key.",
      "id": "project_setup"
    },
    {
      "id": "db_schema_design",
      "required_expertise": "Backend Development",
      "description": "Design and create the necessary database tables in Supabase. This includes tables for 'users', 'detailers', 'services' (detailing packages), 'bookings', and 'availability'. Define table relationships, columns, and data types. Implement Row Level Security (RLS) policies to ensure data privacy and security.",
      "title": "Database Schema Design and Security",
      "dependencies": [
        "project_setup"
      ],
      "priority": 2
    },
    {
      "dependencies": [
        "db_schema_design"
      ],
      "required_expertise": "Full-stack Development",
      "priority": 3,
      "id": "user_auth",
      "description": "Implement user registration and login functionality using Supabase Auth. Create sign-up and sign-in pages/components in the Next.js application. Handle user sessions and protect routes based on authentication status (e.g., separate dashboards for customers and detailers).",
      "title": "User Authentication"
    },
    {
      "priority": 4,
      "description": "Build a public-facing landing page that outlines the concierge service, its value proposition, and the available detailing packages. This page will fetch and display service information from the 'services' table in Supabase.",
      "id": "landing_page",
      "required_expertise": "Frontend Development",
      "title": "Landing Page and Service Display",
      "dependencies": [
        "project_setup"
      ]
    },
    {
      "priority": 5,
      "required_expertise": "Full-stack Development",
      "id": "booking_system",
      "title": "Implement Booking System",
      "description": "Create a multi-step booking form for customers. Users should be able to select a service, view detailer availability, choose a date/time, and confirm their booking. This will write new records to the 'bookings' table and handle the logic for assigning a detailer.",
      "dependencies": [
        "user_auth",
        "db_schema_design"
      ]
    },
    {
      "dependencies": [
        "booking_system"
      ],
      "required_expertise": "Full-stack Development",
      "title": "Detailer Dashboard",
      "description": "Develop a secure dashboard for detailers to log in and view their assigned jobs, manage their weekly availability schedule, and view their earnings. This will involve fetching and displaying data related to their specific user ID.",
      "id": "detailer_dashboard",
      "priority": 6
    },
    {
      "dependencies": [
        "booking_system"
      ],
      "title": "Admin/Concierge Dashboard",
      "description": "Build a comprehensive admin dashboard for the concierge to manage the entire platform. This includes adding and managing detailers, creating and updating service packages, viewing all bookings, and calculating commissions.",
      "priority": 7,
      "id": "admin_dashboard",
      "required_expertise": "Full-stack Development"
    },
    {
      "dependencies": [
        "landing_page",
        "booking_system",
        "detailer_dashboard",
        "admin_dashboard"
      ],
      "title": "End-to-End Testing",
      "priority": 8,
      "id": "testing",
      "required_expertise": "QA Engineering",
      "description": "Conduct end-to-end testing of the entire application. This includes testing the user registration and login flow, the booking process, the functionality of both the detailer and admin dashboards, and ensuring all data is being correctly read and written to the Supabase database."
    },
    {
      "description": "Deploy the Next.js application to Vercel. Configure the production environment variables, set up a custom domain, and ensure the Supabase connection is secure and stable for production use.",
      "title": "Deployment to Production",
      "id": "deployment",
      "priority": 9,
      "dependencies": [
        "testing"
      ],
      "required_expertise": "DevOps Engineering"
    }
  ]
}
```

### Full-stack Development Specialist

Here is the detailed guide for the **Project Setup and Initialization** subtask.

### **Subtask: Project Setup and Initialization**

This first step is crucial for laying a solid foundation for our "Mobile Detailing Concierge" application. We will create a brand new Next.js project using the modern App Router and then provision and connect our Supabase backend.

---

#### **Prerequisites**

Before you begin, ensure you have the following installed and set up:

1. **Node.js**: Version 18.17 or later. You can download it from [nodejs.org](https://nodejs.org/).

2. **A Supabase Account**: If you don't have one, sign up for free at [supabase.com](https://supabase.com/).

---

#### **Step 1: Initialize the Next.js Project**

We'll use the `create-next-app` command-line tool, which bootstraps a complete Next.js application.

1. **Open your terminal** and navigate to the directory where you want to create your project.

2. **Run the following command** to start the interactive setup process:

    ```bash
    npx create-next-app@latest mobile-detailing-concierge
    ```

3. You will be prompted with a series of questions. For this project, we recommend the following settings:

    ```plaintext
    ✔ Would you like to use TypeScript? … Yes
    ✔ Would you like to use ESLint? … Yes
    ✔ Would you like to use Tailwind CSS? … Yes
    ✔ Would you like to use `src/` directory? … Yes
    ✔ Would you like to use App Router? (recommended) … Yes
    ✔ Would you like to customize the default import alias (@/*)? … No
    ```

    * **TypeScript** provides type safety, which is excellent for larger projects.
    * **Tailwind CSS** is a utility-first CSS framework that makes styling fast and efficient.
    * The **`src/` directory** helps organize your application code.
    * The **App Router** is the modern, recommended routing system for Next.js.

4. Once the installation is complete, navigate into your new project directory:

    ```bash
    cd mobile-detailing-concierge
    ```

Your Next.js application is now created and ready for development.

---

#### **Step 2: Set Up the Supabase Project**

Now, let's create the backend on Supabase which will handle our database, authentication, and storage.

1. **Go to [app.supabase.com](https://app.supabase.com/)** and log in.
2. Click the **"New project"** button.
3. Choose an organization if prompted.
4. Fill in the project details:
    * **Name**: `mobile-detailing-concierge` (or a name of your choice).
    * **Database Password**: Generate a strong, secure password and **save it somewhere safe** like a password manager. You will need this for direct database access later, but not for connecting the app.
    * **Region**: Choose the region closest to your target user base for lower latency.
5. Click **"Create new project"**. It will take a minute or two for your new backend infrastructure to be provisioned.

---

#### **Step 3: Configure Environment Variables**

To securely connect your Next.js app to Supabase, we will use environment variables. This prevents you from hard-coding sensitive API keys directly into your code.

1. In your Supabase project dashboard, navigate to **Project Settings** (the gear icon in the left sidebar).
2. Click on the **"API"** tab.
3. You will find two crucial pieces of information here:
    * **Project URL**
    * **Project API Keys** -> `anon` `public` key

4. Back in your Next.js project in your code editor, create a new file in the root directory called `.env.local`. This file will store your secret keys and is ignored by Git by default.

5. Add the following lines to your `.env.local` file, replacing the placeholders with the actual values from your Supabase dashboard:

    ```.env.local
    NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_PROJECT_URL
    NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
    ```

    > **Important**: The `NEXT_PUBLIC_` prefix is required by Next.js to expose these variables to the browser (client-side code).

6. (Optional but Recommended) Create a file named `.env.local.example` to serve as a template for other developers.

    ```.env.local.example
    NEXT_PUBLIC_SUPABASE_URL=
    NEXT_PUBLIC_SUPABASE_ANON_KEY=
    ```

    This file can be safely committed to version control.

---

#### **Step 4: Install Supabase Client Libraries**

We need to install the Supabase JavaScript libraries to interact with our backend from the Next.js application. We will use the `@supabase/ssr` package, which is specifically designed for server-side rendering environments like the Next.js App Router.

1. In your terminal, at the root of your project, run the following command:

    ```bash
    npm install @supabase/supabase-js @supabase/ssr
    ```

This installs the core Supabase client and the Server-Side Rendering helpers, which will manage authentication state across both server and client components seamlessly.

---

#### **Step 5: Create a Reusable Supabase Client**

To avoid re-initializing the Supabase client everywhere in our app, we'll create a centralized utility file.

1. Inside the `src/` directory, create a new folder structure: `lib/supabase`.
2. Inside `src/lib/supabase`, create a new file named `client.ts`.
3. Add the following code to `src/lib/supabase/client.ts`. This client is intended for use in **Client Components** (`'use client'`).

    ```typescript
    // src/lib/supabase/client.ts
    import { createBrowserClient } from '@supabase/ssr'

    export function createClient() {
      // Create a supabase client on the browser with project's credentials
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
    }
    ```

Your project is now fully set up! You have a Next.js application with the App Router, and it is securely connected to your Supabase backend. You can now start building out features like user authentication, database schema, and API routes.

**Metadata:**

```json
{
  "subtask_id": "project_setup",
  "title": "Project Setup and Initialization",
  "expertise": "Full-stack Development"
}
```

### Backend Development Specialist

Here is the detailed implementation for the **Database Schema Design and Security** subtask.

### **Subtask: Database Schema Design and Security**

This section outlines the database structure for the "Mobile Detailing Concierge" application. We will create the necessary tables, define their relationships, and implement robust Row Level Security (RLS) policies to ensure data is only accessible by authorized users.

---

#### **1. Database Schema Overview**

Our database will consist of five core tables to manage users, detailers, services, bookings, and availability.

* **`profiles`**: Extends the built-in `auth.users` table to store public user information and assign roles (`customer` or `detailer`).
* **`detailers`**: Stores specific information for users who are detailers, such as their business name and service area.
* **`services`**: A catalog of the detailing packages offered (e.g., "Full Interior Clean", "Premium Wash & Wax").
* **`bookings`**: The central table connecting customers, detailers, and services for a specific appointment.
* **`detailer_availability`**: Stores the weekly recurring availability for each detailer.

Here is a visual representation of the schema relationships:

```mermaid
erDiagram
    profiles {
        uuid id PK "FK to auth.users.id"
        varchar full_name
        varchar phone_number
        varchar avatar_url
        user_role role
        timestamp with time zone updated_at
    }

    detailers {
        uuid id PK "FK to profiles.id"
        varchar business_name
        text service_area_description
        boolean is_active
    }

    services {
        uuid id PK
        varchar name
        text description
        numeric price
        integer estimated_duration_minutes
    }

    bookings {
        uuid id PK
        uuid customer_id "FK to profiles.id"
        uuid detailer_id "FK to profiles.id"
        uuid service_id "FK to services.id"
        timestamp with time zone booking_time
        text location_address
        booking_status status
        numeric final_price
    }



    detailer_availability {
        uuid id PK
        uuid detailer_id "FK to profiles.id"
        integer day_of_week
        time start_time
        time end_time
    }

    profiles ||--o{ bookings : "places"
    profiles ||--o{ bookings : "is assigned"
    profiles ||--|| detailers : "is a"
    profiles ||--o{ detailer_availability : "sets"
    services ||--o{ bookings : "is for"

```

---

#### **2. SQL Schema Script**

This script creates the necessary custom types and tables. You can run this entire script in the Supabase SQL Editor.

1. Navigate to your Supabase project dashboard.
2. Go to the **SQL Editor** in the left sidebar.
3. Click **"+ New query"**.
4. Copy and paste the entire SQL script below and click **"RUN"**.

```sql
-- ========= CUSTOM TYPES =========
-- Create a custom type for user roles
CREATE TYPE public.user_role AS ENUM ('customer', 'detailer');

-- Create a custom type for booking status
CREATE TYPE public.booking_status AS ENUM ('pending', 'confirmed', 'completed', 'cancelled', 'reschedule_requested');

-- ========= TABLE: profiles =========
-- Stores public user data and links to auth.users
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name text,
  phone_number text,
  avatar_url text,
  role public.user_role NOT NULL DEFAULT 'customer',
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
-- Comment on table
COMMENT ON TABLE public.profiles IS 'Public profile information for each user.';

-- ========= TABLE: detailers =========
-- Stores detailer-specific information
CREATE TABLE public.detailers (
  id uuid NOT NULL PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  business_name text,
  service_area_description text,
  is_active boolean NOT NULL DEFAULT false, -- Admin can toggle this
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
-- Comment on table
COMMENT ON TABLE public.detailers IS 'Stores information specific to detailer profiles.';

-- ========= TABLE: services =========
-- Stores the available detailing packages
CREATE TABLE public.services (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  name text NOT NULL,
  description text,
  price numeric(10, 2) NOT NULL CHECK (price > 0),
  estimated_duration_minutes integer NOT NULL CHECK (estimated_duration_minutes > 0),
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
-- Comment on table
COMMENT ON TABLE public.services IS 'Catalog of detailing packages offered.';

-- ========= TABLE: bookings =========
-- The core table for appointments
CREATE TABLE public.bookings (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  detailer_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL, -- Can be NULL if unassigned
  service_id uuid NOT NULL REFERENCES public.services(id),
  booking_time timestamp with time zone NOT NULL,
  location_address text NOT NULL,
  status public.booking_status NOT NULL DEFAULT 'pending',
  final_price numeric(10, 2) NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
-- Comment on table
COMMENT ON TABLE public.bookings IS 'Stores all booking appointments.';
-- Add indexes for faster lookups
CREATE INDEX ON public.bookings (customer_id);
CREATE INDEX ON public.bookings (detailer_id);
CREATE INDEX ON public.bookings (service_id);


-- ========= TABLE: detailer_availability =========
-- Stores recurring weekly availability for detailers
CREATE TABLE public.detailer_availability (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  detailer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_of_week smallint NOT NULL CHECK (day_of_week >= 0 AND day_of_week <= 6), -- 0=Sunday, 6=Saturday
  start_time time NOT NULL,
  end_time time NOT NULL,
  UNIQUE (detailer_id, day_of_week) -- A detailer can only have one entry per day
);
-- Comment on table
COMMENT ON TABLE public.detailer_availability IS 'Stores recurring weekly availability for detailers.';
-- Add index for faster lookups
CREATE INDEX ON public.detailer_availability (detailer_id);

-- ========= FUNCTION TO CREATE PROFILE ON SIGNUP =========
-- This trigger automatically creates a profile entry when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ========= TRIGGER FOR NEW USER SIGNUP =========
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

```

---

#### **3. Row Level Security (RLS) Policies**

RLS is a critical security feature that ensures users can only access the data they are permitted to. The following script enables RLS on all tables and defines specific access rules.

Run this script in the Supabase **SQL Editor** after the schema script has been successfully executed.

```sql
-- ========= ENABLE RLS FOR ALL TABLES =========
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detailers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detailer_availability ENABLE ROW LEVEL SECURITY;

-- ========= RLS POLICIES FOR 'profiles' TABLE =========
-- 1. Users can see their own profile.
CREATE POLICY "Users can view their own profile"
ON public.profiles FOR SELECT
USING (auth.uid() = id);

-- 2. Users can update their own profile.
CREATE POLICY "Users can update their own profile"
ON public.profiles FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- 3. Authenticated users can see the profiles of active detailers.
CREATE POLICY "Authenticated users can view active detailer profiles"
ON public.profiles FOR SELECT
USING (
  (role = 'detailer') AND
  (EXISTS (
    SELECT 1
    FROM public.detailers
    WHERE detailers.id = profiles.id AND detailers.is_active = true
  ))
);

-- ========= RLS POLICIES FOR 'detailers' TABLE =========
-- 1. Detailers can view and manage their own detailer-specific profile.
CREATE POLICY "Detailers can manage their own detailer profile"
ON public.detailers FOR ALL
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- 2. Authenticated users can view active detailer profiles.
CREATE POLICY "Authenticated users can view active detailer profiles"
ON public.detailers FOR SELECT
USING (is_active = true);


-- ========= RLS POLICIES FOR 'services' TABLE =========
-- 1. Any authenticated user can view active services.
CREATE POLICY "Authenticated users can view active services"
ON public.services FOR SELECT
USING (auth.role() = 'authenticated' AND is_active = true);
-- NOTE: For now, we assume an admin will add services via the Supabase dashboard.
-- You could later create an 'admin' role and policies for INSERT/UPDATE/DELETE.


-- ========= RLS POLICIES FOR 'bookings' TABLE =========
-- 1. Customers can create new bookings for themselves.
CREATE POLICY "Customers can create their own bookings"
ON public.bookings FOR INSERT
WITH CHECK (auth.uid() = customer_id AND status = 'pending');

-- 2. Customers can view their own bookings.
CREATE POLICY "Customers can view their own bookings"
ON public.bookings FOR SELECT
USING (auth.uid() = customer_id);

-- 3. Detailers can view bookings assigned to them.
CREATE POLICY "Detailers can view bookings assigned to them"
ON public.bookings FOR SELECT
USING (auth.uid() = detailer_id);

-- 4. Customers and detailers can update the status of their bookings.
--    Customers can cancel or request reschedule.
--    Detailers can confirm, complete, cancel, or request reschedule.
CREATE POLICY "Users can update their own bookings"
ON public.bookings FOR UPDATE
USING (auth.uid() = customer_id OR auth.uid() = detailer_id);
-- The WITH CHECK clause can be added later for more granular control if needed.


-- ========= RLS POLICIES FOR 'detailer_availability' TABLE =========
-- 1. Detailers can manage their own availability.
CREATE POLICY "Detailers can create, view, update, and delete their own availability"
ON public.detailer_availability FOR ALL
USING (auth.uid() = detailer_id)
WITH CHECK (auth.uid() = detailer_id);

-- 2. Any authenticated user can view the availability of detailers.
--    This is necessary for the booking system to find available slots.
CREATE POLICY "Authenticated users can view detailer availability"
ON public.detailer_availability FOR SELECT
USING (auth.role() = 'authenticated');

```

Your database is now fully configured with a logical schema and essential security policies, providing a solid and secure foundation for building the application's features.

**Metadata:**

```json
{
  "subtask_id": "db_schema_design",
  "title": "Database Schema Design and Security",
  "expertise": "Backend Development"
}
```

### Frontend Development Specialist

Here is the detailed guide for implementing the **Landing Page and Service Display** subtask.

### **Subtask: Landing Page and Service Display**

This guide will walk you through creating a public-facing landing page for the "Mobile Detailing Concierge" service. We will set up the necessary database table in Supabase, fetch the detailing packages, and display them in a clean, professional layout using Next.js Server Components and Tailwind CSS.

---

#### **Prerequisites**

* You must have completed the **Project Setup and Initialization** subtask.
* Your Next.js project should be running and connected to your Supabase instance via environment variables.

---

#### **Step 1: Create the `services` Table in Supabase**

First, we need a place to store our detailing packages. We'll create a `services` table in the Supabase database.

1. **Navigate to the Supabase Dashboard**: Go to [app.supabase.com](https://app.supabase.com/) and select your `mobile-detailing-concierge` project.
2. **Open the SQL Editor**: In the left sidebar, click on the database icon and then select **SQL Editor**.
3. **Create the Table**: Click **"+ New query"**. Copy the following SQL script into the editor and click **"RUN"**. This script creates the `services` table with columns for a name, description, price, and a list of included features.

    ```sql
    -- Create the services table
    CREATE TABLE services (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        price NUMERIC(10, 2) NOT NULL,
        features TEXT[] NOT NULL, -- An array of text for the feature list
        created_at TIMESTAMPTZ DEFAULT NOW()
    );

    -- Add comments for clarity
    COMMENT ON TABLE services IS 'Stores the detailing packages offered.';
    COMMENT ON COLUMN services.name IS 'The name of the detailing package (e.g., "Full Interior Detail").';
    COMMENT ON COLUMN services.price IS 'The starting price for the service.';
    COMMENT ON COLUMN services.features IS 'A list of what is included in the package.';
    ```

4. **Enable Row Level Security (RLS)**: For security, it's crucial to enable RLS on your new table. This ensures that data is not accessible by default.
    * In the left sidebar, navigate to **Authentication** -> **Policies**.
    * Find the `services` table and click **"Enable RLS"**.

5. **Create a Read Policy**: Now, we'll create a policy that allows anyone (even unauthenticated users) to *read* the services. This is necessary for our public landing page.
    * On the same policies page, click **"New Policy"** next to the `services` table.
    * Choose **"Create a new policy from scratch"**.
    * **Policy name**: `Allow public read access to services`
    * **Allowed operation**: Check **SELECT**.
    * **Target roles**: Keep this as `public`.
    * **USING expression**: Set this to `true`. This means the condition for reading is always met.
    * Click **"Review"** and then **"Save policy"**.

6. **Insert Sample Data**: Let's add some sample detailing packages so we have something to display. Run this query in the **SQL Editor**:

    ```sql
    -- Insert sample detailing packages
    INSERT INTO services (name, description, price, features)
    VALUES
    (
        'Exterior Wash & Wax',
        'A thorough exterior clean to make your car shine.',
        79.99,
        ARRAY['Hand wash and dry', 'Wheel and tire cleaning', 'Tire shine', 'Carnauba wax application']
    ),
    (
        'Full Interior Detail',
        'Deep cleaning for a spotless and fresh interior.',
        149.99,
        ARRAY['Thorough vacuuming', 'Shampoo carpets and seats', 'Leather cleaning and conditioning', 'Dashboard and console detailing', 'Window cleaning']
    ),
    (
        'The Concierge Special',
        'The ultimate package for a pristine, showroom-quality finish, inside and out.',
        229.99,
        ARRAY['Includes all Exterior & Interior features', 'Clay bar treatment', 'Paint sealant application', 'Engine bay cleaning']
    );
    ```

Your backend is now ready with the necessary data.

---

#### **Step 2: Create a Supabase Server Client**

For fetching data in Server Components (which is the default in the App Router), we need a Supabase client instance that works on the server.

1. Navigate to `src/lib/supabase/` in your project.
2. Create a new file named `server.ts`.
3. Add the following code. This utility creates a server-side Supabase client that securely reads cookies from incoming requests.

    ```typescript
    // src/lib/supabase/server.ts
    import { createServerClient, type CookieOptions } from '@supabase/ssr'
    import { cookies } from 'next/headers'

    export function createClient() {
      const cookieStore = cookies()

      // Create a server-side client for Supabase.
      return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          cookies: {
            get(name: string) {
              return cookieStore.get(name)?.value
            },
            set(name: string, value: string, options: CookieOptions) {
              try {
                cookieStore.set({ name, value, ...options })
              } catch (error) {
                // The `set` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
              }
            },
            remove(name: string, options: CookieOptions) {
              try {
                cookieStore.set({ name, value: '', ...options })
              } catch (error) {
                // The `delete` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
              }
            },
          },
        }
      )
    }
    ```

---

#### **Step 3: Define a Type for Your Service Data**

Using TypeScript helps prevent errors and improves autocompletion. Let's define a type for our `Service` object.

1. Create a new directory `src/types`.
2. Inside it, create a file `index.ts`.
3. Add the following type definition:

    ```typescript
    // src/types/index.ts
    export type Service = {
      id: number;
      name: string;
      description: string | null;
      price: number;
      features: string[];
    };
    ```

---

#### **Step 4: Build the UI Components**

Let's create reusable components for our landing page.

1. **Create a `components` directory** inside `src/`.
2. **Create the `ServiceCard` Component**: This will display a single detailing package.
    * Create `src/components/ServiceCard.tsx` and add the following code:

    ```tsx
    // src/components/ServiceCard.tsx
    import { CheckCircleIcon } from '@heroicons/react/24/solid';
    import { Service } from '@/types';

    interface ServiceCardProps {
      service: Service;
    }

    export default function ServiceCard({ service }: ServiceCardProps) {
      return (
        <div className="flex flex-col rounded-lg shadow-lg overflow-hidden border border-gray-200">
          <div className="px-6 py-8 bg-white sm:p-10 sm:pb-6">
            <div>
              <h3 className="inline-flex px-4 py-1 rounded-full text-sm font-semibold tracking-wider uppercase bg-indigo-100 text-indigo-600">
                {service.name}
              </h3>
            </div>
            <div className="mt-4 flex items-baseline text-6xl font-extrabold text-gray-900">
              ${service.price}
              <span className="ml-1 text-2xl font-medium text-gray-500">.00</span>
            </div>
            <p className="mt-5 text-lg text-gray-500">{service.description}</p>
          </div>
          <div className="flex-1 flex flex-col justify-between px-6 pt-6 pb-8 bg-gray-50 space-y-6 sm:p-10 sm:pt-6">
            <ul role="list" className="space-y-4">
              {service.features.map((feature) => (
                <li key={feature} className="flex items-start">
                  <div className="flex-shrink-0">
                    <CheckCircleIcon className="h-6 w-6 text-green-500" aria-hidden="true" />
                  </div>
                  <p className="ml-3 text-base font-medium text-gray-700">{feature}</p>
                </li>
              ))}
            </ul>
            <div className="rounded-md shadow">
              <a
                href="#" // This will later link to the booking page for this service
                className="flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700"
              >
                Book Now
              </a>
            </div>
          </div>
        </div>
      );
    }
    ```

    * You'll need to install `@heroicons/react` for the checkmark icon:

        ```bash
        npm install @heroicons/react
        ```

---

#### **Step 5: Assemble the Landing Page**

Now, let's update the main page file to fetch and display the services.

1. **Open `src/app/page.tsx`**.
2. **Replace its entire content** with the following code. This turns the page into an `async` Server Component, fetches data from Supabase, and renders the UI.

    ```tsx
    // src/app/page.tsx
    import { createClient } from "@/lib/supabase/server";
    import ServiceCard from "@/components/ServiceCard";
    import { Service } from "@/types";

    export default async function HomePage() {
      const supabase = createClient();

      // Fetch services data from Supabase
      const { data: services, error } = await supabase
        .from('services')
        .select('*')
        .order('price', { ascending: true });

      if (error) {
        console.error('Error fetching services:', error);
        // You can render an error message to the user here
      }

      return (
        <div className="bg-gray-100 min-h-screen">
          <main>
            {/* Hero Section */}
            <div className="relative bg-white">
              <div className="max-w-7xl mx-auto py-16 px-4 sm:py-24 sm:px-6 lg:px-8">
                <div className="text-center">
                  <h1 className="text-4xl font-extrabold text-gray-900 sm:text-5xl sm:tracking-tight lg:text-6xl">
                    Mobile Detailing Concierge
                  </h1>
                  <p className="mt-5 max-w-xl mx-auto text-xl text-gray-500">
                    We connect you with top-rated local detailers. Premium car care, delivered to your door.
                  </p>
                </div>
              </div>
            </div>

            {/* Services Section */}
            <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8">
              <h2 className="text-3xl font-extrabold text-gray-900 text-center mb-12">
                Our Packages
              </h2>

              {services && services.length > 0 ? (
                <div className="mt-12 space-y-4 sm:mt-16 sm:space-y-0 sm:grid sm:grid-cols-1 sm:gap-6 lg:max-w-4xl lg:mx-auto xl:max-w-none xl:mx-0 xl:grid-cols-3">
                  {services.map((service) => (
                    <ServiceCard key={service.id} service={service as Service} />
                  ))}
                </div>
              ) : (
                <p className="text-center text-gray-500">
                  No detailing packages are available at the moment. Please check back later.
                </p>
              )}

              {error && (
                 <p className="text-center text-red-500 mt-4">
                  Could not load services. Please try refreshing the page.
                </p>
              )}
            </div>
          </main>
        </div>
      );
    }
    ```

---

#### **Step 6: Run and Verify**

1. Start your development server if it's not already running:

    ```bash
    npm run dev
    ```

2. Open your browser and navigate to `http://localhost:3000`.

You should now see a professional-looking landing page with a hero section and three service cards displaying the sample data you entered into your Supabase database. The data is fetched on the server when the page is requested, making it fast and SEO-friendly.

**Metadata:**

```json
{
  "subtask_id": "landing_page",
  "title": "Landing Page and Service Display",
  "expertise": "Frontend Development"
}
```

### Full-stack Development Specialist

Here is the detailed implementation for the **User Authentication** subtask.

### **Subtask: User Authentication**

This guide will walk you through setting up a complete authentication system using Next.js App Router and Supabase. We will implement user registration, login, session management, and role-based route protection for both "customer" and "detailer" user types.

---

#### **1. Environment Setup and Supabase Client**

First, we need to install the necessary Supabase libraries and configure our environment variables. The `@supabase/ssr` library is specifically designed for server-side rendering frameworks like Next.js and simplifies session management.

**A. Install Supabase Packages**

Open your terminal in the root of your Next.js project and run:

```bash
npm install @supabase/supabase-js @supabase/ssr
```

**B. Configure Environment Variables**

Create a file named `.env.local` in the root of your project. Add your Supabase Project URL and Anon Key, which you can find in your Supabase project dashboard under **Project Settings > API**.

```.env.local
NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
```

**Important:** Restart your Next.js development server after creating or modifying this file.

**C. Create Supabase Client Helpers**

The `@supabase/ssr` library requires slightly different client initializations for use in Client Components, Server Components, and Middleware. Let's create these helpers in a structured way.

Create a new folder `lib/supabase`. Inside it, create three files:

**`lib/supabase/client.ts`** (For use in Client Components)

```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**`lib/supabase/server.ts`** (For use in Server Components & Server Actions)

```typescript
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export function createClient() {
  const cookieStore = cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.delete({ name, ...options })
          } catch (error) {
            // The `delete` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

---

#### **2. Authentication UI (Login & Signup Pages)**

We'll use Next.js Server Actions to handle form submissions, which keeps our authentication logic secure on the server.

**A. Create the Login Page**

This page will contain a form that calls a server action to sign the user in.

**`app/login/page.tsx`**

```tsx
import { createClient } from '@/lib/supabase/server'
import { headers } from 'next/headers'
import { redirect } from 'next/navigation'
import Link from 'next/link'

export default function Login({ searchParams }: { searchParams: { message: string } }) {
  const signIn = async (formData: FormData) => {
    'use server'

    const email = formData.get('email') as string
    const password = formData.get('password') as string
    const supabase = createClient()

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      return redirect(`/login?message=Could not authenticate user: ${error.message}`)
    }
    
    // After successful login, get the user's role and redirect
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
        return redirect('/login?message=User not found after login.');
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profile?.role === 'detailer') {
        return redirect('/dashboard/detailer');
    }

    return redirect('/dashboard/customer')
  }

  return (
    <div className="flex-1 flex flex-col w-full px-8 sm:max-w-md justify-center gap-2">
      <Link href="/" className="absolute left-8 top-8 py-2 px-4 rounded-md no-underline text-foreground bg-btn-background hover:bg-btn-background-hover flex items-center group text-sm">
        {/* Back arrow SVG */}
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4 transition-transform group-hover:-translate-x-1"><polyline points="15 18 9 12 15 6" /></svg> Back
      </Link>
      <form className="animate-in flex-1 flex flex-col w-full justify-center gap-2 text-foreground" action={signIn}>
        <label className="text-md" htmlFor="email">Email</label>
        <input className="rounded-md px-4 py-2 bg-inherit border mb-6" name="email" placeholder="you@example.com" required />
        <label className="text-md" htmlFor="password">Password</label>
        <input className="rounded-md px-4 py-2 bg-inherit border mb-6" type="password" name="password" placeholder="••••••••" required />
        <button className="bg-green-700 rounded-md px-4 py-2 text-foreground mb-2">Sign In</button>
        <Link href="/signup" className="border border-foreground/20 rounded-md px-4 py-2 text-foreground mb-2 text-center">Sign Up</Link>
        {searchParams?.message && (
          <p className="mt-4 p-4 bg-foreground/10 text-foreground text-center">
            {searchParams.message}
          </p>
        )}
      </form>
    </div>
  )
}
```

**B. Create the Signup Page**

This page allows new users to register. Note that Supabase enables "Confirm email" by default, which is a crucial security feature.

**`app/signup/page.tsx`**

```tsx
import { headers } from 'next/headers'
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import Link from 'next/link'

export default function Signup({ searchParams }: { searchParams: { message: string } }) {
  const signUp = async (formData: FormData) => {
    'use server'

    const origin = headers().get('origin')
    const email = formData.get('email') as string
    const password = formData.get('password') as string
    const fullName = formData.get('fullName') as string
    // Simple role selection for signup form
    const role = formData.get('role') as 'customer' | 'detailer';

    const supabase = createClient()

    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${origin}/auth/callback`,
        // Pass user metadata that the trigger `handle_new_user` will use
        data: {
          full_name: fullName,
        },
      },
    })

    if (error) {
      return redirect(`/signup?message=Could not authenticate user: ${error.message}`)
    }
    
    // After signup, update the role in the profiles table
    // The profile is created by the trigger, so we just need to update it.
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ role: role })
            .eq('id', user.id);
        
        if (updateError) {
            console.error("Error updating role:", updateError.message);
            // Handle this error appropriately
        }
    }

    return redirect('/signup?message=Check email to continue sign in process')
  }

  return (
    <div className="flex-1 flex flex-col w-full px-8 sm:max-w-md justify-center gap-2">
      <Link href="/" className="absolute left-8 top-8 py-2 px-4 rounded-md no-underline text-foreground bg-btn-background hover:bg-btn-background-hover flex items-center group text-sm">
        {/* Back arrow SVG */}
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4 transition-transform group-hover:-translate-x-1"><polyline points="15 18 9 12 15 6" /></svg> Back
      </Link>
      <form className="animate-in flex-1 flex flex-col w-full justify-center gap-2 text-foreground" action={signUp}>
        <label className="text-md" htmlFor="fullName">Full Name</label>
        <input className="rounded-md px-4 py-2 bg-inherit border mb-6" name="fullName" placeholder="John Doe" required />
        <label className="text-md" htmlFor="email">Email</label>
        <input className="rounded-md px-4 py-2 bg-inherit border mb-6" name="email" placeholder="you@example.com" required />
        <label className="text-md" htmlFor="password">Password</label>
        <input className="rounded-md px-4 py-2 bg-inherit border mb-6" type="password" name="password" placeholder="••••••••" required />
        
        <label className="text-md" htmlFor="role">I am a:</label>
        <select name="role" className="rounded-md px-4 py-2 bg-inherit border mb-6">
            <option value="customer">Car Owner</option>
            <option value="detailer">Detailer</option>
        </select>

        <button className="bg-green-700 rounded-md px-4 py-2 text-foreground mb-2">Sign Up</button>
        <Link href="/login" className="border border-foreground/20 rounded-md px-4 py-2 text-foreground mb-2 text-center">Already have an account? Sign In</Link>
        {searchParams?.message && (
          <p className="mt-4 p-4 bg-foreground/10 text-foreground text-center">
            {searchParams.message}
          </p>
        )}
      </form>
    </div>
  )
}
```

---

#### **3. Handling Auth Callbacks**

When a user signs up, Supabase sends them a confirmation email. Clicking the link in that email will direct them to the `/auth/callback` route with a special code. This route exchanges that code for a valid user session.

Create the following file:

**`app/auth/callback/route.ts`**

```typescript
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  // if "next" is in param, use it as the redirect URL
  const next = searchParams.get('next') ?? '/'

  if (code) {
    const supabase = createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // return the user to an error page with instructions
  return NextResponse.redirect(`${origin}/login?message=Could not log you in. Please try again.`)
}
```

---

#### **4. Middleware for Route Protection**

Middleware is the most effective way to protect routes in Next.js. It runs on the server before a request is completed. We will protect all routes under `/dashboard`.

**A. Create Middleware Supabase Client**

**`lib/supabase/middleware.ts`**

```typescript
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { type NextRequest, type NextResponse } from 'next/server'

export async function updateSession(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  // This will refresh the session if it's expired
  await supabase.auth.getUser()

  return response
}
```

**B. Create the Middleware File**

Create a `middleware.ts` file in the root of your project (at the same level as `app` and `pages`).

**`middleware.ts`**

```typescript
import { NextResponse, type NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/middleware' // This should be the middleware client

export async function middleware(request: NextRequest) {
  const { supabase, response } = createClient(request)

  // Refresh session if expired - required for Server Components
  const {
    data: { session },
  } = await supabase.auth.getSession()

  const { pathname } = request.nextUrl

  // If user is not logged in and is trying to access a protected route, redirect to login
  if (!session && pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // If user is logged in and tries to access login/signup page, redirect to their dashboard
  if (session && (pathname === '/login' || pathname === '/signup')) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', session.user.id)
      .single()

    if (profile?.role === 'detailer') {
      return NextResponse.redirect(new URL('/dashboard/detailer', request.url))
    }
    return NextResponse.redirect(new URL('/dashboard/customer', request.url))
  }

  return response
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
```

---

#### **5. Dashboards and Sign-Out**

Finally, let's create the protected dashboard pages and a sign-out button.

**A. Create Placeholder Dashboards**

These pages will only be accessible to logged-in users due to our middleware.

**`app/dashboard/customer/page.tsx`**

```tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import SignOutButton from '@/components/SignOutButton'

export default async function CustomerDashboard() {
  const supabase = createClient()

  const { data, error } = await supabase.auth.getUser()
  if (error || !data?.user) {
    redirect('/login')
  }

  return (
    <div>
      <h1>Welcome, Customer!</h1>
      <p>This is your dashboard.</p>
      <p>Your email: {data.user.email}</p>
      <SignOutButton />
    </div>
  )
}
```

**`app/dashboard/detailer/page.tsx`**

```tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import SignOutButton from '@/components/SignOutButton'

export default async function DetailerDashboard() {
  const supabase = createClient()

  const { data, error } = await supabase.auth.getUser()
  if (error || !data?.user) {
    redirect('/login')
  }

  return (
    <div>
      <h1>Welcome, Detailer!</h1>
      <p>This is your dashboard where you can manage your bookings and availability.</p>
      <p>Your email: {data.user.email}</p>
      <SignOutButton />
    </div>
  )
}
```

**B. Create the Sign-Out Button Component**

The sign-out action must be handled on the server, but the button itself is a client component because it uses an `onClick` event.

Create a new file: `components/SignOutButton.tsx`

```tsx
export default function SignOutButton() {
  return (
    <form action="/auth/signout" method="post">
      <button className="py-2 px-4 rounded-md no-underline bg-btn-background hover:bg-btn-background-hover">
        Logout
      </button>
    </form>
  )
}
```

**C. Create the Sign-Out Server Action**

Create a route handler that signs the user out.

**`app/auth/signout/route.ts`**

```typescript
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(req: NextRequest) {
  const supabase = createClient()

  // Check if a user's session exists
  const {
    data: { session },
  } = await supabase.auth.getSession()

  if (session) {
    await supabase.auth.signOut()
  }
  
  revalidatePath('/', 'layout')
  return NextResponse.redirect(new URL('/login', req.url), {
    status: 302,
  })
}
```

Your authentication system is now complete. You have:

* Separate sign-up and sign-in pages.
* Secure handling of credentials via Server Actions.
* Robust route protection using middleware.
* Role-based redirects to different dashboards for customers and detailers.
* A fully functional sign-out process.

**Metadata:**

```json
{
  "subtask_id": "user_auth",
  "title": "User Authentication",
  "expertise": "Full-stack Development"
}
```

### Full-stack Development Specialist

Here is the detailed implementation for the **Booking System** subtask.

This implementation creates a multi-step booking form on a dedicated `/book` page, allowing customers to select a service, choose an available date and time, and confirm their appointment. It uses Next.js Server Actions to securely handle availability checks and booking creation.

---

### **1. Create Server Actions for Booking Logic**

Server actions are the secure bridge between our client-side form and the server-side database logic. Let's create a dedicated file for them.

**`app/book/actions.ts`**

```typescript
'use server'

import { createClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { addMinutes, format, getDay, parseISO, startOfDay } from 'date-fns';

// Define types for clarity
type Service = {
  id: string;
  name: string;
  description: string;
  price: number;
  estimated_duration_minutes: number;
};

// Action to fetch all active services
export async function getServices(): Promise<Service[]> {
    const supabase = createClient();
    const { data, error } = await supabase
        .from('services')
        .select('*')
        .eq('is_active', true)
        .order('price');

    if (error) {
        console.error('Error fetching services:', error);
        return [];
    }
    return data;
}

// Action to get available time slots for a given date and service duration
export async function getAvailableSlots(selectedDate: string, serviceDuration: number): Promise<string[]> {
    const supabase = createClient();
    const date = parseISO(selectedDate);
    const dayOfWeek = getDay(date); // 0 = Sunday, 6 = Saturday

    // 1. Fetch all active detailers and their availability for the selected day of the week
    const { data: detailers, error: detailerError } = await supabase
        .from('detailers')
        .select(`
            id,
            detailer_availability (
                day_of_week,
                start_time,
                end_time
            )
        `)
        .eq('is_active', true)
        .eq('detailer_availability.day_of_week', dayOfWeek);

    if (detailerError) {
        console.error('Error fetching detailer availability:', detailerError);
        return [];
    }

    if (!detailers || detailers.length === 0) {
        return []; // No detailers available on this day
    }

    // 2. Fetch all bookings for the selected date
    const startOfSelectedDay = startOfDay(date);
    const endOfSelectedDay = addMinutes(startOfSelectedDay, 24 * 60);

    const { data: bookings, error: bookingError } = await supabase
        .from('bookings')
        .select('detailer_id, booking_time, service_id, services(estimated_duration_minutes)')
        .in('status', ['pending', 'confirmed'])
        .gte('booking_time', startOfSelectedDay.toISOString())
        .lt('booking_time', endOfSelectedDay.toISOString());

    if (bookingError) {
        console.error('Error fetching bookings:', bookingError);
        return [];
    }
    
    // Create a map of detailer bookings for quick lookup
    const detailerBookings: Record<string, { start: Date; end: Date }[]> = {};
    bookings?.forEach((booking: any) => {
        if (!detailerBookings[booking.detailer_id]) {
            detailerBookings[booking.detailer_id] = [];
        }
        const bookingStart = parseISO(booking.booking_time);
        const bookingEnd = addMinutes(bookingStart, booking.services.estimated_duration_minutes);
        detailerBookings[booking.detailer_id].push({ start: bookingStart, end: bookingEnd });
    });

    // 3. Generate and filter time slots
    const allAvailableSlots = new Set<string>();
    const timeSlotInterval = 30; // Check for a slot every 30 minutes

    for (const detailer of detailers) {
        const availability = detailer.detailer_availability[0];
        if (!availability) continue;

        const [startHour, startMinute] = availability.start_time.split(':').map(Number);
        const [endHour, endMinute] = availability.end_time.split(':').map(Number);

        let currentTime = new Date(date);
        currentTime.setHours(startHour, startMinute, 0, 0);

        const endTime = new Date(date);
        endTime.setHours(endHour, endMinute, 0, 0);

        while (currentTime < endTime) {
            const potentialSlotStart = new Date(currentTime);
            const potentialSlotEnd = addMinutes(potentialSlotStart, serviceDuration);

            if (potentialSlotEnd > endTime) {
                break; // Slot extends beyond detailer's availability
            }

            // Check for conflicts with existing bookings for this specific detailer
            const isConflict = detailerBookings[detailer.id]?.some(booking => 
                (potentialSlotStart < booking.end && potentialSlotEnd > booking.start)
            );

            if (!isConflict) {
                allAvailableSlots.add(potentialSlotStart.toISOString());
            }

            currentTime = addMinutes(currentTime, timeSlotInterval);
        }
    }

    return Array.from(allAvailableSlots).sort();
}


// Action to create the final booking
export async function createBooking(formData: FormData) {
    const supabase = createClient();

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
        return redirect('/login');
    }

    const rawFormData = {
        serviceId: formData.get('serviceId') as string,
        bookingTime: formData.get('bookingTime') as string,
        locationAddress: formData.get('locationAddress') as string,
    };

    // 1. Fetch service details to get price and duration
    const { data: service, error: serviceError } = await supabase
        .from('services')
        .select('price, estimated_duration_minutes')
        .eq('id', rawFormData.serviceId)
        .single();
    
    if (serviceError || !service) {
        console.error("Service not found");
        return redirect('/book?error=Service not found');
    }

    // 2. Re-verify availability and find a detailer to assign
    const availableSlots = await getAvailableSlots(rawFormData.bookingTime, service.estimated_duration_minutes);
    if (!availableSlots.includes(rawFormData.bookingTime)) {
        return redirect('/book?error=The selected time slot is no longer available. Please choose another.');
    }

    // Find a detailer who is free at this time (simple assignment: first one found)
    // In a real app, this could be round-robin, location-based, etc.
    const { data: availableDetailers, error: detailerError } = await supabase.rpc('find_available_detailer', {
        slot_time: rawFormData.bookingTime,
        service_duration: service.estimated_duration_minutes
    });

    if (detailerError || !availableDetailers || availableDetailers.length === 0) {
        console.error("No available detailer found on re-check:", detailerError);
        return redirect('/book?error=Could not assign a detailer. Please try another time.');
    }

    const assignedDetailerId = availableDetailers[0].id;

    // 3. Create the booking
    const { error: insertError } = await supabase
        .from('bookings')
        .insert({
            customer_id: user.id,
            detailer_id: assignedDetailerId,
            service_id: rawFormData.serviceId,
            booking_time: rawFormData.bookingTime,
            location_address: rawFormData.locationAddress,
            status: 'pending',
            final_price: service.price,
        });

    if (insertError) {
        console.error("Error creating booking:", insertError);
        return redirect(`/book?error=${insertError.message}`);
    }

    // 4. Redirect to a success page or the customer's dashboard
    revalidatePath('/dashboard/customer');
    redirect('/dashboard/customer?message=Booking successful!');
}
```

### **2. Create a Helper SQL Function**

The `createBooking` action needs a way to find an available detailer. A PostgreSQL function is the most efficient way to do this. Run this in your Supabase SQL Editor.

```sql
-- This function finds the ID of a detailer who is available at a specific time for a given duration.
CREATE OR REPLACE FUNCTION find_available_detailer(slot_time timestamptz, service_duration int)
RETURNS TABLE (id uuid) AS $$
DECLARE
    slot_end_time timestamptz;
    slot_day_of_week int;
BEGIN
    slot_end_time := slot_time + (service_duration * interval '1 minute');
    slot_day_of_week := EXTRACT(DOW FROM slot_time);

    RETURN QUERY
    SELECT d.id
    FROM public.detailers d
    -- Check 1: Is the detailer active and available on this day of the week?
    JOIN public.detailer_availability da ON d.id = da.detailer_id
    WHERE d.is_active = true
      AND da.day_of_week = slot_day_of_week
      -- Check 2: Does the requested slot fall within their working hours?
      AND (slot_time::time >= da.start_time AND slot_end_time::time <= da.end_time)
      -- Check 3: Does the detailer have any conflicting bookings?
      AND NOT EXISTS (
          SELECT 1
          FROM public.bookings b
          JOIN public.services s ON b.service_id = s.id
          WHERE b.detailer_id = d.id
            AND b.status IN ('pending', 'confirmed')
            AND (b.booking_time, b.booking_time + (s.estimated_duration_minutes * interval '1 minute'))
                OVERLAPS (slot_time, slot_end_time)
      )
    LIMIT 1; -- Return the first one found for simplicity
END;
$$ LANGUAGE plpgsql;
```

### **3. Build the Multi-Step Booking Form**

Now, let's create the user-facing component. This will be a client component to manage the state of the multi-step form.

**`app/book/page.tsx`**

```tsx
'use client'

import { useState, useEffect, useTransition } from 'react';
import { getServices, getAvailableSlots, createBooking } from './actions';
import { format, parseISO } from 'date-fns';

// Define a type for the service object
type Service = {
    id: string;
    name: string;
    description: string;
    price: number;
    estimated_duration_minutes: number;
};

export default function BookingPage() {
    const [step, setStep] = useState(1);
    const [services, setServices] = useState<Service[]>([]);
    const [selectedService, setSelectedService] = useState<Service | null>(null);
    const [selectedDate, setSelectedDate] = useState('');
    const [availableSlots, setAvailableSlots] = useState<string[]>([]);
    const [selectedSlot, setSelectedSlot] = useState('');
    const [locationAddress, setLocationAddress] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    
    let [isPending, startTransition] = useTransition();

    // Fetch services on component mount
    useEffect(() => {
        const fetchServices = async () => {
            setIsLoading(true);
            const fetchedServices = await getServices();
            setServices(fetchedServices);
            setIsLoading(false);
        };
        fetchServices();
    }, []);

    // Fetch available slots when a date is selected
    useEffect(() => {
        if (selectedDate && selectedService) {
            const fetchSlots = async () => {
                setIsLoading(true);
                const slots = await getAvailableSlots(selectedDate, selectedService.estimated_duration_minutes);
                setAvailableSlots(slots);
                setSelectedSlot(''); // Reset selected slot when date changes
                setIsLoading(false);
            };
            fetchSlots();
        }
    }, [selectedDate, selectedService]);

    const handleServiceSelect = (service: Service) => {
        setSelectedService(service);
        setStep(2);
    };

    const handleSlotSelect = (slot: string) => {
        setSelectedSlot(slot);
        setStep(3);
    };

    const today = format(new Date(), 'yyyy-MM-dd');

    return (
        <div className="container mx-auto p-8 max-w-2xl">
            <h1 className="text-3xl font-bold mb-6">Book Your Mobile Detailing</h1>
            
            {/* Step 1: Select Service */}
            {step === 1 && (
                <div>
                    <h2 className="text-2xl font-semibold mb-4">Step 1: Choose a Service</h2>
                    {isLoading && <p>Loading services...</p>}
                    <div className="space-y-4">
                        {services.map((service) => (
                            <div key={service.id} className="p-4 border rounded-lg flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold">{service.name}</h3>
                                    <p className="text-sm text-gray-600">{service.description}</p>
                                    <p className="text-lg font-semibold">${service.price}</p>
                                </div>
                                <button onClick={() => handleServiceSelect(service)} className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">
                                    Select
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            )}

            {/* Step 2: Select Date & Time */}
            {step === 2 && selectedService && (
                <div>
                    <h2 className="text-2xl font-semibold mb-4">Step 2: Pick a Date & Time for "{selectedService.name}"</h2>
                    <button onClick={() => setStep(1)} className="text-blue-600 mb-4">&larr; Back to services</button>
                    <div className="mb-4">
                        <label htmlFor="date" className="block font-medium mb-1">Select Date:</label>
                        <input type="date" id="date" min={today} value={selectedDate} onChange={(e) => setSelectedDate(e.target.value)} className="p-2 border rounded-md w-full" />
                    </div>
                    {selectedDate && (
                        <div>
                            <h3 className="font-semibold mb-2">Available Slots for {format(parseISO(selectedDate), 'EEEE, MMMM d')}:</h3>
                            {isLoading ? <p>Finding available slots...</p> : (
                                <div className="grid grid-cols-3 gap-2">
                                    {availableSlots.length > 0 ? availableSlots.map(slot => (
                                        <button key={slot} onClick={() => handleSlotSelect(slot)} className="p-2 border rounded-md text-center bg-gray-100 hover:bg-blue-200">
                                            {format(parseISO(slot), 'h:mm a')}
                                        </button>
                                    )) : <p>No available slots for this day. Please try another date.</p>}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            )}

            {/* Step 3: Confirmation */}
            {step === 3 && selectedService && selectedSlot && (
                <div>
                    <h2 className="text-2xl font-semibold mb-4">Step 3: Confirm Your Booking</h2>
                    <button onClick={() => setStep(2)} className="text-blue-600 mb-4">&larr; Back to time selection</button>
                    <div className="p-4 border rounded-lg bg-gray-50 space-y-2">
                        <p><strong>Service:</strong> {selectedService.name}</p>
                        <p><strong>Date & Time:</strong> {format(parseISO(selectedSlot), 'EEEE, MMMM d, yyyy @ h:mm a')}</p>
                        <p><strong>Price:</strong> ${selectedService.price}</p>
                    </div>
                    <form action={(formData) => startTransition(() => createBooking(formData))}>
                        <input type="hidden" name="serviceId" value={selectedService.id} />
                        <input type="hidden" name="bookingTime" value={selectedSlot} />
                        <div className="mt-4">
                            <label htmlFor="location" className="block font-medium mb-1">Service Address:</label>
                            <input type="text" id="location" name="locationAddress" required value={locationAddress} onChange={(e) => setLocationAddress(e.target.value)} placeholder="Enter your full address" className="p-2 border rounded-md w-full" />
                        </div>
                        <button type="submit" disabled={isPending} className="mt-6 w-full bg-green-600 text-white px-4 py-3 rounded-md hover:bg-green-700 disabled:bg-gray-400">
                            {isPending ? 'Booking...' : 'Confirm Booking'}
                        </button>
                    </form>
                </div>
            )}
        </div>
    );
}

```

### **4. (Optional) Create a Page to View Bookings**

To see the result of a successful booking, create a simple page for customers to view their appointments.

**`app/dashboard/customer/page.tsx`** (Update this existing file)

```tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import SignOutButton from '@/components/SignOutButton'
import Link from 'next/link';
import { format } from 'date-fns';

export default async function CustomerDashboard({ searchParams }: { searchParams: { message: string } }) {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    redirect('/login')
  }

  const { data: bookings, error } = await supabase
    .from('bookings')
    .select(`
      id,
      booking_time,
      status,
      services ( name, price )
    `)
    .eq('customer_id', user.id)
    .order('booking_time', { ascending: false });

  return (
    <div className="container mx-auto p-8">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-3xl font-bold">Welcome, Customer!</h1>
          <p>Your email: {user.email}</p>
        </div>
        <SignOutButton />
      </div>

      {searchParams.message && (
        <div className="p-4 mb-4 text-center bg-green-100 text-green-800 rounded-md">
          {searchParams.message}
        </div>
      )}

      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-semibold">Your Bookings</h2>
        <Link href="/book" className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">
          + New Booking
        </Link>
      </div>
      
      <div className="space-y-4">
        {bookings && bookings.length > 0 ? (
          bookings.map((booking: any) => (
            <div key={booking.id} className="p-4 border rounded-lg">
              <h3 className="font-bold text-lg">{booking.services.name}</h3>
              <p><strong>Date:</strong> {format(new Date(booking.booking_time), 'EEEE, MMMM d, yyyy @ h:mm a')}</p>
              <p><strong>Status:</strong> <span className="capitalize font-medium">{booking.status}</span></p>
              <p><strong>Price:</strong> ${booking.services.price}</p>
            </div>
          ))
        ) : (
          <p>You have no bookings yet.</p>
        )}
      </div>
    </div>
  )
}
```

With these files in place, your application now has a fully functional, multi-step booking system that securely interacts with your Supabase backend to manage services, detailer availability, and appointments.

**Metadata:**

```json
{
  "subtask_id": "booking_system",
  "title": "Implement Booking System",
  "expertise": "Full-stack Development"
}
```

### Full-stack Development Specialist

Here is the detailed implementation for the **Detailer Dashboard** subtask.

This section focuses on creating a secure, multi-functional dashboard for detailers. It leverages Next.js Server Components for secure data fetching and Server Actions for handling form submissions, ensuring that detailers can only see and manage their own information.

---

### **1. Secure the Data with Row-Level Security (RLS)**

First, we must ensure that a logged-in detailer can only access their own data. This is the most critical security step. Go to the Supabase SQL Editor and run the following queries to create RLS policies.

```sql
-- Enable RLS on the tables if not already enabled
ALTER TABLE public.detailer_availability ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to avoid conflicts (optional, but good for clean setup)
DROP POLICY IF EXISTS "Detailers can view their own availability" ON public.detailer_availability;
DROP POLICY IF EXISTS "Detailers can update their own availability" ON public.detailer_availability;
DROP POLICY IF EXISTS "Detailers can view their own bookings" ON public.bookings;
DROP POLICY IF EXISTS "Detailers can update their own bookings" ON public.bookings;


-- ** Policies for detailer_availability table **

-- 1. Policy: Allow detailers to view their own availability schedule
CREATE POLICY "Detailers can view their own availability"
ON public.detailer_availability FOR SELECT
USING ( auth.uid() = detailer_id );

-- 2. Policy: Allow detailers to create or update their own availability
CREATE POLICY "Detailers can update their own availability"
ON public.detailer_availability FOR ALL -- Covers INSERT, UPDATE, DELETE
USING ( auth.uid() = detailer_id );


-- ** Policies for bookings table **

-- 3. Policy: Allow detailers to view bookings assigned to them
CREATE POLICY "Detailers can view their own bookings"
ON public.bookings FOR SELECT
USING ( auth.uid() = detailer_id );

-- 4. Policy: Allow detailers to update the status of their own bookings
--    (e.g., from 'pending' to 'confirmed' or 'completed')
CREATE POLICY "Detailers can update their own bookings"
ON public.bookings FOR UPDATE
USING ( auth.uid() = detailer_id )
WITH CHECK ( auth.uid() = detailer_id );
```

### **2. Create Server Actions for Dashboard Logic**

Server Actions will handle updates, such as changing availability, without needing to build a separate API route.

**`app/dashboard/detailer/actions.ts`**

```typescript
'use server'

import { createClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

// Type for availability data from the form
type AvailabilityData = {
    day_of_week: number;
    start_time: string;
    end_time: string;
    is_available: boolean;
};

export async function updateAvailability(formData: FormData) {
    const supabase = createClient();

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
        return redirect('/login');
    }

    const availabilityPayload = [];

    // Loop through each day of the week (0=Sun, 1=Mon, ..., 6=Sat)
    for (let i = 0; i < 7; i++) {
        const isAvailable = formData.get(`day-${i}-available`) === 'on';
        const startTime = formData.get(`day-${i}-start`) as string;
        const endTime = formData.get(`day-${i}-end`) as string;

        // Only add to payload if the detailer wants to be available and times are set
        if (isAvailable && startTime && endTime) {
            availabilityPayload.push({
                detailer_id: user.id,
                day_of_week: i,
                start_time: startTime,
                end_time: endTime,
            });
        }
    }

    // First, delete all existing availability for this detailer
    const { error: deleteError } = await supabase
        .from('detailer_availability')
        .delete()
        .eq('detailer_id', user.id);

    if (deleteError) {
        console.error('Error deleting old availability:', deleteError);
        return { error: 'Failed to update availability.' };
    }

    // Then, insert the new availability if there's any
    if (availabilityPayload.length > 0) {
        const { error: insertError } = await supabase
            .from('detailer_availability')
            .insert(availabilityPayload);

        if (insertError) {
            console.error('Error inserting new availability:', insertError);
            return { error: 'Failed to update availability.' };
        }
    }
    
    // Revalidate the path to show the updated data
    revalidatePath('/dashboard/detailer');
    return { success: 'Availability updated successfully!' };
}
```

### **3. Build the Detailer Dashboard Page and Components**

We'll create a main page component that fetches all necessary data and passes it down to smaller, focused components for managing availability, viewing bookings, and seeing earnings.

#### **Main Dashboard Page**

This server component acts as the secure entry point, fetching all data for the logged-in detailer.

**`app/dashboard/detailer/page.tsx`**

```tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import SignOutButton from '@/components/SignOutButton'
import AvailabilityManager from '@/components/detailer/AvailabilityManager';
import BookingsList from '@/components/detailer/BookingsList';
import EarningsSummary from '@/components/detailer/EarningsSummary';

// Define a commission rate for the platform (e.g., 20%)
const PLATFORM_COMMISSION_RATE = 0.20;

export default async function DetailerDashboard() {
  const supabase = createClient();

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    redirect('/login');
  }

  // Verify the user has the 'detailer' role
  const { data: profile } = await supabase
    .from('profiles')
    .select('role')
    .eq('id', user.id)
    .single();

  if (profile?.role !== 'detailer') {
    return (
      <div className="container mx-auto p-8 text-center">
        <h1 className="text-2xl font-bold text-red-600">Access Denied</h1>
        <p>You do not have permission to view this page.</p>
      </div>
    );
  }

  // Fetch all necessary data in parallel
  const [bookingsData, availabilityData, earningsData] = await Promise.all([
    // 1. Fetch upcoming and past bookings
    supabase
      .from('bookings')
      .select(`
        id,
        booking_time,
        status,
        location_address,
        services ( name, price, estimated_duration_minutes ),
        profiles!bookings_customer_id_fkey ( full_name, email )
      `)
      .eq('detailer_id', user.id)
      .order('booking_time', { ascending: false }),
    // 2. Fetch current availability
    supabase
      .from('detailer_availability')
      .select('*')
      .eq('detailer_id', user.id),
    // 3. Fetch completed bookings for earnings calculation
    supabase
      .from('bookings')
      .select('final_price')
      .eq('detailer_id', user.id)
      .eq('status', 'completed')
  ]);

  // Calculate earnings
  const totalGrossRevenue = earningsData.data?.reduce((sum, booking) => sum + booking.final_price, 0) || 0;
  const detailerTotalEarnings = totalGrossRevenue * (1 - PLATFORM_COMMISSION_RATE);

  const earnings = {
    totalJobs: earningsData.data?.length || 0,
    totalEarnings: detailerTotalEarnings,
  };

  return (
    <div className="container mx-auto p-4 md:p-8">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-3xl font-bold">Detailer Dashboard</h1>
          <p className="text-gray-500">Welcome, {user.email}</p>
        </div>
        <SignOutButton />
      </div>

      {/* Earnings Summary */}
      <EarningsSummary stats={earnings} />

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
        {/* Availability Manager */}
        <div className="lg:col-span-1">
          <AvailabilityManager initialAvailability={availabilityData.data || []} />
        </div>

        {/* Bookings List */}
        <div className="lg:col-span-2">
          <BookingsList bookings={bookingsData.data || []} />
        </div>
      </div>
    </div>
  );
}
```

#### **Earnings Summary Component**

A simple component to display key metrics.

**`components/detailer/EarningsSummary.tsx`**

```tsx
type EarningsStats = {
    totalJobs: number;
    totalEarnings: number;
};

export default function EarningsSummary({ stats }: { stats: EarningsStats }) {
    return (
        <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold mb-4">Your Performance</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="p-4 bg-blue-50 rounded-lg">
                    <p className="text-sm text-gray-600">Total Completed Jobs</p>
                    <p className="text-3xl font-bold">{stats.totalJobs}</p>
                </div>
                <div className="p-4 bg-green-50 rounded-lg">
                    <p className="text-sm text-gray-600">Total Earnings (After Commission)</p>
                    <p className="text-3xl font-bold">${stats.totalEarnings.toFixed(2)}</p>
                </div>
            </div>
        </div>
    );
}
```

#### **Availability Manager Component**

A client component to manage the weekly schedule form.

**`components/detailer/AvailabilityManager.tsx`**

```tsx
'use client'

import { useState, useTransition } from 'react';
import { updateAvailability } from '@/app/dashboard/detailer/actions';

type Availability = {
    day_of_week: number;
    start_time: string;
    end_time: string;
};

const daysOfWeek = [
    { id: 1, name: 'Monday' },
    { id: 2, name: 'Tuesday' },
    { id: 3, name: 'Wednesday' },
    { id: 4, name: 'Thursday' },
    { id: 5, name: 'Friday' },
    { id: 6, name: 'Saturday' },
    { id: 0, name: 'Sunday' },
];

export default function AvailabilityManager({ initialAvailability }: { initialAvailability: Availability[] }) {
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'success' | 'error', text: string } | null>(null);

    const handleSubmit = (formData: FormData) => {
        startTransition(async () => {
            const result = await updateAvailability(formData);
            if (result?.error) {
                setMessage({ type: 'error', text: result.error });
            } else if (result?.success) {
                setMessage({ type: 'success', text: result.success });
            }
        });
    };

    return (
        <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold mb-4">Manage Your Availability</h2>
            <form action={handleSubmit}>
                <div className="space-y-4">
                    {daysOfWeek.map(day => {
                        const currentDay = initialAvailability.find(a => a.day_of_week === day.id);
                        return (
                            <div key={day.id} className="p-3 border rounded-md bg-gray-50">
                                <div className="flex items-center justify-between">
                                    <label htmlFor={`day-${day.id}-available`} className="font-medium">{day.name}</label>
                                    <input
                                        type="checkbox"
                                        name={`day-${day.id}-available`}
                                        id={`day-${day.id}-available`}
                                        defaultChecked={!!currentDay}
                                        className="h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                    />
                                </div>
                                <div className="flex items-center space-x-2 mt-2">
                                    <input
                                        type="time"
                                        name={`day-${day.id}-start`}
                                        defaultValue={currentDay?.start_time || '09:00'}
                                        className="p-1 border rounded-md w-full text-sm"
                                    />
                                    <span>to</span>
                                    <input
                                        type="time"
                                        name={`day-${day.id}-end`}
                                        defaultValue={currentDay?.end_time || '17:00'}
                                        className="p-1 border rounded-md w-full text-sm"
                                    />
                                </div>
                            </div>
                        );
                    })}
                </div>
                <button type="submit" disabled={isPending} className="mt-6 w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:bg-gray-400">
                    {isPending ? 'Updating...' : 'Save Availability'}
                </button>
                {message && (
                    <p className={`mt-4 text-sm text-center ${message.type === 'success' ? 'text-green-600' : 'text-red-600'}`}>
                        {message.text}
                    </p>
                )}
            </form>
        </div>
    );
}
```

#### **Bookings List Component**

A component to display upcoming and past jobs.

**`components/detailer/BookingsList.tsx`**

```tsx
import { format } from 'date-fns';

// Define a more specific type for the booking data we receive
type Booking = {
    id: string;
    booking_time: string;
    status: string;
    location_address: string;
    services: {
        name: string;
        price: number;
        estimated_duration_minutes: number;
    };
    profiles: {
        full_name: string | null;
        email: string | null;
    };
};

export default function BookingsList({ bookings }: { bookings: Booking[] }) {
    const upcomingBookings = bookings.filter(b => new Date(b.booking_time) >= new Date() && b.status !== 'completed' && b.status !== 'cancelled');
    const pastBookings = bookings.filter(b => new Date(b.booking_time) < new Date() || b.status === 'completed' || b.status === 'cancelled');

    return (
        <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold mb-4">Your Jobs</h2>
            <div className="space-y-6">
                <div>
                    <h3 className="text-xl font-semibold mb-2 text-gray-700">Upcoming</h3>
                    {upcomingBookings.length > 0 ? (
                        <div className="space-y-4">
                            {upcomingBookings.map(booking => <BookingCard key={booking.id} booking={booking} />)}
                        </div>
                    ) : (
                        <p className="text-gray-500">You have no upcoming jobs.</p>
                    )}
                </div>
                <div>
                    <h3 className="text-xl font-semibold mb-2 text-gray-700">History</h3>
                    {pastBookings.length > 0 ? (
                        <div className="space-y-4">
                            {pastBookings.map(booking => <BookingCard key={booking.id} booking={booking} />)}
                        </div>
                    ) : (
                        <p className="text-gray-500">You have no past jobs.</p>
                    )}
                </div>
            </div>
        </div>
    );
}

function BookingCard({ booking }: { booking: Booking }) {
    const statusColors: { [key: string]: string } = {
        pending: 'bg-yellow-100 text-yellow-800',
        confirmed: 'bg-blue-100 text-blue-800',
        completed: 'bg-green-100 text-green-800',
        cancelled: 'bg-red-100 text-red-800',
    };

    return (
        <div className="p-4 border rounded-lg">
            <div className="flex justify-between items-start">
                <div>
                    <h4 className="font-bold text-lg">{booking.services.name}</h4>
                    <p className="text-sm text-gray-600">
                        {format(new Date(booking.booking_time), 'EEEE, MMM d @ h:mm a')}
                    </p>
                </div>
                <span className={`px-2 py-1 text-xs font-medium rounded-full ${statusColors[booking.status] || 'bg-gray-100 text-gray-800'}`}>
                    {booking.status}
                </span>
            </div>
            <div className="mt-2 text-sm">
                <p><strong>Customer:</strong> {booking.profiles.full_name || 'N/A'}</p>
                <p><strong>Location:</strong> {booking.location_address}</p>
                <p><strong>Service Price:</strong> ${booking.services.price.toFixed(2)}</p>
            </div>
            {/* Add buttons for actions like 'Confirm' or 'Mark Complete' here */}
        </div>
    );
}
```

With these files, you now have a robust and secure dashboard for your detailers. They can log in, manage their work schedule, see their assigned jobs, and track their earnings, all while the system ensures they can only interact with their own data.

**Metadata:**

```json
{
  "subtask_id": "detailer_dashboard",
  "title": "Detailer Dashboard",
  "expertise": "Full-stack Development"
}
```

### Full-stack Development Specialist

Here is the detailed implementation for the **Admin/Concierge Dashboard**.

This section provides a secure, comprehensive dashboard for the business owner to manage detailers, services, bookings, and view financial summaries. It leverages Next.js Server Components and Server Actions for a secure and efficient implementation.

---

### **1. Set Up Admin Role and Protected Routes**

First, we need a way to distinguish regular users from administrators. We'll add a `role` column to our `profiles` table and then use middleware to protect the `/admin` routes.

**A. Update `profiles` Table**

If you haven't already, add a `role` column to your `profiles` table. Go to the Supabase SQL Editor and run:

```sql
-- Add a 'role' column to the profiles table
ALTER TABLE public.profiles
ADD COLUMN role TEXT DEFAULT 'customer';

-- Optional: Create an index for faster role lookups
CREATE INDEX idx_profiles_role ON public.profiles(role);

-- Manually update your own user to be an admin in the Supabase Table Editor
-- Find your user in the 'profiles' table and set the 'role' column to 'admin'
```

**B. Create Middleware for Route Protection**

The middleware will intercept requests to `/admin` and redirect non-admin users.

**`middleware.ts`** (Create this file in the root of your project)

```typescript
import { type NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/middleware'

// This function can be marked `async` if using `await` inside
export async function middleware(request: NextRequest) {
  const { supabase, response } = createClient(request)

  // Refresh session if expired - required for Server Components
  const { data: { session } } = await supabase.auth.getSession()

  // If the user is not logged in and trying to access a protected route, redirect to login
  if (!session && request.nextUrl.pathname.startsWith('/admin')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // If the user is logged in, check if they are an admin
  if (session && request.nextUrl.pathname.startsWith('/admin')) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', session.user.id)
      .single();

    // If profile is not found or user is not an admin, redirect to the home page
    if (!profile || profile.role !== 'admin') {
      return NextResponse.redirect(new URL('/', request.url));
    }
  }

  return response
}

// See "Matching Paths" below to learn more
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
```

### **2. Create Server Actions for Admin Operations**

All data manipulation for the admin dashboard will be handled by these secure server actions.

**`app/admin/actions.ts`**

```typescript
'use server'

import { createClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

// Helper function to check for admin role
async function ensureAdmin() {
    const supabase = createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
        redirect('/login');
    }
    const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('id', user.id)
        .single();
    
    if (profile?.role !== 'admin') {
        throw new Error('Unauthorized');
    }
    return { supabase, user };
}


// --- Service Management Actions ---

export async function createOrUpdateService(formData: FormData) {
    const { supabase } = await ensureAdmin();
    
    const rawFormData = {
        id: formData.get('id') as string | null,
        name: formData.get('name') as string,
        description: formData.get('description') as string,
        price: parseFloat(formData.get('price') as string),
        estimated_duration_minutes: parseInt(formData.get('estimated_duration_minutes') as string, 10),
        is_active: formData.get('is_active') === 'on',
    };

    const { id, ...updateData } = rawFormData;

    const { error } = id
        ? await supabase.from('services').update(updateData).eq('id', id)
        : await supabase.from('services').insert(updateData);

    if (error) {
        console.error("Error saving service:", error);
        return { error: error.message };
    }

    revalidatePath('/admin/services');
    return { success: true };
}


// --- Detailer Management Actions ---

export async function createOrUpdateDetailer(formData: FormData) {
    const { supabase } = await ensureAdmin();

    const rawFormData = {
        id: formData.get('id') as string | null,
        full_name: formData.get('full_name') as string,
        phone_number: formData.get('phone_number') as string,
        is_active: formData.get('is_active') === 'on',
    };

    const availability = [];
    for (let i = 0; i < 7; i++) {
        if (formData.get(`availability[${i}][enabled]`)) {
            availability.push({
                day_of_week: i,
                start_time: formData.get(`availability[${i}][start_time]`) as string,
                end_time: formData.get(`availability[${i}][end_time]`) as string,
            });
        }
    }

    // Upsert detailer info
    const { data: detailerData, error: detailerError } = await supabase
        .from('detailers')
        .upsert({
            id: rawFormData.id || undefined,
            full_name: rawFormData.full_name,
            phone_number: rawFormData.phone_number,
            is_active: rawFormData.is_active,
        })
        .select('id')
        .single();

    if (detailerError) {
        console.error("Error saving detailer:", detailerError);
        return { error: detailerError.message };
    }
    
    const detailerId = detailerData.id;

    // Delete old availability
    const { error: deleteError } = await supabase
        .from('detailer_availability')
        .delete()
        .eq('detailer_id', detailerId);

    if (deleteError) {
        console.error("Error deleting old availability:", deleteError);
        return { error: deleteError.message };
    }

    // Insert new availability
    if (availability.length > 0) {
        const availabilityToInsert = availability.map(a => ({ ...a, detailer_id: detailerId }));
        const { error: availabilityError } = await supabase
            .from('detailer_availability')
            .insert(availabilityToInsert);
        
        if (availabilityError) {
            console.error("Error saving availability:", availabilityError);
            return { error: availabilityError.message };
        }
    }

    revalidatePath('/admin/detailers');
    return { success: true };
}


// --- Booking Management Actions ---

export async function updateBookingStatus(formData: FormData) {
    const { supabase } = await ensureAdmin();

    const bookingId = formData.get('bookingId') as string;
    const newStatus = formData.get('status') as string;
    
    if (!['pending', 'confirmed', 'completed', 'cancelled'].includes(newStatus)) {
        return { error: 'Invalid status' };
    }

    const { error } = await supabase
        .from('bookings')
        .update({ status: newStatus })
        .eq('id', bookingId);

    if (error) {
        return { error: error.message };
    }

    revalidatePath('/admin/bookings');
    revalidatePath('/admin');
    return { success: true };
}
```

### **3. Build the Admin Layout and Pages**

This structure provides consistent navigation across the admin section.

**`app/admin/layout.tsx`**

```tsx
import Link from 'next/link';
import SignOutButton from '@/components/SignOutButton';

export default function AdminLayout({ children }: { children: React.ReactNode }) {
    const navItems = [
        { name: 'Dashboard', href: '/admin' },
        { name: 'Bookings', href: '/admin/bookings' },
        { name: 'Detailers', href: '/admin/detailers' },
        { name: 'Services', href: '/admin/services' },
    ];

    return (
        <div className="flex min-h-screen">
            <aside className="w-64 bg-gray-800 text-white p-4">
                <h1 className="text-2xl font-bold mb-8">Concierge</h1>
                <nav>
                    <ul>
                        {navItems.map((item) => (
                            <li key={item.name} className="mb-4">
                                <Link href={item.href} className="hover:text-blue-300">
                                    {item.name}
                                </Link>
                            </li>
                        ))}
                    </ul>
                </nav>
            </aside>
            <main className="flex-1 p-8 bg-gray-100">
                <header className="flex justify-end mb-8">
                    <SignOutButton />
                </header>
                {children}
            </main>
        </div>
    );
}
```

**`app/admin/page.tsx` (Dashboard Overview)**

```tsx
import { createClient } from '@/lib/supabase/server';
import { format } from 'date-fns';

const COMMISSION_RATE = 0.20; // 20% commission

export default async function AdminDashboardPage() {
    const supabase = createClient();

    // Fetch all bookings for stats
    const { data: bookings, error } = await supabase
        .from('bookings')
        .select('status, final_price');

    if (error) {
        console.error("Error fetching bookings for stats:", error);
        return <p>Error loading dashboard data.</p>;
    }

    const totalBookings = bookings.length;
    const pendingBookings = bookings.filter(b => b.status === 'pending').length;
    const completedBookings = bookings.filter(b => b.status === 'completed');
    
    const totalRevenue = completedBookings.reduce((acc, b) => acc + (b.final_price || 0), 0);
    const totalCommission = totalRevenue * COMMISSION_RATE;

    // Fetch recent bookings
    const { data: recentBookings } = await supabase
        .from('bookings')
        .select(`
            id,
            booking_time,
            status,
            profiles ( full_name ),
            detailers ( full_name )
        `)
        .order('booking_time', { ascending: false })
        .limit(5);

    return (
        <div>
            <h1 className="text-3xl font-bold mb-6">Dashboard</h1>
            
            {/* Stats Cards */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <StatCard title="Total Bookings" value={totalBookings} />
                <StatCard title="Pending Bookings" value={pendingBookings} />
                <StatCard title="Total Revenue" value={`$${totalRevenue.toFixed(2)}`} />
                <StatCard title="Commissions Owed" value={`$${totalCommission.toFixed(2)}`} />
            </div>

            {/* Recent Bookings */}
            <div className="bg-white p-6 rounded-lg shadow-md">
                <h2 className="text-xl font-semibold mb-4">Recent Bookings</h2>
                <div className="overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr className="border-b">
                                <th className="text-left py-2 px-4">Customer</th>
                                <th className="text-left py-2 px-4">Detailer</th>
                                <th className="text-left py-2 px-4">Date & Time</th>
                                <th className="text-left py-2 px-4">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            {recentBookings?.map((booking: any) => (
                                <tr key={booking.id} className="border-b hover:bg-gray-50">
                                    <td className="py-2 px-4">{booking.profiles.full_name}</td>
                                    <td className="py-2 px-4">{booking.detailers.full_name}</td>
                                    <td className="py-2 px-4">{format(new Date(booking.booking_time), 'PPpp')}</td>
                                    <td className="py-2 px-4"><span className="capitalize font-medium">{booking.status}</span></td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}

function StatCard({ title, value }: { title: string, value: string | number }) {
    return (
        <div className="bg-white p-6 rounded-lg shadow-md">
            <h3 className="text-gray-500 text-sm font-medium">{title}</h3>
            <p className="text-3xl font-bold mt-2">{value}</p>
        </div>
    );
}
```

**`app/admin/bookings/page.tsx` (Booking Management)**

```tsx
import { createClient } from '@/lib/supabase/server';
import { format } from 'date-fns';
import { updateBookingStatus } from '../actions';

export default async function AdminBookingsPage() {
    const supabase = createClient();
    const { data: bookings } = await supabase
        .from('bookings')
        .select(`
            id,
            booking_time,
            status,
            final_price,
            location_address,
            profiles ( full_name, email ),
            services ( name ),
            detailers ( full_name )
        `)
        .order('booking_time', { ascending: false });

    return (
        <div>
            <h1 className="text-3xl font-bold mb-6">Manage Bookings</h1>
            <div className="bg-white p-6 rounded-lg shadow-md overflow-x-auto">
                <table className="min-w-full text-sm">
                    <thead>
                        <tr className="border-b">
                            <th className="text-left py-2 px-3">Date & Time</th>
                            <th className="text-left py-2 px-3">Customer</th>
                            <th className="text-left py-2 px-3">Detailer</th>
                            <th className="text-left py-2 px-3">Service</th>
                            <th className="text-left py-2 px-3">Price</th>
                            <th className="text-left py-2 px-3">Status</th>
                            <th className="text-left py-2 px-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {bookings?.map((booking: any) => (
                            <tr key={booking.id} className="border-b hover:bg-gray-50">
                                <td className="py-2 px-3">{format(new Date(booking.booking_time), 'PPp')}</td>
                                <td className="py-2 px-3">{booking.profiles.full_name}</td>
                                <td className="py-2 px-3">{booking.detailers.full_name}</td>
                                <td className="py-2 px-3">{booking.services.name}</td>
                                <td className="py-2 px-3">${booking.final_price}</td>
                                <td className="py-2 px-3"><span className="capitalize font-medium">{booking.status}</span></td>
                                <td className="py-2 px-3">
                                    <form action={updateBookingStatus}>
                                        <input type="hidden" name="bookingId" value={booking.id} />
                                        <select 
                                            name="status" 
                                            defaultValue={booking.status}
                                            className="p-1 border rounded-md"
                                            onChange={(e) => e.currentTarget.form?.requestSubmit()}
                                        >
                                            <option value="pending">Pending</option>
                                            <option value="confirmed">Confirmed</option>
                                            <option value="completed">Completed</option>
                                            <option value="cancelled">Cancelled</option>
                                        </select>
                                    </form>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}
```

**`app/admin/detailers/page.tsx` (Detailer Management)**

```tsx
import { createClient } from '@/lib/supabase/server';
import { createOrUpdateDetailer } from '../actions';

export default async function AdminDetailersPage() {
    const supabase = createClient();
    const { data: detailers } = await supabase
        .from('detailers')
        .select(`*, detailer_availability(*)`)
        .order('full_name');

    const daysOfWeek = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    return (
        <div>
            <h1 className="text-3xl font-bold mb-6">Manage Detailers</h1>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Detailers List */}
                <div className="lg:col-span-2 bg-white p-6 rounded-lg shadow-md">
                    <h2 className="text-xl font-semibold mb-4">Existing Detailers</h2>
                    <div className="space-y-4">
                        {detailers?.map((detailer) => (
                            <div key={detailer.id} className="p-4 border rounded-md">
                                <p className="font-bold">{detailer.full_name} - <span className={detailer.is_active ? 'text-green-600' : 'text-red-600'}>{detailer.is_active ? 'Active' : 'Inactive'}</span></p>
                                <p className="text-sm text-gray-600">{detailer.phone_number}</p>
                                <div className="text-sm mt-2">
                                    <strong>Availability:</strong>
                                    {detailer.detailer_availability.length > 0 ? (
                                        <ul className="list-disc list-inside">
                                            {detailer.detailer_availability.sort((a,b) => a.day_of_week - b.day_of_week).map(avail => (
                                                <li key={avail.id}>{daysOfWeek[avail.day_of_week]}: {avail.start_time} - {avail.end_time}</li>
                                            ))}
                                        </ul>
                                    ) : <p>None set.</p>}
                                </div>
                                {/* TODO: Add an Edit button that populates the form */}
                            </div>
                        ))}
                    </div>
                </div>

                {/* Add/Edit Form */}
                <div className="bg-white p-6 rounded-lg shadow-md">
                    <h2 className="text-xl font-semibold mb-4">Add New Detailer</h2>
                    <form action={createOrUpdateDetailer} className="space-y-4">
                        <div>
                            <label htmlFor="full_name" className="block font-medium">Full Name</label>
                            <input type="text" name="full_name" required className="w-full p-2 border rounded-md" />
                        </div>
                        <div>
                            <label htmlFor="phone_number" className="block font-medium">Phone Number</label>
                            <input type="tel" name="phone_number" required className="w-full p-2 border rounded-md" />
                        </div>
                        <div className="flex items-center">
                            <input type="checkbox" name="is_active" id="is_active_detailer" defaultChecked className="mr-2" />
                            <label htmlFor="is_active_detailer">Is Active</label>
                        </div>

                        <h3 className="font-semibold pt-4 border-t">Availability</h3>
                        {daysOfWeek.map((day, index) => (
                            <div key={index} className="grid grid-cols-3 items-center gap-2 text-sm">
                                <div className="col-span-3 flex items-center">
                                    <input type="checkbox" name={`availability[${index}][enabled]`} id={`day_${index}`} className="mr-2"/>
                                    <label htmlFor={`day_${index}`}>{day}</label>
                                </div>
                                <input type="time" name={`availability[${index}][start_time]`} defaultValue="09:00" className="p-1 border rounded-md"/>
                                <span>to</span>
                                <input type="time" name={`availability[${index}][end_time]`} defaultValue="17:00" className="p-1 border rounded-md"/>
                            </div>
                        ))}
                        
                        <button type="submit" className="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700">Save Detailer</button>
                    </form>
                </div>
            </div>
        </div>
    );
}
```

**`app/admin/services/page.tsx` (Service Management)**

```tsx
import { createClient } from '@/lib/supabase/server';
import { createOrUpdateService } from '../actions';

export default async function AdminServicesPage() {
    const supabase = createClient();
    const { data: services } = await supabase
        .from('services')
        .select('*')
        .order('name');
    
    return (
        <div>
            <h1 className="text-3xl font-bold mb-6">Manage Services</h1>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Services List */}
                <div className="lg:col-span-2 bg-white p-6 rounded-lg shadow-md">
                    <h2 className="text-xl font-semibold mb-4">Existing Services</h2>
                    <div className="space-y-4">
                        {services?.map((service) => (
                            <div key={service.id} className="p-4 border rounded-md">
                                <p className="font-bold">{service.name} - ${service.price} <span className={service.is_active ? 'text-green-600' : 'text-red-600'}>({service.is_active ? 'Active' : 'Inactive'})</span></p>
                                <p className="text-sm text-gray-600">{service.description}</p>
                                <p className="text-sm">Duration: {service.estimated_duration_minutes} mins</p>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Add/Edit Form */}
                <div className="bg-white p-6 rounded-lg shadow-md">
                    <h2 className="text-xl font-semibold mb-4">Add New Service</h2>
                    <form action={createOrUpdateService} className="space-y-4">
                        <div>
                            <label htmlFor="name" className="block font-medium">Service Name</label>
                            <input type="text" name="name" required className="w-full p-2 border rounded-md" />
                        </div>
                        <div>
                            <label htmlFor="description" className="block font-medium">Description</label>
                            <textarea name="description" rows={3} className="w-full p-2 border rounded-md"></textarea>
                        </div>
                        <div>
                            <label htmlFor="price" className="block font-medium">Price ($)</label>
                            <input type="number" name="price" step="0.01" required className="w-full p-2 border rounded-md" />
                        </div>
                        <div>
                            <label htmlFor="estimated_duration_minutes" className="block font-medium">Duration (minutes)</label>
                            <input type="number" name="estimated_duration_minutes" required className="w-full p-2 border rounded-md" />
                        </div>
                        <div className="flex items-center">
                            <input type="checkbox" name="is_active" id="is_active_service" defaultChecked className="mr-2" />
                            <label htmlFor="is_active_service">Is Active</label>
                        </div>
                        <button type="submit" className="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700">Save Service</button>
                    </form>
                </div>
            </div>
        </div>
    );
}
```

With these files, you have a fully functional and secure admin dashboard. The concierge can now log in, manage every aspect of the business, and monitor performance without needing direct access to the database.

**Metadata:**

```json
{
  "subtask_id": "admin_dashboard",
  "title": "Admin/Concierge Dashboard",
  "expertise": "Full-stack Development"
}
```

### QA Engineering Specialist

Here is the detailed guide for the **End-to-End Testing** subtask.

This guide will walk you through setting up and writing end-to-end (E2E) tests for the entire application using **Playwright**. E2E tests simulate real user journeys in a browser, ensuring all parts of your application—frontend, backend, and database—work together correctly.

---

### **Why Playwright?**

* **Reliable:** Auto-waits for elements to be ready, reducing flaky tests.
* **Cross-Browser:** Tests run on Chromium (Chrome, Edge), Firefox, and WebKit (Safari).
* **Excellent Tooling:** Comes with a test generator (Codegen), a trace viewer for debugging, and a UI mode for a great developer experience.
* **Powerful:** Can interact with your database or APIs directly from the test environment for setup and verification.

---

### **Step 1: Install and Configure Playwright**

1. **Install Playwright**: In your project's root directory, run the following command. This will install Playwright and download the necessary browser binaries.

    ```bash
    npm init playwright@latest
    ```

    When prompted:
    * Choose either **TypeScript** or JavaScript (this guide will use TypeScript).
    * Name of your tests folder: `e2e`.
    * Add a GitHub Actions workflow: `true` (This is a great starting point for CI/CD).

2. **Review Created Files**: The installer will create a few files:
    * `playwright.config.ts`: The main configuration file.
    * `e2e/`: The folder where your test files will live.
    * `e2e/example.spec.ts`: An example test file you can review or delete.
    * `tests-examples/`: More examples, which can be safely deleted.

3. **Configure `playwright.config.ts`**: Open this file and make one important change. We need to tell Playwright the base URL of our application when it's running in development.

    ```typescript
    // playwright.config.ts
    import { defineConfig, devices } from '@playwright/test';

    export default defineConfig({
      testDir: './e2e',
      /* Run tests in files in parallel */
      fullyParallel: true,
      /* Fail the build on CI if you accidentally left test.only in the source code. */
      forbidOnly: !!process.env.CI,
      /* Retry on CI only */
      retries: process.env.CI ? 2 : 0,
      /* Opt out of parallel tests on CI. */
      workers: process.env.CI ? 1 : undefined,
      /* Reporter to use. See https://playwright.dev/docs/test-reporters */
      reporter: 'html',
      /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
      use: {
        /* Base URL to use in actions like `await page.goto('/')`. */
        baseURL: 'http://localhost:3000', // <-- ADD THIS LINE

        /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
        trace: 'on-first-retry',
      },

      /* Configure projects for major browsers */
      projects: [
        {
          name: 'chromium',
          use: { ...devices['Desktop Chrome'] },
        },
        // You can uncomment these for other browsers
        // {
        //   name: 'firefox',
        //   use: { ...devices['Desktop Firefox'] },
        // },
        // {
        //   name: 'webkit',
        //   use: { ...devices['Desktop WebKit'] },
        // },
      ],
    });
    ```

---

### **Step 2: Create a Database Seeding Script**

Reliable E2E tests require a consistent starting state. We'll create a script to reset our database and populate it with known test users and data before each test run.

1. **Install `dotenv`**: This will allow our script to read environment variables from the `.env.local` file.

    ```bash
    npm install -D dotenv
    ```

2. **Create the Seeding Script**: Create a new folder `e2e/utils` and a file inside it named `seed.ts`. This script will use the Supabase admin client to bypass RLS and set up our test environment.

    **`e2e/utils/seed.ts`**

    ```typescript
    import { createClient } from '@supabase/supabase-js';
    import * as dotenv from 'dotenv';

    // Load environment variables from .env.local
    dotenv.config({ path: '.env.local' });

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // Use the SERVICE ROLE KEY for admin actions

    if (!supabaseUrl || !supabaseServiceKey) {
      throw new Error("Supabase URL or Service Role Key is not defined in .env.local");
    }

    // IMPORTANT: Use the Service Role Key to bypass RLS for seeding
    const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);

    // Define our test users
    export const testUsers = {
      customer: { email: 'customer@example.com', password: 'password123', fullName: 'Test Customer' },
      detailer: { email: 'detailer@example.com', password: 'password123', fullName: 'Test Detailer' },
      admin: { email: 'admin@example.com', password: 'password123', fullName: 'Test Admin' },
    };

    async function seedDatabase() {
      console.log('Starting database seeding...');

      // 1. Clean up existing test users from Auth
      const { data: { users }, error: listUsersError } = await supabaseAdmin.auth.admin.listUsers();
      if (listUsersError) throw listUsersError;

      const testUserEmails = Object.values(testUsers).map(u => u.email);
      const usersToDelete = users.filter(u => testUserEmails.includes(u.email ?? ''));

      for (const user of usersToDelete) {
        await supabaseAdmin.auth.admin.deleteUser(user.id);
      }
      console.log('Cleaned up old test users.');

      // 2. Truncate tables in the correct order (due to foreign key constraints)
      const tables = ['bookings', 'detailer_availability', 'services', 'detailers', 'profiles'];
      for (const table of tables) {
        const { error } = await supabaseAdmin.from(table).delete().neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all rows
        if (error) throw new Error(`Error truncating ${table}: ${error.message}`);
      }
      console.log('Truncated tables.');

      // 3. Create test users in Auth and Profiles
      const createdUsers: { [key: string]: any } = {};
      for (const [role, user] of Object.entries(testUsers)) {
        const { data: { user: authUser }, error: authError } = await supabaseAdmin.auth.admin.createUser({
          email: user.email,
          password: user.password,
          email_confirm: true,
        });
        if (authError) throw authError;

        const { error: profileError } = await supabaseAdmin.from('profiles').insert({
          id: authUser!.id,
          full_name: user.fullName,
          role: role,
        });
        if (profileError) throw profileError;
        createdUsers[role] = authUser;
      }
      console.log('Created test users and profiles.');

      // 4. Create detailer-specific data
      const { error: detailerError } = await supabaseAdmin.from('detailers').insert({
        id: createdUsers.detailer.id,
        full_name: testUsers.detailer.fullName,
        is_active: true,
      });
      if (detailerError) throw detailerError;

      // 5. Create a known availability for the test detailer (e.g., Wednesdays 9-5)
      const { error: availabilityError } = await supabaseAdmin.from('detailer_availability').insert({
        detailer_id: createdUsers.detailer.id,
        day_of_week: 3, // Wednesday
        start_time: '09:00',
        end_time: '17:00',
      });
      if (availabilityError) throw availabilityError;
      console.log('Created test detailer with availability.');

      // 6. Create test services
      const { error: serviceError } = await supabaseAdmin.from('services').insert([
        { name: 'E2E Test Wash', price: 50.00, estimated_duration_minutes: 60, is_active: true },
        { name: 'E2E Test Detail', price: 150.00, estimated_duration_minutes: 180, is_active: true },
      ]);
      if (serviceError) throw serviceError;
      console.log('Created test services.');

      console.log('Database seeding completed successfully!');
    }

    // Execute the seeding function if the script is run directly
    if (require.main === module) {
      seedDatabase().catch(error => {
        console.error('Seeding failed:', error);
        process.exit(1);
      });
    }

    export default seedDatabase;
    ```

3. **Add a `seed` script to `package.json`**:

    ```json
    // package.json
    "scripts": {
      "dev": "next dev",
      "build": "next build",
      "start": "next start",
      "lint": "next lint",
      "seed": "tsx e2e/utils/seed.ts" // <-- Add this line
    },
    ```

    * You may need to install `tsx` for running the TypeScript script: `npm install -D tsx`.

4. **Run the script manually** to ensure it works: `npm run seed`. Check your Supabase tables to verify the data was created.

---

### **Step 3: Write E2E Test Scenarios**

Now we'll write the actual tests. We'll create separate files for different user journeys. Delete `e2e/example.spec.ts` and create the following files.

#### **`e2e/auth.spec.ts` - Authentication Flow**

This test covers signing up, logging in, and logging out.

```typescript
import { test, expect } from '@playwright/test';
import { testUsers } from './utils/seed';
import seedDatabase from './utils/seed';

// Run seeding before all tests in this file
test.beforeAll(async () => {
  await seedDatabase();
});

test.describe('Authentication', () => {
  test('should allow a user to sign up', async ({ page }) => {
    await page.goto('/signup');
    await page.getByLabel('Full Name').fill('New User');
    await page.getByLabel('Email').fill('newuser@example.com');
    await page.getByLabel('Password').fill('password123');
    await page.getByRole('button', { name: 'Sign Up' }).click();

    // After signup, user is usually redirected to a confirmation page or dashboard
    await expect(page).toHaveURL('/'); // Or wherever your app redirects
    await expect(page.getByText('Check your email for a confirmation link.')).toBeVisible();
  });

  test('should allow a customer to log in and log out', async ({ page }) => {
    await page.goto('/login');
    await page.getByLabel('Email').fill(testUsers.customer.email);
    await page.getByLabel('Password').fill(testUsers.customer.password);
    await page.getByRole('button', { name: 'Sign In' }).click();

    // Should be redirected to their dashboard
    await expect(page).toHaveURL('/dashboard/customer');
    await expect(page.getByRole('heading', { name: 'Welcome, Customer!' })).toBeVisible();

    // Log out
    await page.getByRole('button', { name: 'Sign Out' }).click();
    await expect(page).toHaveURL('/');
    await expect(page.getByRole('link', { name: 'Login' })).toBeVisible();
  });

  test('should redirect detailer to detailer dashboard', async ({ page }) => {
    await page.goto('/login');
    await page.getByLabel('Email').fill(testUsers.detailer.email);
    await page.getByLabel('Password').fill(testUsers.detailer.password);
    await page.getByRole('button', { name: 'Sign In' }).click();

    await expect(page).toHaveURL('/dashboard/detailer');
    await expect(page.getByRole('heading', { name: 'Detailer Dashboard' })).toBeVisible();
  });

  test('should redirect admin to admin dashboard', async ({ page }) => {
    await page.goto('/login');
    await page.getByLabel('Email').fill(testUsers.admin.email);
    await page.getByLabel('Password').fill(testUsers.admin.password);
    await page.getByRole('button', { name: 'Sign In' }).click();

    await expect(page).toHaveURL('/admin');
    await expect(page.getByRole('heading', { name: 'Dashboard' })).toBeVisible();
  });
});
```

#### **`e2e/booking.spec.ts` - Customer Booking Flow**

This is the core user journey for a customer.

```typescript
import { test, expect } from '@playwright/test';
import { testUsers } from './utils/seed';
import seedDatabase from './utils/seed';
import { getDay, addDays, format, parseISO } from 'date-fns';

test.beforeAll(async () => {
  await seedDatabase();
});

test.describe('Booking Flow', () => {
  // Log in as the customer before each test in this file
  test.beforeEach(async ({ page }) => {
    await page.goto('/login');
    await page.getByLabel('Email').fill(testUsers.customer.email);
    await page.getByLabel('Password').fill(testUsers.customer.password);
    await page.getByRole('button', { name: 'Sign In' }).click();
    await expect(page).toHaveURL('/dashboard/customer');
  });

  test('should allow a customer to book a service', async ({ page }) => {
    await page.goto('/book');

    // Step 1: Select a service
    await expect(page.getByRole('heading', { name: 'Step 1: Choose a Service' })).toBeVisible();
    // Use a more specific selector if needed, like data-testid
    await page.locator('div:has-text("E2E Test Detail")').getByRole('button', { name: 'Select' }).click();

    // Step 2: Select a date and time
    await expect(page.getByRole('heading', { name: 'Step 2: Pick a Date & Time' })).toBeVisible();
    
    // Find the next Wednesday (day_of_week: 3), which we seeded as available
    let bookingDate = new Date();
    while (getDay(bookingDate) !== 3) {
      bookingDate = addDays(bookingDate, 1);
    }
    const dateString = format(bookingDate, 'yyyy-MM-dd');

    await page.getByLabel('Select Date:').fill(dateString);

    // Wait for slots to load and click the first available one (e.g., 9:00 AM)
    const nineAmSlot = page.getByRole('button', { name: '9:00 AM' });
    await expect(nineAmSlot).toBeVisible({ timeout: 10000 }); // Wait up to 10s for slots
    await nineAmSlot.click();

    // Step 3: Confirm booking
    await expect(page.getByRole('heading', { name: 'Step 3: Confirm Your Booking' })).toBeVisible();
    await expect(page.getByText('Service: E2E Test Detail')).toBeVisible();

    await page.getByLabel('Service Address:').fill('123 Test St, Anytown, USA');
    await page.getByRole('button', { name: 'Confirm Booking' }).click();

    // Verification: Check for success message on the customer dashboard
    await expect(page).toHaveURL(/.*dashboard\/customer\?message=Booking successful!/);
    await expect(page.getByText('Booking successful!')).toBeVisible();

    // Verify the booking is displayed on the dashboard
    await expect(page.getByRole('heading', { name: 'E2E Test Detail' })).toBeVisible();
    await expect(page.getByText('Status: pending')).toBeVisible();
  });
});
```

---

### **Step 4: Running Your E2E Tests**

1. **Start your development server**: The tests need the application to be running.

    ```bash
    npm run dev
    ```

2. **Run the tests from your terminal**: In a *new terminal window*, run:

    ```bash
    npx playwright test
    ```

    This will run all tests in the `e2e/` directory headlessly.

3. **View the HTML Report**: After the run completes, a report is generated.

    ```bash
    npx playwright show-report
    ```

    This report is invaluable for seeing what happened, including traces, screenshots, and videos of failed tests.

4. **Run in UI Mode (Highly Recommended for Development)**: Playwright's UI mode is a powerful tool for writing and debugging tests.

    ```bash
    npx playwright test --ui
    ```

    This opens a browser window where you can see your tests run live, step through them, and inspect the page at any point.

---

### **Step 5: Next Steps and Best Practices**

* **Add `data-testid` Attributes**: To make your tests more resilient to changes in text or styling, add `data-testid` attributes to key elements in your React components.
  * Example: `<button data-testid="confirm-booking-btn">Confirm Booking</button>`
  * In Playwright: `page.getByTestId('confirm-booking-btn').click()`

* **Test Detailer and Admin Dashboards**: Use the same patterns as above to create `e2e/detailer.spec.ts` and `e2e/admin.spec.ts`.
  * For the detailer, log in as `testUsers.detailer`, navigate to their dashboard, and assert that the booking created by the customer test is visible.
  * For the admin, log in as `testUsers.admin`, navigate to the bookings page, find the test booking, and use the UI to change its status to "confirmed". Then, you could even add a step to the detailer test to verify the status updated on their dashboard.

* **CI/CD Integration**: The GitHub Actions workflow created during setup (`.github/workflows/playwright.yml`) provides a solid foundation. It will automatically run your E2E tests on every push or pull request, preventing regressions from being merged. You will need to add your Supabase environment variables as secrets to your GitHub repository for the tests to run in the CI environment.

By following this guide, you have established a robust end-to-end testing suite that verifies your application's critical user flows, ensuring a high-quality and reliable experience for your users.

**Metadata:**

```json
{
  "subtask_id": "testing",
  "title": "End-to-End Testing",
  "expertise": "QA Engineering"
}
```

### DevOps Engineering Specialist

Here is the detailed guide for the **Deployment to Production** subtask.

This final phase takes your locally developed "Mobile Detailing Concierge" application and makes it live on the internet using Vercel, the platform created by the makers of Next.js. This ensures a seamless, performant, and scalable deployment experience.

---

### **Why Vercel?**

* **Optimized for Next.js:** Vercel provides a native, first-class experience for Next.js, automatically handling optimizations like Incremental Static Regeneration (ISR), Server Components, and API routes without any complex configuration.
* **Git-Based Workflow:** Deployment is as simple as pushing your code to a Git repository. Vercel automatically builds and deploys every change.
* **Global CDN:** Your application is deployed to a global Edge Network, ensuring fast load times for users anywhere in the world.
* **Automatic SSL:** Vercel automatically provisions and renews SSL certificates for all your domains, ensuring your site is secure (HTTPS).

---

### **Prerequisites**

1. **Vercel Account:** If you don't have one, sign up at [vercel.com](https://vercel.com). The easiest way is to sign up using your GitHub, GitLab, or Bitbucket account.
2. **Code on a Git Provider:** Your project's code must be hosted on a Git provider like GitHub. If you've been working locally, now is the time to push it.
3. **Supabase Project Ready:** Your Supabase project should be set up with the necessary tables, RLS policies, and functions.

---

### **Step 1: Push Your Project to GitHub**

If your code isn't already in a GitHub repository, follow these steps:

1. **Create a new repository on GitHub:** Go to GitHub, create a new repository (e.g., `mobile-detailing-concierge`), and make it private or public. Do *not* initialize it with a README or .gitignore file.

2. **Initialize Git locally and push your code:** In your project's root directory, run the following commands, replacing the URL with your repository's URL.

    ```bash
    # Make sure you have a .gitignore file (Next.js creates one)
    # It should include node_modules/ and .env.local

    git init -b main
    git add .
    git commit -m "Initial commit: Ready for deployment"
    git remote add origin https://github.com/your-username/mobile-detailing-concierge.git
    git push -u origin main
    ```

---

### **Step 2: Import and Deploy Project on Vercel**

1. **Log in to your Vercel dashboard.**

2. **Add New Project:** Click the "Add New..." button and select "Project".

3. **Import Git Repository:** Vercel will show a list of your Git repositories. Find your `mobile-detailing-concierge` repository and click the "Import" button next to it.

4. **Configure Project:** Vercel will automatically detect that you're using Next.js and pre-fill the build settings. You don't need to change the "Framework Preset" or "Build and Output Settings". The most critical step is configuring the environment variables.

---

### **Step 3: Configure Production Environment Variables**

Your local `.env.local` file is not committed to Git for security reasons. You must provide these secrets to Vercel through its dashboard.

1. **Expand the "Environment Variables" section** in the Vercel project configuration screen.

2. **Find your Supabase keys:**
    * Go to your Supabase project dashboard.
    * Navigate to **Project Settings > API**.
    * You will find your `URL`, `anon (public)` key, and `service_role (secret)` key here.
    * Navigate to **Project Settings > API > JWT Settings**.
    * You will find your `JWT Secret` here.

3. **Add the variables to Vercel:** Add each variable one by one.

    | Vercel Variable Name          | Value Source                                         | Type   | Note                                                                        |
    | ----------------------------- | ---------------------------------------------------- | ------ | --------------------------------------------------------------------------- |
    | `NEXT_PUBLIC_SUPABASE_URL`    | Your Supabase Project URL                            | Public | Prefixed with `NEXT_PUBLIC_` so it's available in the browser.              |
    | `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Your Supabase `anon` (public) key                    | Public | Also prefixed with `NEXT_PUBLIC_` for browser access.                       |
    | `SUPABASE_SERVICE_ROLE_KEY`   | Your Supabase `service_role` (secret) key            | Secret | **Do not** prefix with `NEXT_PUBLIC_`. This is for server-side use only.   |
    | `JWT_SECRET`                  | Your Supabase JWT Secret                             | Secret | **Do not** prefix with `NEXT_PUBLIC_`. Used for server-side auth checks. |

4. **Click "Deploy"**. Vercel will now pull your code, install dependencies, build the project using the environment variables you provided, and deploy it.

You'll see a build log in real-time. Once it's finished, you'll get a confirmation message with confetti and links to your live site. Congratulations, your application is now live on a `.vercel.app` domain!

---

### **Step 4: Add a Custom Domain**

Using a professional domain name like `yourdetailingservice.com` is essential.

1. **Navigate to your Project's Settings:** In the Vercel dashboard, go to your newly deployed project and click on the "Settings" tab, then select "Domains".

2. **Add Your Domain:** Enter your custom domain (e.g., `mobiledetailconcierge.com`) and click "Add". Vercel will recommend a configuration, usually pointing to Vercel's nameservers.

3. **Configure Your DNS:**
    * **Recommended Method (Using Vercel Nameservers):** Log in to your domain registrar (GoDaddy, Namecheap, etc.). Find the DNS or nameserver settings and replace the existing nameservers with the ones Vercel provides. This gives Vercel full control to manage DNS records for you, which is the simplest and most reliable method.
    * **Alternative Method (Using A/CNAME Records):** If you need to manage your DNS elsewhere, Vercel will provide an `A` record value for your root domain (`@`) and a `CNAME` record for your `www` subdomain. You will need to create these records in your registrar's DNS settings.

4. **Wait for Propagation:** DNS changes can take anywhere from a few minutes to several hours to propagate across the internet. Vercel will automatically detect when the changes are complete and issue an SSL certificate for your domain. The status in the Vercel domains dashboard will change to "Valid Configuration".

---

### **Step 5: Final Production Checks for Supabase**

Before you start marketing your service, perform these crucial checks in your Supabase project.

1. **Enable Row Level Security (RLS):** Double-check that RLS is **enabled** on all tables containing sensitive user data (e.g., `profiles`, `bookings`, `detailers`). This is the most important security feature.
2. **Review RLS Policies:** Read through your RLS policies one last time to ensure they correctly restrict access. For example, a user should only be able to see their own bookings, and a detailer should only see bookings assigned to them.
3. **Set a Strong Database Password:** Go to **Project Settings > Database** and set a very strong, generated password. You won't need this password for the app to function (it uses the API keys), but it's critical for securing direct database access.
4. **Configure Email Templates:** In the Supabase dashboard, go to **Authentication > Email Templates**. Customize the "Confirm Signup", "Reset Password", and other templates to match your brand's voice and design.
5. **(Optional) Set up a Custom SMTP:** For a more professional look, configure a custom SMTP provider (like SendGrid or Resend) under **Authentication > SMTP Settings**. This ensures confirmation and password reset emails come from your domain (e.g., `noreply@mobiledetailconcierge.com`) instead of a generic Supabase address.

Your Mobile Detailing Concierge is now fully deployed, secure, and ready for business. Any future changes you `git push` to your `main` branch will automatically trigger a new deployment on Vercel, keeping your live application up-to-date with your latest code.

**Metadata:**

```json
{
  "subtask_id": "deployment",
  "title": "Deployment to Production",
  "expertise": "DevOps Engineering"
}
```

### Results Integrator

Of course. Here is a comprehensive technical architecture and implementation guide for building the "Mobile Detailing Concierge" platform using the Next.js App Router and Supabase.

### **Executive Summary**

This guide outlines a complete, production-ready technical architecture for a mobile car detailing concierge service. The solution is built on a modern, scalable stack: **Next.js with the App Router** for the frontend and server-side logic, and **Supabase** as the all-in-one backend for the database, authentication, and storage.

The architecture is broken down into five phases, guiding you from initial project setup to a live, deployed application:

1. **Foundation:** Establishes the Next.js project, Supabase backend, database schema, and security rules.
2. **Authentication:** Implements a robust user management system with distinct roles for customers, detailers, and administrators.
3. **Core Features:** Builds the customer-facing landing page and the multi-step booking system.
4. **Dashboards:** Creates secure, role-specific dashboards for detailers to manage their schedules and for the concierge to manage the entire platform.
5. **Testing & Deployment:** Ensures application quality with end-to-end testing and provides a clear path to production using Vercel.

---

### **Phase 1: Project Foundation**

This phase lays the essential groundwork for the entire application.

#### **Step 1.1: Initializing the Next.js Project**

We'll begin by creating a new Next.js project using the recommended App Router and TypeScript for a robust development experience.

1. Open your terminal and run the `create-next-app` command:

    ```bash
    npx create-next-app@latest mobile-detailing-concierge
    ```

2. When prompted, select the following options for a modern setup:
    * Use TypeScript? **Yes**
    * Use ESLint? **Yes**
    * Use Tailwind CSS? **Yes**
    * Use `src/` directory? **Yes**
    * Use App Router? **Yes**
    * Customize default import alias? **No**
3. Navigate into your new project directory:

    ```bash
    cd mobile-detailing-concierge
    ```

#### **Step 1.2: Setting Up the Supabase Backend**

Next, create the Supabase project that will serve as your database and authentication provider.

1. Log in to your account at [app.supabase.com](https://app.supabase.com/) and click **"New project"**.
2. Name your project (e.g., `mobile-detailing-concierge`), generate and securely save a database password, and choose the region closest to your users.
3. Click **"Create new project"**.

#### **Step 1.3: Connecting Next.js and Supabase**

Securely connect your Next.js application to Supabase using environment variables.

1. In your Supabase project dashboard, navigate to **Project Settings > API**.
2. Copy the **Project URL** and the `anon` `public` **Project API Key**.
3. In your Next.js project root, create a file named `.env.local` and add your credentials:

    ```.env.local
    NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_PROJECT_URL
    NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
    ```

    The `NEXT_PUBLIC_` prefix is required by Next.js to expose these variables to the browser.

4. Install the Supabase client libraries, including the package specifically designed for server-side rendering (`ssr`):

    ```bash
    npm install @supabase/supabase-js @supabase/ssr
    ```

#### **Step 1.4: Database Schema & Security**

This is the blueprint for your application's data. We will create all necessary tables and secure them with Supabase's powerful Row Level Security (RLS).

Go to the **SQL Editor** in your Supabase dashboard, create a new query, and run the following script to set up your entire database structure.

**Schema Creation Script:**

```sql
-- ========= CUSTOM TYPES =========
CREATE TYPE public.user_role AS ENUM ('customer', 'detailer', 'admin');
CREATE TYPE public.booking_status AS ENUM ('pending', 'confirmed', 'completed', 'cancelled');

-- ========= TABLES =========
-- Stores public user data and links to auth.users
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name text,
  phone_number text,
  role public.user_role NOT NULL DEFAULT 'customer'
);

-- Stores detailer-specific information
CREATE TABLE public.detailers (
  id uuid NOT NULL PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  business_name text,
  service_area_description text,
  is_active boolean NOT NULL DEFAULT false
);

-- Catalog of detailing packages offered
CREATE TABLE public.services (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  name text NOT NULL,
  description text,
  price numeric(10, 2) NOT NULL,
  estimated_duration_minutes integer NOT NULL,
  is_active boolean NOT NULL DEFAULT true
);

-- The core table for appointments
CREATE TABLE public.bookings (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id),
  detailer_id uuid REFERENCES public.profiles(id),
  service_id uuid NOT NULL REFERENCES public.services(id),
  booking_time timestamp with time zone NOT NULL,
  location_address text NOT NULL,
  status public.booking_status NOT NULL DEFAULT 'pending',
  final_price numeric(10, 2) NOT NULL
);

-- Stores recurring weekly availability for detailers
CREATE TABLE public.detailer_availability (
  id uuid NOT NULL PRIMARY KEY DEFAULT uuid_generate_v4(),
  detailer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_of_week smallint NOT NULL CHECK (day_of_week >= 0 AND day_of_week <= 6), -- 0=Sun, 6=Sat
  start_time time NOT NULL,
  end_time time NOT NULL,
  UNIQUE (detailer_id, day_of_week)
);

-- ========= TRIGGERS =========
-- Creates a profile entry when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

**Row Level Security (RLS) Policies:**

Next, run this script in the SQL Editor to enable RLS and apply security rules. This ensures users can only access data they are permitted to see.

```sql
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detailers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detailer_availability ENABLE ROW LEVEL SECURITY;

-- POLICIES: profiles
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- POLICIES: bookings
CREATE POLICY "Customers can create their own bookings" ON public.bookings FOR INSERT WITH CHECK (auth.uid() = customer_id);
CREATE POLICY "Customers can view their own bookings" ON public.bookings FOR SELECT USING (auth.uid() = customer_id);
CREATE POLICY "Detailers can view bookings assigned to them" ON public.bookings FOR SELECT USING (auth.uid() = detailer_id);

-- POLICIES: detailer_availability
CREATE POLICY "Detailers can manage their own availability" ON public.detailer_availability FOR ALL USING (auth.uid() = detailer_id);
CREATE POLICY "Authenticated users can view availability" ON public.detailer_availability FOR SELECT USING (auth.role() = 'authenticated');

-- POLICIES: services
CREATE POLICY "Public can view active services" ON public.services FOR SELECT USING (is_active = true);

-- NOTE: Admin access is typically handled by disabling RLS for specific server-side operations using the SERVICE_ROLE_KEY, or by creating specific admin policies.
```

---

### **Phase 2: User Authentication & Authorization**

With the foundation in place, we'll build the complete authentication system.

#### **Step 2.1: Create Supabase Client Helpers**

To interact with Supabase seamlessly across client components, server components, and middleware, we create a set of helper functions.

Create a new folder `src/lib/supabase` and add the following files:

* **`src/lib/supabase/client.ts`** (For Client Components)

    ```typescript
    import { createBrowserClient } from '@supabase/ssr'
    export function createClient() {
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
    }
    ```

* **`src/lib/supabase/server.ts`** (For Server Components/Actions)

    ```typescript
    import { createServerClient, type CookieOptions } from '@supabase/ssr'
    import { cookies } from 'next/headers'
    // ... (full code provided in subtask result)
    ```

* **`src/lib/supabase/middleware.ts`** (For Middleware)

    ```typescript
    import { createServerClient, type CookieOptions } from '@supabase/ssr'
    import { type NextRequest, type NextResponse } from 'next/server'
    // ... (full code provided in subtask result)
    ```

#### **Step 2.2: Implement Login & Signup Pages**

Create pages with forms that use Next.js Server Actions to securely handle user credentials.

* **`app/signup/page.tsx`**: A form with fields for full name, email, password, and a role selector (`Car Owner` or `Detailer`). The `signUp` server action will call `supabase.auth.signUp` and update the user's role in the `profiles` table.
* **`app/login/page.tsx`**: A form with email and password fields. The `signIn` server action calls `supabase.auth.signInWithPassword`, then checks the user's role from the `profiles` table to redirect them to the correct dashboard (`/dashboard/customer`, `/dashboard/detailer`, or `/admin`).

#### **Step 2.3: Handle Authentication Callbacks**

When a user confirms their email, Supabase redirects them to a specific route. Create this route to exchange the confirmation code for a valid user session.

* **`app/auth/callback/route.ts`**: This route handler will parse the `code` from the URL, call `supabase.auth.exchangeCodeForSession`, and redirect the user to their dashboard.

#### **Step 2.4: Secure Routes with Middleware**

Middleware runs before a request is completed, making it the ideal place to protect routes. Create a `middleware.ts` file in the root of your project.

* **`middleware.ts`**: This file will:
  * Refresh the user's session on every request.
  * Redirect unauthenticated users trying to access `/dashboard` or `/admin` to the `/login` page.
  * Redirect authenticated users away from `/login` or `/signup`.
  * Check the user's role and block non-admins from accessing the `/admin` path.

---

### **Phase 3: Core Feature Implementation**

Now we'll build the primary features that customers interact with.

#### **Step 3.1: Building the Public Landing Page**

Create a visually appealing landing page to attract customers and showcase your services.

* **`app/page.tsx`**: This will be an `async` Server Component.
    1. It will use the server Supabase client to fetch all active services from the `services` table (`select * from services where is_active = true`).
    2. It will render a hero section with your value proposition.
    3. It will map over the fetched services and display each one in a `ServiceCard` component, showing the name, description, price, and a "Book Now" button.

#### **Step 3.2: Implementing the Multi-Step Booking System**

This is the core functionality of the concierge service.

1. **Create Server Actions (`app/book/actions.ts`)**:
    * `getServices()`: Fetches all active detailing services.
    * `getAvailableSlots(date, duration)`: A complex action that finds all available time slots on a given day by:
        * Fetching all active detailers and their weekly availability.
        * Fetching all existing bookings for that day.
        * Calculating potential time slots and filtering out any that conflict with existing bookings.
    * `createBooking(formData)`: The final action that:
        * Validates the selected service and time slot.
        * Assigns an available detailer to the job.
        * Inserts a new record into the `bookings` table with a `pending` status.
        * Redirects the user to their dashboard with a success message.

2. **Create the Booking Page (`app/book/page.tsx`)**:
    * This will be a client component (`'use client'`) to manage the state of the multi-step form.
    * **Step 1:** Display services fetched via the `getServices` action. The user selects one.
    * **Step 2:** Show a date picker. When a date is chosen, it calls the `getAvailableSlots` action and displays the returned time slots as clickable buttons.
    * **Step 3:** Display a confirmation summary of the selected service, date, and time. The user enters their address and submits the form, which calls the `createBooking` server action.

---

### **Phase 4: Role-Based Dashboards**

Create secure areas for detailers and the admin to manage their respective tasks.

#### **Step 4.1: Developing the Detailer Dashboard**

This dashboard is the central hub for your detailers.

* **`app/dashboard/detailer/page.tsx`**: A secure Server Component that:
    1. Verifies the logged-in user has the `detailer` role.
    2. Fetches all necessary data for that specific detailer ID in parallel:
        * Assigned bookings from the `bookings` table.
        * Current weekly availability from `detailer_availability`.
        * Completed jobs to calculate earnings.
    3. Passes this data to client components for display and interaction.
* **Components:**
  * **`EarningsSummary`**: Displays key metrics like total completed jobs and total earnings (after commission).
  * **`BookingsList`**: Shows upcoming and past jobs, including customer details and service location.
  * **`AvailabilityManager`**: A form where the detailer can set their recurring weekly work hours (e.g., Monday 9 AM - 5 PM). Submitting this form calls a server action to update their schedule in the `detailer_availability` table.

#### **Step 4.2: Building the Admin/Concierge Dashboard**

This is the control panel for the entire business, protected by the middleware to be admin-only.

* **`app/admin/layout.tsx`**: A shared layout for all admin pages with consistent navigation (Dashboard, Bookings, Detailers, Services).
* **Admin Pages (`app/admin/**/page.tsx`)**: A series of Server Components, each with a specific management function:
  * **Dashboard (`/admin`):** Displays high-level statistics like total revenue, commissions owed, and pending bookings.
  * **Bookings Management:** Shows a table of *all* bookings. The admin can view details and update the status of any booking (e.g., change from `pending` to `confirmed`).
  * **Detailer Management:** A page to view all detailers, activate/deactivate their profiles, and edit their information. Includes a form for adding new detailers to the network.
  * **Service Management:** A page to create, edit, and update the detailing packages offered on the platform.
* **Admin Server Actions (`app/admin/actions.ts`)**: A set of secure server actions for creating, updating, and deleting services and detailers, and for modifying booking statuses. These actions will use the Supabase admin client to bypass RLS policies when necessary.

---

### **Phase 5: Testing and Deployment**

The final phase ensures your application is reliable and makes it accessible to the world.

#### **Step 5.1: End-to-End Testing with Playwright**

Simulate real user journeys to validate that all parts of the application work together correctly.

1. **Setup:** Install Playwright (`npm init playwright@latest`) and configure it to use your local development server's URL (`http://localhost:3000`).
2. **Database Seeding:** Create a script (`e2e/utils/seed.ts`) that resets the database and populates it with known test users (customer, detailer, admin) and data before each test run. This ensures a consistent state for reliable testing.
3. **Write Test Scenarios:** Create test files for critical user flows:
    * **`auth.spec.ts`**: Tests user signup, login with different roles, and logout.
    * **`booking.spec.ts`**: Logs in as a customer, navigates the multi-step booking form, confirms a booking, and verifies it appears on their dashboard.
    * **`detailer.spec.ts`**: Logs in as a detailer and verifies they can see the booking created in the previous test.
    * **`admin.spec.ts`**: Logs in as an admin, navigates to the bookings page, and confirms the test booking.

#### **Step 5.2: Deploying to Production with Vercel**

Vercel provides a seamless, one-click deployment experience for Next.js applications.

1. **Push to Git:** Ensure your project code is pushed to a GitHub, GitLab, or Bitbucket repository.
2. **Import to Vercel:** Log in to Vercel, import your Git repository, and Vercel will automatically detect the Next.js framework.
3. **Configure Environment Variables:** In the Vercel project settings, add the same environment variables from your `.env.local` file (`NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY`). These are now your production credentials.
4. **Deploy:** Click the "Deploy" button. Vercel will build and deploy your application to a global CDN.
5. **Add Custom Domain:** In your Vercel project's "Domains" tab, add your custom domain and follow the instructions to update your DNS records with your domain registrar. Vercel will automatically handle SSL certificate provisioning.
6. **Final Supabase Checks:** Ensure RLS is enabled on all tables, set a strong database password, and customize the user-facing email templates in the Supabase dashboard.

**Metadata:**

```json
{
  "subtask_count": 9
}
```
