# Agent Response - orchestrator_workers

**Session ID**: 6ab90142-ae65-4e7b-9580-092238b74d26
**Processing Time**: 552.83 seconds

## Final Response

Of course. Based on your comprehensive business plan for HOMEase | AI, here is a detailed technical implementation plan to build the platform using a Next.js frontend, Firebase Hosting, and a Firebase Cloud Functions backend.

This plan synthesizes the necessary steps, from initial setup to deploying a full-featured application, providing a clear roadmap for your development team.

---

### **Phase 1: Backend Foundation & Setup**

This phase establishes the core infrastructure for your application on Firebase.

#### **Step 1: Firebase Project Initialization**

First, create and configure your Firebase project, which will serve as the central hub for your backend services.

1.  **Create the Project:**
    *   Navigate to the [Firebase Console](https://console.firebase.google.com/).
    *   Click **+ Add project**, name it `HOMEase-AI`, and enable **Google Analytics** when prompted. Analytics is crucial for tracking user funnels and conversions, which are central to your business model.

2.  **Enable Core Services:**
    *   **Authentication:** In the console, go to **Build > Authentication** and click "Get started". Enable the **Email/Password** and **Google** sign-in providers. These will be used for both homeowner and contractor accounts.
    *   **Firestore Database:** Go to **Build > Firestore Database** and create a new database. Start in **test mode** for initial development (this allows open access), but we will secure it with rules later. Select a server location close to your target market (e.g., `us-central`).
    *   **Cloud Functions & Hosting:** These will be initialized via the command line in the next steps.

#### **Step 2: Firestore Database Schema Design**

A well-designed schema is critical for performance and scalability. Here are the core data models for your Firestore database.

*   **`/users/{userId}`** (For Homeowners)
    *   Stores homeowner profiles. The document ID is their Firebase Auth `uid`.
    ```json
    {
      "email": "sandra.p@example.com",
      "displayName": "Sandra Peterson",
      "role": "homeowner",
      "address": { "city": "Austin", "state": "TX", "zipCode": "78701" },
      "createdAt": "2025-01-15T10:00:00Z"
    }
    ```

*   **`/contractors/{contractorId}`**
    *   Stores contractor profiles, including vetting and performance data. The document ID is their Firebase Auth `uid`.
    ```json
    {
      "email": "contact@reliable-remodeling.com",
      "businessName": "Reliable Remodeling LLC",
      "role": "contractor",
      "serviceAreas": ["78701", "78704"],
      "specializations": ["bathroom_remodel", "ramp_installation"],
      "vettingStatus": "approved", // 'pending', 'approved', 'rejected'
      "isCAPSCertified": true,
      "performanceTier": "Gold", // 'Bronze', 'Silver', 'Gold', 'Platinum'
      "fcmTokens": ["token1", "token2"], // For push notifications
      "createdAt": "2025-02-01T09:00:00Z"
    }
    ```

*   **`/assessments/{assessmentId}`**
    *   Stores the processed results from the AR scan analysis.
    ```json
    {
      "homeownerUid": "user_uid_here",
      "scanId": "original_scan_id",
      "status": "completed",
      "summary": { "critical": 1, "recommended": 2, "total": 3 },
      "identifiedNeeds": [
        {
          "needId": "uuid_here",
          "category": "General Accessibility",
          "type": "DoorwayWidth",
          "severity": "Critical",
          "description": "Doorway is 29.5\" wide, less than the recommended 32\".",
          "suggestedModification": "Widen doorway.",
          "estimatedCostRange": { "min": 200, "max": 7000 }
        }
      ],
      "createdAt": "2025-03-10T14:30:00Z"
    }
    ```

*   **`/leads/{leadId}`**
    *   The central transactional collection for the marketplace. The `leadId` will be the same as the `assessmentId`.
    ```json
    {
      "homeownerUid": "user_uid_here",
      "assessmentId": "assessment_id_here",
      "status": "matched", // 'new', 'matched', 'contacted', 'won', 'lost'
      "matchedContractors": [
        {
          "contractorUid": "contractor_uid_here",
          "status": "contacted",
          "paymentStatus": "paid",
          "price": 40.00
        }
      ],
      "createdAt": "2025-03-10T14:45:00Z"
    }
    ```

*   **`/chats/{chatId}`**
    *   Manages conversation metadata between a homeowner and a contractor.
    ```json
    {
      "chatId": "auto_generated_id",
      "leadId": "lead_id_here",
      "participants": ["homeowner_uid", "contractor_uid"],
      "lastMessage": {
        "text": "Hello, I'd like to discuss the assessment.",
        "timestamp": "2025-03-11T09:00:00Z",
        "senderId": "homeowner_uid"
      },
      "updatedAt": "2025-03-11T09:00:00Z"
    }
    ```
    *   **Subcollection:** `/chats/{chatId}/messages/{messageId}` will store the actual message content.

#### **Step 3: Core Backend API (User & Contractor Profiles)**

We'll use an Express.js app running within a single Cloud Function for an organized and performant API.

1.  **Initialize Firebase in your local project:**
    *   Run `firebase login`.
    *   Run `firebase init` and select **Firestore**, **Functions**, and **Hosting**. Choose your `HOMEase-AI` project.
    *   For Functions, select **TypeScript**.
    *   For Hosting, set the public directory to your Next.js build output (we'll configure this later).

2.  **Install Dependencies** in the `functions` directory:
    ```bash
    cd functions
    npm install express cors
    npm install --save-dev @types/express @types/cors
    ```

3.  **Create the API Endpoints:** Set up a file structure as detailed in the subtasks. The core logic involves creating, retrieving, and updating user and contractor profiles. An authentication middleware will protect these routes by verifying the user's Firebase ID token.

    **Example Controller Function (`profile.controller.ts`):**
    ```typescript
    import * as admin from 'firebase-admin';
    import { Response } from 'express';
    // ... other imports

    // This function runs after a user signs up on the frontend.
    export const createProfile = async (req: AuthenticatedRequest, res: Response) => {
      const { uid, email } = req.user!;
      const { role, ...profileData } = req.body;

      // Set a custom claim for role-based access control
      await admin.auth().setCustomUserClaims(uid, { role });

      const collection = role === 'contractor' ? 'contractors' : 'users';
      const newProfile = {
        uid,
        email: email!,
        role,
        createdAt: admin.firestore.Timestamp.now(),
        updatedAt: admin.firestore.Timestamp.now(),
        ...(role === 'contractor' ? { vettingStatus: 'pending', performanceTier: 'Bronze' } : {}),
        ...profileData,
      };

      await db.collection(collection).doc(uid).set(newProfile);
      return res.status(201).send(newProfile);
    };
    ```

4.  **Deploy the API:**
    ```bash
    firebase deploy --only functions
    ```
    This gives you a base API URL to use in your frontend.

---

### **Phase 2: Frontend Foundation & User Management**

Now, we'll build the Next.js frontend and connect it to our backend.

#### **Step 4: Next.js Frontend Setup**

1.  **Initialize Project:** Create a new Next.js app with TypeScript, ESLint, Tailwind CSS, and the App Router.
    ```bash
    npx create-next-app@latest homease-frontend
    ```

2.  **Integrate Shadcn UI:** This provides a beautiful and highly customizable component library.
    ```bash
    cd homease-frontend
    npx shadcn-ui@latest init
    ```
    Follow the prompts, accepting the defaults. This will configure Tailwind CSS and create helper files.

3.  **Install Initial Components:**
    ```bash
    npx shadcn-ui@latest add button card form input label select toast
    ```

4.  **Establish Project Structure:** Organize your `app` directory with route groups like `(auth)` for login/register pages and `(main)` for the core application dashboard. Create folders for `components`, `hooks`, `lib`, and `types`.

#### **Step 5: Frontend Authentication & Profile Management**

1.  **Configure Firebase Client:** Create a file (`lib/firebase/client.ts`) to initialize the Firebase client SDK using your project's web configuration keys (stored in a `.env.local` file for security).

2.  **Create an `AuthContext`:** This React Context will manage the global authentication state, providing the current `user` object and their `profile` data (fetched from your `/api/profile` endpoint) to the entire application. It will also handle route protection, redirecting unauthenticated users from protected pages.

3.  **Build Registration & Login Pages:**
    *   Use `react-hook-form` and `zod` for robust, type-safe form validation.
    *   **Registration Flow:**
        1.  User fills out the form (name, email, password, role).
        2.  Call Firebase Auth's `createUserWithEmailAndPassword`.
        3.  On success, get the user's ID token.
        4.  Make a `POST` request to your backend's `/api/profile` endpoint, sending the token in the `Authorization` header and the chosen role in the body.
        5.  Redirect to the dashboard.
    *   **Login Flow:**
        1.  User fills out the form (email, password).
        2.  Call Firebase Auth's `signInWithEmailAndPassword`.
        3.  The `AuthContext` will automatically detect the state change, fetch the user's profile, and redirect to the dashboard.

---

### **Phase 3: The Core Feature - AR Assessment & Lead Generation**

This is the most innovative and complex part of the application. A hybrid native/web approach is required for the best results.

#### **Step 6: The AR Home Assessment Module (Hybrid Approach)**

**Why a Hybrid App?** The WebXR API in browsers does not currently provide the low-level LiDAR mesh data needed for accurate room scanning. Therefore, a small, dedicated **native iOS app** using Swift and ARKit is the most robust solution. The main Next.js app will orchestrate the process.

1.  **Web-to-Native Bridge (Next.js):**
    *   When the user clicks "Start Scan" on an iPhone, the Next.js app makes a `POST` request to a Cloud Function to create a `scan` document in Firestore with a `pending` status.
    *   The function returns the `scanId`.
    *   The Next.js app then redirects the user to a **Universal Link** (e.g., `homease://scan?scanId=...&token=...`), passing the `scanId` and a Firebase Auth token. This link opens the native iOS app.

2.  **Native iOS Scanner App (Swift & ARKit):**
    *   The app launches and receives the `scanId` and auth `token`.
    *   It uses the token to authenticate with Firebase silently.
    *   It starts an `ARWorldTrackingConfiguration` with `sceneReconstruction` enabled to capture the room's LiDAR mesh.
    *   When the user finishes, the app processes the `ARMeshAnchor` data into a structured JSON format (containing vertices, faces, and identified features like doorways).
    *   It uploads this JSON file to a private folder in **Firebase Storage** (e.g., `/scans/{userId}/{scanId}/data.json`).
    *   Finally, it updates the `scan` document in Firestore, setting the `status` to `completed` and adding the `scanResultUrl`.

3.  **Displaying Results (Next.js):**
    *   The user is directed back to a results page in the Next.js app (e.g., `/dashboard/scans/{scanId}`).
    *   This page uses a real-time Firestore listener (`onSnapshot`) to watch the `scan` document. When the status changes to `completed`, it downloads the JSON from Storage and displays the results.

#### **Step 7: Backend AR Data Processing**

This is the "AI" part of your platform, where raw scan data is turned into actionable insights.

*   **Create a Cloud Function Trigger:** This function (`processArScan`) is triggered `onUpdate` of any document in the `scans` collection.
*   **Logic:**
    1.  It runs only when a scan's `status` changes to `completed`.
    2.  It downloads the raw `data.json` file from Firebase Storage.
    3.  It runs the data through a **rule-based analysis engine** (`assessment.logic.ts`). This engine checks for common aging-in-place issues based on predefined constants (e.g., `ADA_DOORWAY_WIDTH_INCHES = 32`).
    4.  It identifies needs like narrow doorways, lack of grab bars, or trip hazards (shower curbs).
    5.  It generates a new document in the `assessments` collection containing a list of `identifiedNeeds`, their severity, and estimated cost ranges based on your business plan's data.

#### **Step 8: Lead Creation & Contractor Matching**

This automated workflow converts a completed assessment into a paid lead for contractors.

1.  **`createLeadFromAssessment` Function:** A Cloud Function triggered `onCreate` of a document in the `assessments` collection. It creates a corresponding `lead` document, populating it with a summary of the project and the homeowner's location.

2.  **`matchLeadToContractors` Function:** A second Cloud Function triggered `onCreate` of a document in the `leads` collection.
    *   It queries all `active` and `approved` contractors in the `contractors` collection.
    *   It filters them based on **location** (service area zip codes) and **specialization** (matching project needs like "bathroom remodel" to contractor skills).
    *   It scores and sorts the remaining contractors based on their **performance tier** (`Platinum` > `Gold`, etc.) and **CAPS certification**.
    *   It selects the top 3-5 matches and creates entries in the `matchedContractors` array within the lead document.

---

### **Phase 4: Building the Marketplace & Admin Tools**

These features bring the two-sided marketplace to life.

#### **Step 9: Contractor Lead Notification System**

Instant notifications are key to contractor engagement.

1.  **Setup SendGrid Extension:** Install the "Trigger Email" Firebase Extension. Configure it to watch a `mail` collection.
2.  **Create Notification Function:** A Cloud Function (`sendNotificationOnLeadAssignment`) is triggered `onCreate` of a `matchedContractor` entry in a lead.
3.  **Logic:**
    *   It fetches the contractor's profile to get their email and FCM push notification tokens.
    *   **Email:** It creates a document in the `mail` collection with the contractor's email and dynamic template data (project location, summary, link to the lead). The SendGrid extension handles the rest.
    *   **Push Notification (FCM):** It uses the Firebase Admin SDK to send a push notification directly to the contractor's devices, alerting them to the new lead instantly.

#### **Step 10: In-App Communication Tool**

A secure, real-time chat connects homeowners and contractors.

1.  **Backend:**
    *   Create a **Callable Cloud Function** (`initiateChat`) that a user can call to start a conversation. This function verifies that a valid lead exists between the two parties before creating a new `chat` document.
    *   Create a **Firestore Trigger** (`updateChatOnNewMessage`) that listens for new messages in the `/chats/{chatId}/messages` subcollection. It updates the parent `chat` document with the `lastMessage` metadata for display in a chat list.

2.  **Security Rules:** Implement strict Firestore rules to ensure only participants of a chat can read or write messages to it.

3.  **Frontend:**
    *   Build a `ChatWindow` component.
    *   Use a custom React hook (`useMessages`) with a real-time listener (`onSnapshot`) to display messages as they arrive.
    *   A "Contact Contractor" button on the lead details page calls the `initiateChat` function to start the conversation.

#### **Step 11: Contractor Vetting & Admin Dashboard**

Maintaining a high-quality contractor network is paramount.

1.  **Admin Backend Endpoints:**
    *   Create a new `admin.controller.ts` file for your Cloud Function API.
    *   Add an `isAdmin` middleware that checks for a custom claim (`admin: true`) on the user's token. You can set this claim manually on your staff's accounts using the Firebase Admin SDK.
    *   Create secure endpoints like `GET /api/admin/contractors?status=pending` to list contractors needing review and `PUT /api/admin/contractors/{id}/status` to approve/reject them or update their performance tier.

2.  **Admin Dashboard (Frontend):**
    *   Create a new route group in Next.js, such as `/admin`.
    *   Protect this entire route group in a layout file that checks for the user's `admin` custom claim. If the claim is missing, redirect the user away.
    *   Build UI tables and forms that call the secure admin endpoints to display contractor information, review their uploaded credentials (licenses, insurance), and update their status and tier.

---

### **Deployment & Next Steps**

1.  **Configure Hosting:** In your `firebase.json` file, configure Firebase Hosting to serve your Next.js application. This involves setting up rewrites to direct all requests to the Next.js server-side rendering function.
2.  **Deploy:** Run `firebase deploy` to push your Hosting configuration, Firestore rules, and all Cloud Functions to production.

This technical plan provides a robust, scalable, and secure foundation for HOMEase | AI. It directly implements the core value propositions of your business plan, from the innovative AR assessment to the efficient, high-quality lead generation marketplace.

## Intermediate Steps

### Task Coordinator

Task Understanding:
The user wants to build a full-stack application called HOMEase | AI. The platform's core function is to generate high-quality leads for aging-in-place home modifications by using an Augmented Reality (AR) tool for initial home assessments. The tech stack is specified as a Next.js frontend with Firebase Hosting and a Firebase Cloud Functions backend. The plan needs to cover the entire development process, from backend setup to frontend implementation, including the critical AR feature and contractor management tools.

Execution Strategy:
The project will be executed in four sequential phases, starting with a foundational backend setup in Firebase, followed by parallel frontend development in Next.js. The third phase will focus on the core high-risk/high-value AR feature, integrating it to create the primary lead generation pipeline. The final phase will build out value-add features like communication tools and contractor management systems. This strategy prioritizes building the core infrastructure first, enabling parallel workstreams, and tackling the most complex component (AR) as a dedicated work package before iterating on secondary features. Firebase Hosting will be used for continuous deployment and previews.

Subtasks:
1. Firebase Project Initialization and Authentication Setup (Priority: 1, Expertise: Firebase Specialist)
   Description: Set up the Firebase project, enable Authentication (Email/Password, Google), configure Firestore database, and establish initial security rules for data access. This provides the foundational backend infrastructure.
   Dependencies: None
2. Firestore Database Schema Design (Priority: 2, Expertise: Backend Developer)
   Description: Design and implement the Firestore data models for Users (homeowners), Contractors (with fields for vetting status, CAPS certification, etc.), Assessments (to store AR data), and Leads (linking homeowners to contractors).
   Dependencies: firebase_setup
3. Create Core Cloud Functions for User & Contractor Profiles (Priority: 3, Expertise: Backend Developer)
   Description: Develop Firebase Cloud Functions (Node.js/TypeScript) to handle user and contractor profile creation, updates, and retrieval. This includes creating an endpoint for contractors to submit their vetting information.
   Dependencies: firestore_schema
4. Setup Next.js Frontend with UI Framework (Priority: 4, Expertise: Frontend Developer)
   Description: Initialize a new Next.js project using the App Router. Integrate the chosen UI framework (Shadcn UI with Radix UI and Tailwind CSS) and establish the basic project structure, including layout, component folders, and routing.
   Dependencies: None
5. Implement Frontend Authentication and Profile Management (Priority: 5, Expertise: Frontend Developer)
   Description: Build the UI for user and contractor registration, login, and profile management. Integrate these components with the Firebase Authentication and Firestore backend to ensure a seamless user flow.
   Dependencies: firebase_setup, nextjs_setup, core_backend_functions
6. Build AR Home Assessment Module (Priority: 6, Expertise: AR/VR Developer)
   Description: Develop the core feature: an AR module for home assessment. This will likely require a native iOS component (using Swift/ARKit) or a sophisticated WebXR implementation to access LiDAR data. The module must guide the user through scanning a room, capture dimensional data, and output a structured data format (e.g., JSON) representing the floor plan and key features.
   Dependencies: frontend_auth
7. Develop Backend for AR Data Processing (Priority: 7, Expertise: Backend Developer)
   Description: Create a Firebase Cloud Function that receives the structured data from the AR module. This function will process the data to identify potential aging-in-place needs (e.g., narrow doorways, lack of grab bars) and generate a detailed assessment report stored in Firestore.
   Dependencies: ar_module, core_backend_functions
8. Implement Lead Creation and Contractor Matching Logic (Priority: 8, Expertise: Backend Developer)
   Description: Once an assessment is finalized, create a "Lead" document in Firestore. Develop a Cloud Function that implements the matching algorithm, connecting the lead to qualified contractors based on their specialization, location, and performance tier.
   Dependencies: process_ar_data
9. Create Lead Notification System for Contractors (Priority: 9, Expertise: Backend Developer)
   Description: Build a notification system using Firebase Cloud Messaging (FCM) or email triggers (e.g., using SendGrid extension) to instantly alert matched contractors about new, high-quality leads.
   Dependencies: lead_matching
10. Build In-App Communication Tool (Priority: 10, Expertise: Full-Stack Developer)
   Description: Develop a secure, real-time messaging feature using Firestore for homeowners and matched contractors to communicate, discuss the assessment, and schedule consultations.
   Dependencies: lead_matching
11. Develop Contractor Vetting and Tiering System (Priority: 11, Expertise: Full-Stack Developer)
   Description: Create a secure admin dashboard (can be a separate web app or a protected route in the main app) for internal staff to review and verify contractor credentials (licenses, insurance, CAPS certs) and manage their performance-based tiering.
   Dependencies: core_backend_functions

**Metadata:**
```json
{
  "subtasks": [
    {
      "priority": 1,
      "description": "Set up the Firebase project, enable Authentication (Email/Password, Google), configure Firestore database, and establish initial security rules for data access. This provides the foundational backend infrastructure.",
      "title": "Firebase Project Initialization and Authentication Setup",
      "dependencies": [],
      "required_expertise": "Firebase Specialist",
      "id": "firebase_setup"
    },
    {
      "dependencies": [
        "firebase_setup"
      ],
      "description": "Design and implement the Firestore data models for Users (homeowners), Contractors (with fields for vetting status, CAPS certification, etc.), Assessments (to store AR data), and Leads (linking homeowners to contractors).",
      "priority": 2,
      "id": "firestore_schema",
      "title": "Firestore Database Schema Design",
      "required_expertise": "Backend Developer"
    },
    {
      "id": "core_backend_functions",
      "priority": 3,
      "title": "Create Core Cloud Functions for User & Contractor Profiles",
      "required_expertise": "Backend Developer",
      "dependencies": [
        "firestore_schema"
      ],
      "description": "Develop Firebase Cloud Functions (Node.js/TypeScript) to handle user and contractor profile creation, updates, and retrieval. This includes creating an endpoint for contractors to submit their vetting information."
    },
    {
      "id": "nextjs_setup",
      "dependencies": [],
      "title": "Setup Next.js Frontend with UI Framework",
      "description": "Initialize a new Next.js project using the App Router. Integrate the chosen UI framework (Shadcn UI with Radix UI and Tailwind CSS) and establish the basic project structure, including layout, component folders, and routing.",
      "priority": 4,
      "required_expertise": "Frontend Developer"
    },
    {
      "title": "Implement Frontend Authentication and Profile Management",
      "required_expertise": "Frontend Developer",
      "dependencies": [
        "firebase_setup",
        "nextjs_setup",
        "core_backend_functions"
      ],
      "id": "frontend_auth",
      "priority": 5,
      "description": "Build the UI for user and contractor registration, login, and profile management. Integrate these components with the Firebase Authentication and Firestore backend to ensure a seamless user flow."
    },
    {
      "id": "ar_module",
      "required_expertise": "AR/VR Developer",
      "description": "Develop the core feature: an AR module for home assessment. This will likely require a native iOS component (using Swift/ARKit) or a sophisticated WebXR implementation to access LiDAR data. The module must guide the user through scanning a room, capture dimensional data, and output a structured data format (e.g., JSON) representing the floor plan and key features.",
      "priority": 6,
      "dependencies": [
        "frontend_auth"
      ],
      "title": "Build AR Home Assessment Module"
    },
    {
      "description": "Create a Firebase Cloud Function that receives the structured data from the AR module. This function will process the data to identify potential aging-in-place needs (e.g., narrow doorways, lack of grab bars) and generate a detailed assessment report stored in Firestore.",
      "required_expertise": "Backend Developer",
      "title": "Develop Backend for AR Data Processing",
      "id": "process_ar_data",
      "dependencies": [
        "ar_module",
        "core_backend_functions"
      ],
      "priority": 7
    },
    {
      "description": "Once an assessment is finalized, create a \"Lead\" document in Firestore. Develop a Cloud Function that implements the matching algorithm, connecting the lead to qualified contractors based on their specialization, location, and performance tier.",
      "id": "lead_matching",
      "required_expertise": "Backend Developer",
      "title": "Implement Lead Creation and Contractor Matching Logic",
      "priority": 8,
      "dependencies": [
        "process_ar_data"
      ]
    },
    {
      "dependencies": [
        "lead_matching"
      ],
      "priority": 9,
      "required_expertise": "Backend Developer",
      "description": "Build a notification system using Firebase Cloud Messaging (FCM) or email triggers (e.g., using SendGrid extension) to instantly alert matched contractors about new, high-quality leads.",
      "title": "Create Lead Notification System for Contractors",
      "id": "notification_system"
    },
    {
      "id": "communication_tool",
      "description": "Develop a secure, real-time messaging feature using Firestore for homeowners and matched contractors to communicate, discuss the assessment, and schedule consultations.",
      "required_expertise": "Full-Stack Developer",
      "dependencies": [
        "lead_matching"
      ],
      "title": "Build In-App Communication Tool",
      "priority": 10
    },
    {
      "description": "Create a secure admin dashboard (can be a separate web app or a protected route in the main app) for internal staff to review and verify contractor credentials (licenses, insurance, CAPS certs) and manage their performance-based tiering.",
      "dependencies": [
        "core_backend_functions"
      ],
      "required_expertise": "Full-Stack Developer",
      "id": "contractor_vetting",
      "title": "Develop Contractor Vetting and Tiering System",
      "priority": 11
    }
  ],
  "task_understanding": "The user wants to build a full-stack application called HOMEase | AI. The platform's core function is to generate high-quality leads for aging-in-place home modifications by using an Augmented Reality (AR) tool for initial home assessments. The tech stack is specified as a Next.js frontend with Firebase Hosting and a Firebase Cloud Functions backend. The plan needs to cover the entire development process, from backend setup to frontend implementation, including the critical AR feature and contractor management tools.",
  "execution_strategy": "The project will be executed in four sequential phases, starting with a foundational backend setup in Firebase, followed by parallel frontend development in Next.js. The third phase will focus on the core high-risk/high-value AR feature, integrating it to create the primary lead generation pipeline. The final phase will build out value-add features like communication tools and contractor management systems. This strategy prioritizes building the core infrastructure first, enabling parallel workstreams, and tackling the most complex component (AR) as a dedicated work package before iterating on secondary features. Firebase Hosting will be used for continuous deployment and previews."
}
```

### Firebase Specialist Specialist

Here is the detailed plan for the **Firebase Project Initialization and Authentication Setup** subtask for your HOMEase | AI application. This foundational step configures the secure and scalable backend infrastructure using Firebase.

### **Subtask: Firebase Project Initialization and Authentication Setup**

This guide will walk you through creating your Firebase project, setting up the necessary services (Authentication, Firestore, Functions, Hosting), and establishing initial security rules.

---

### **Step 1: Create Your Firebase Project**

1.  **Go to the Firebase Console:** Navigate to [https://console.firebase.google.com/](https://console.firebase.google.com/) and sign in with your Google account.
2.  **Add a Project:** Click on "**+ Add project**".
3.  **Enter Project Name:** Name your project something descriptive, like `HOMEase-AI`. Firebase will generate a unique Project ID (e.g., `homease-ai-f1a2b`). You can edit this ID, but the default is usually fine.
4.  **Enable Google Analytics:** On the next screen, it's highly recommended to **enable Google Analytics** for this project. It provides invaluable insights into user engagement, event tracking (like AR scan completions), and conversion funnels, which are central to your business model. Select or create a new Analytics account.
5.  **Create Project:** Click "**Create project**". Firebase will provision your resources, which may take a minute.

### **Step 2: Set Up Firebase Services in the Console**

Once your project is created, you'll be taken to the project dashboard. Let's enable the services we need.

#### **A. Enable Authentication**

This service will manage your users (homeowners and contractors).

1.  In the left-hand navigation pane, go to **Build > Authentication**.
2.  Click "**Get started**".
3.  You'll be taken to the "Sign-in method" tab. We'll enable two providers as per your plan:
    *   **Email/Password:** Click on it, toggle the **Enable** switch, and click **Save**.
    *   **Google:** Click on it, toggle the **Enable** switch, select a project support email, and click **Save**.



**Metadata:**
```json
{
  "subtask_id": "firebase_setup",
  "title": "Firebase Project Initialization and Authentication Setup",
  "expertise": "Firebase Specialist"
}
```

### Frontend Developer Specialist

Here is a detailed guide for setting up the Next.js frontend for your HOMEase | AI application.

### **Subtask: Setup Next.js Frontend with UI Framework**

This guide will walk you through initializing a new Next.js project with the App Router and integrating **Shadcn UI**, a highly popular and customizable component library built on **Radix UI** and **Tailwind CSS**. This stack provides a powerful, type-safe, and scalable foundation for your application.

---

### **Step 1: Initialize the Next.js Project**

First, let's create a new Next.js application. Open your terminal and run the following command. We'll name our project `homease-frontend`.

```bash
npx create-next-app@latest homease-frontend
```

You will be prompted with several questions. For the HOMEase project, use these recommended settings:

```text
✔ Would you like to use TypeScript? … No / Yes
// Select: Yes (Crucial for a scalable and maintainable application)

✔ Would you like to use ESLint? … No / Yes
// Select: Yes (For code quality and consistency)

✔ Would you like to use Tailwind CSS? … No / Yes
// Select: Yes (Required for Shadcn UI)

✔ Would you like to use `src/` directory? … No / Yes
// Select: No (We will use the root `app/` directory for simplicity, a common convention)

✔ Would you like to use App Router? (recommended) … No / Yes
// Select: Yes (This is the modern, recommended approach for Next.js)

✔ Would you like to customize the default import alias (@/*)? … No / Yes
// Select: Yes, and set it to `@/*` (This is the standard and works best with Shadcn UI)
// Path alias: @/*
```

After the installation is complete, navigate into your new project directory:

```bash
cd homease-frontend
```

### **Step 2: Integrate Shadcn UI**

Now that the Next.js project is set up, we'll initialize Shadcn UI. This command will configure your project to work with the library and set up necessary files.

Run the following command in your project's root directory:

```bash
npx shadcn-ui@latest init
```

You'll be asked a few configuration questions. The defaults are generally good, but let's confirm them:

```text
✔ Which style would you like to use? › Default
// Select: Default

✔ Which color would you like to use as base color? › Slate
// Select: Slate (You can change this later in globals.css)

✔ Where is your global CSS file? … app/globals.css
// Confirm: app/globals.css

✔ Would you like to use CSS variables for colors? … no / yes
// Select: yes

✔ Where is your tailwind.config.js located? … tailwind.config.ts
// Confirm: tailwind.config.ts

✔ Configure the import alias for components: … @/components
// Confirm: @/components

✔ Configure the import alias for utils: … @/lib/utils
// Confirm: @/lib/utils

✔ Are you using React Server Components? … no / yes
// Select: yes
```

**What did this command do?**

1.  **`components.json`**: Created this file in your project root. It tracks which components you've installed and your configuration choices.
2.  **`tailwind.config.ts`**: Modified this file to include Shadcn's theme settings and animations.
3.  **`app/globals.css`**: Added CSS variables for the color theme you selected (Slate).
4.  **`lib/utils.ts`**: Created this utility file which includes a `cn` function (from `clsx` and `tailwind-merge`) for conditionally applying CSS classes. This is extremely useful.
5.  **Dependencies**: It installed necessary packages like `tailwind-merge`, `class-variance-authority`, and `clsx`.

### **Step 3: Establish the Project Structure**

A well-organized project structure is key to long-term success. Here is a recommended structure for HOMEase | AI:

```
homease-frontend/
├── app/                      # App Router: All routes, pages, and layouts
│   ├── (auth)/               # Route group for authentication pages
│   │   └── login/
│   │       └── page.tsx
│   ├── (main)/               # Route group for main application pages
│   │   ├── dashboard/        # Contractor dashboard
│   │   │   └── page.tsx
│   │   ├── scan/             # The AR scanner page
│   │   │   └── page.tsx
│   │   └── layout.tsx        # Shared layout for the main app (e.g., with header/footer)
│   ├── api/                  # Route handlers (Serverless Functions)
│   ├── favicon.ico
│   ├── globals.css           # Global styles (configured by Shadcn)
│   ├── layout.tsx            # Root layout for the entire application
│   └── page.tsx              # The public homepage
├── components/               # All React components
│   ├── features/             # Complex components for specific features
│   │   ├── ar-scanner/       # Components related to the AR experience
│   │   └── contractor-dashboard/ # Components for the contractor view
│   ├── layout/               # Reusable layout components (Header, Footer, Sidebar)
│   ├── shared/               # Simple, reusable components (Logo, UserAvatar)
│   └── ui/                   # Shadcn UI components will be added here
├── hooks/                    # Custom React hooks (e.g., useUser, useContractors)
├── lib/                      # Helper functions, utilities, and constants
│   ├── firebase/             # Firebase configuration and client SDK setup will go here
│   └── utils.ts              # Utility functions (cn function from Shadcn)
├── public/                   # Static assets (images, icons)
├── types/                    # TypeScript type definitions
├── .eslintrc.json
├── components.json           # Shadcn UI configuration
├── next.config.mjs
├── package.json
├── postcss.config.js
└── tailwind.config.ts
└── tsconfig.json
```

**Action:** Go ahead and create the `components` folder with its subdirectories (`features`, `layout`, `shared`), the `hooks` folder, and the `types` folder. The `components/ui` directory will be created automatically when you add your first Shadcn component.

### **Step 4: Configure the Root Layout**

The root layout (`app/layout.tsx`) is the shell for your entire application. Let's clean it up and prepare it.

Replace the content of `app/layout.tsx` with the following:

```tsx
// app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { cn } from "@/lib/utils";

const fontSans = Inter({
  subsets: ["latin"],
  variable: "--font-sans",
});

export const metadata: Metadata = {
  title: "HOMEase | AI Business Plan",
  description: "AR-driven lead generation for aging-in-place home modifications.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={cn(
          "min-h-screen bg-background font-sans antialiased",
          fontSans.variable
        )}
      >
        {children}
      </body>
    </html>
  );
}
```

This code sets up the `Inter` font (a clean sans-serif font), applies global background and font styles, and sets the page title and description.

### **Step 5: Create a Sample Homepage**

Let's test our setup by adding a few Shadcn components to the homepage.

First, add the `button` and `card` components using the Shadcn CLI:

```bash
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
```

You'll notice that `components/ui/button.tsx` and `components/ui/card.tsx` have been created.

Now, replace the content of your homepage file, `app/page.tsx`, with this code:

```tsx
// app/page.tsx
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { ArrowRight } from "lucide-react";

export default function HomePage() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center bg-slate-50 p-8">
      <div className="w-full max-w-2xl">
        <Card className="text-center">
          <CardHeader>
            <h1 className="text-4xl font-bold tracking-tight">
              Welcome to <span className="text-blue-600">HOMEase | AI</span>
            </h1>
            <CardDescription className="pt-2 text-lg">
              The future of aging-in-place home modifications.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-muted-foreground">
              Our platform uses Augmented Reality to help you visualize safety
              and accessibility upgrades in your home, connecting you with
              trusted, specialized contractors.
            </p>
          </CardContent>
          <CardFooter className="flex justify-center gap-4">
            <Button size="lg">
              Start Your Free Home Scan <ArrowRight className="ml-2 h-4 w-4" />
            </Button>
            <Button size="lg" variant="outline">
              I'm a Contractor
            </Button>
          </CardFooter>
        </Card>
      </div>
    </main>
  );
}
```

We also need to install `lucide-react` for the icons:

```bash
npm install lucide-react
```

### **Step 6: Run the Application**

You are now ready to see your work. Start the development server:

```bash
npm run dev
```

Open your browser and navigate to `http://localhost:3000`. You should see a clean, styled landing page with a card and two buttons, confirming that Next.js, Tailwind CSS, and Shadcn UI are all working together perfectly.



**Metadata:**
```json
{
  "subtask_id": "nextjs_setup",
  "title": "Setup Next.js Frontend with UI Framework",
  "expertise": "Frontend Developer"
}
```

### Backend Developer Specialist

Excellent. With the Firebase project initialized and Authentication services enabled, the next critical step is designing the data structure that will power the entire HOMEase | AI application. A well-designed Firestore schema is essential for scalability, performance, and security.

Here is the detailed Firestore database schema design, tailored to the specific needs outlined in your business plan.

### **Subtask: Firestore Database Schema Design**

This schema is designed around four core collections: `users`, `contractors`, `assessments`, and `leads`. It supports the distinct roles of homeowners and contractors, the storage of AR data, and the transactional nature of the lead generation model.

---

### **1. `users` Collection**

This collection stores information for the **homeowner** user type. The document ID for each user will be their unique Firebase Authentication `uid`.

**Collection Path:** `/users/{userId}`

**Purpose:** Manages homeowner profiles, contact information, and links them to their activities on the platform.

**Data Model:**

```json
{
  // Document ID is the Firebase Auth UID
  "email": "sandra.p@example.com",
  "displayName": "Sandra Peterson",
  "photoURL": "https://lh3.googleusercontent.com/a-/...",
  "role": "homeowner",
  "phoneNumber": "555-123-4567",
  "isCaregiver": true, // Identifies if user is an adult child/caregiver
  "address": {
    "street": "123 Maple Street",
    "city": "Austin",
    "state": "TX",
    "zipCode": "78701"
  },
  "createdAt": "2025-01-15T10:00:00Z", // Firestore Timestamp
  "updatedAt": "2025-01-15T10:00:00Z"  // Firestore Timestamp
}
```

---

### **2. `contractors` Collection**

This collection stores detailed profiles for the **contractor** user type. The document ID will also be their Firebase Authentication `uid`. This model includes fields for the rigorous vetting process and performance tracking mentioned in the business plan.

**Collection Path:** `/contractors/{contractorId}`

**Purpose:** Manages contractor business profiles, service areas, specializations, vetting status, and performance metrics.

**Data Model:**

```json
{
  // Document ID is the Firebase Auth UID
  "email": "contact@reliable-remodeling.com",
  "businessName": "Reliable Remodeling LLC",
  "contactName": "John Doe",
  "role": "contractor",
  "phoneNumber": "512-987-6543",
  "address": {
    "street": "456 Commerce Blvd",
    "city": "Austin",
    "state": "TX",
    "zipCode": "78704"
  },
  "serviceAreas": ["78701", "78704", "78745", "78759"], // Array of zip codes for matching
  "specializations": ["bathroom_remodel", "ramp_installation", "walk_in_shower"],
  "vettingStatus": "approved", // 'pending', 'approved', 'rejected'
  "isCAPSCertified": true, // Key differentiator: Certified Aging-in-Place Specialist
  "licenseNumber": "TX-LIC-12345",
  "insuranceInfo": {
    "liabilityPolicy": "POL-LIAB-9876",
    "workersCompPolicy": "POL-WC-5432",
    "expirationDate": "2026-06-01T00:00:00Z" // Firestore Timestamp
  },
  "performanceMetrics": {
    "averageRating": 4.8,
    "totalJobsCompleted": 12,
    "leadConversionRate": 0.25 // 25%
  },
  "profile": {
    "bio": "Specializing in safe and accessible home modifications for seniors for over 15 years.",
    "portfolioImageUrls": [
      "https://firebasestorage.googleapis.com/v0/b/...",
      "https://firebasestorage.googleapis.com/v0/b/..."
    ]
  },
  "createdAt": "2025-02-01T09:00:00Z" // Firestore Timestamp
}
```

---

### **3. `assessments` Collection**

This collection stores the output from the AR scanning tool. It's the raw data that forms the basis of a high-quality lead.

**Collection Path:** `/assessments/{assessmentId}`

**Purpose:** To store the technical data and visualizations from each AR scan, linking them to a specific homeowner.

**Data Model:**

```json
{
  // Document ID is an auto-generated unique ID
  "homeownerUid": "uid_of_sandra_peterson", // Foreign key to the `users` collection
  "status": "completed", // 'in_progress', 'completed', 'lead_generated'
  "roomType": "bathroom",
  "homeownerNotes": "Main concern is the high step into the tub and slippery floors.",
  "arData": {
    "measurements": {
      "doorwayWidth": 29.5, // inches
      "tubWallHeight": 18, // inches
      "toiletHeight": 15 // inches
    },
    "identifiedIssues": [
      { "type": "narrow_doorway", "severity": "medium" },
      { "type": "trip_hazard", "description": "High tub wall" },
      { "type": "lack_of_support", "description": "No grab bars" }
    ],
    "suggestedModifications": [
      { "type": "walk_in_shower", "estimatedCost": 8000 },
      { "type": "grab_bar_installation", "count": 3, "estimatedCost": 250 },
      { "type": "comfort_height_toilet", "estimatedCost": 400 }
    ]
  },
  // Optional: Use if arData object exceeds 1 MiB Firestore document limit
  "arDataStoragePath": "gs://homease-ai.appspot.com/assessments/assessmentId/scan.json",
  "createdAt": "2025-03-10T14:30:00Z" // Firestore Timestamp
}
```

---

### **4. `leads` Collection**

This is the central transactional collection, representing a homeowner's request being sent to contractors. It tracks the entire lifecycle of a lead, from matching to completion and payment.

**Collection Path:** `/leads/{leadId}`

**Purpose:** To manage the connection between a homeowner's need (from an `assessment`) and the contractors who can service it. This collection directly supports the pay-per-lead revenue model.

**Data Model:**

```json
{
  // Document ID is an auto-generated unique ID
  "assessmentId": "id_of_the_bathroom_assessment", // Foreign key to `assessments`
  "homeownerUid": "uid_of_sandra_peterson", // Foreign key to `users`
  "status": "contacted", // 'new', 'matched', 'contacted', 'quoted', 'won', 'lost'
  "urgency": "within_month", // 'asap', 'within_month', 'planning'
  "budgetRange": "5000-10000",
  "matchedContractors": [
    {
      "contractorUid": "uid_of_john_doe", // Foreign key to `contractors`
      "sentAt": "2025-03-10T15:00:00Z",
      "status": "contacted", // 'sent', 'viewed', 'accepted', 'rejected'
      "paymentStatus": "paid", // 'unpaid', 'paid'
      "price": 40.00 // The cost of this lead for this contractor
    },
    {
      "contractorUid": "uid_of_another_contractor",
      "sentAt": "2025-03-10T15:01:00Z",
      "status": "viewed",
      "paymentStatus": "unpaid",
      "price": 40.00
    }
  ],
  "winningContractorUid": null, // Populated when homeowner accepts a bid
  "homeownerFeedback": {
    "rating": null, // e.g., 5
    "comment": null, // e.g., "John was fantastic..."
    "submittedAt": null
  },
  "createdAt": "2025-03-10T14:45:00Z" // Firestore Timestamp
}
```

This comprehensive schema provides a robust foundation for building all the features described in the HOMEase | AI business plan, from user registration and AR assessments to the core contractor lead marketplace. The next step will be to implement Firestore Security Rules to protect this data.

**Metadata:**
```json
{
  "subtask_id": "firestore_schema",
  "title": "Firestore Database Schema Design",
  "expertise": "Backend Developer"
}
```

### Backend Developer Specialist

Of course. Here is a detailed implementation plan for the core Cloud Functions that will manage user and contractor profiles for your HOMEase | AI application.

This solution uses TypeScript and Express.js to create a clean, maintainable, and scalable API structure within a single Cloud Function, which is a best practice for performance and organization.

---

### **1. Project Setup & File Structure**

First, ensure you have initialized Firebase Functions in your project with TypeScript. If you haven't, run `firebase init functions` in your project root and select TypeScript.

Inside your `functions` directory, create the following file structure:

```
functions/
├── src/
│   ├── api/
│   │   ├── controllers/
│   │   │   └── profile.controller.ts  // Logic for handling profile requests
│   │   ├── middleware/
│   │   │   └── auth.middleware.ts     // Middleware to verify user tokens
│   │   └── routes/
│   │       └── profile.routes.ts      // Defines the API routes
│   ├── models/
│   │   └── profile.models.ts        // TypeScript interfaces for our data
│   └── index.ts                     // Main entry point for all functions
├── package.json
└── tsconfig.json
```

### **2. Install Dependencies**

Navigate to the `functions` directory and install the necessary packages:

```bash
cd functions
npm install express cors
npm install --save-dev @types/express @types/cors
```

### **3. Define Data Models (TypeScript Interfaces)**

These interfaces ensure type safety and align with your Firestore schema.

**File: `src/models/profile.models.ts`**
```typescript
import { Timestamp } from "firebase-admin/firestore";

// Base interface for shared properties
interface BaseProfile {
  uid: string;
  email: string;
  role: 'homeowner' | 'contractor';
  phoneNumber?: string;
  address?: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
  };
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

// Profile for a Homeowner user
export interface HomeownerProfile extends BaseProfile {
  role: 'homeowner';
  displayName: string;
  photoURL?: string;
  isCaregiver?: boolean;
}

// Profile for a Contractor user
export interface ContractorProfile extends BaseProfile {
  role: 'contractor';
  businessName: string;
  contactName: string;
  serviceAreas: string[]; // Array of zip codes
  specializations: string[];
  vettingStatus: 'pending' | 'approved' | 'rejected' | 'needs_info';
  isCAPSCertified: boolean;
  licenseNumber?: string;
  insuranceInfo?: {
    liabilityPolicy: string;
    workersCompPolicy: string;
    expirationDate: Timestamp;
  };
  performanceMetrics: {
    averageRating: number;
    totalJobsCompleted: number;
    leadConversionRate: number;
  };
  profile: {
    bio: string;
    portfolioImageUrls: string[];
  };
}
```

### **4. Create Authentication Middleware**

This middleware will protect your endpoints by verifying the user's Firebase Auth token and attaching their user data to the request object.

**File: `src/api/middleware/auth.middleware.ts`**
```typescript
import { Request, Response, NextFunction } from 'express';
import * as admin from 'firebase-admin';

// Extends the Express Request to include a 'user' property
export interface AuthenticatedRequest extends Request {
  user?: admin.auth.DecodedIdToken;
}

// Middleware to verify the Firebase ID token
export const isAuthenticated = async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
  const { authorization } = req.headers;

  if (!authorization || !authorization.startsWith('Bearer ')) {
    res.status(401).send({ error: 'Unauthorized: No token provided.' });
    return;
  }

  const split = authorization.split('Bearer ');
  if (split.length !== 2) {
    res.status(401).send({ error: 'Unauthorized: Malformed token.' });
    return;
  }
  const token = split[1];

  try {
    const decodedToken: admin.auth.DecodedIdToken = await admin.auth().verifyIdToken(token);
    req.user = decodedToken;
    next();
  } catch (err) {
    console.error(`${err.code} -  ${err.message}`);
    res.status(403).send({ error: 'Forbidden: Invalid token.' });
  }
};

// Middleware to check if the authenticated user is a contractor
export const isContractor = (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (req.user?.role === 'contractor') {
        next();
    } else {
        res.status(403).send({ error: 'Forbidden: User is not a contractor.' });
    }
};
```

### **5. Implement the Controller Logic**

This file contains the core logic for creating, reading, and updating profiles in Firestore.

**File: `src/api/controllers/profile.controller.ts`**
```typescript
import * as admin from 'firebase-admin';
import { Response } from 'express';
import { AuthenticatedRequest } from '../middleware/auth.middleware';
import { ContractorProfile, HomeownerProfile } from '../../models/profile.models';

const db = admin.firestore();

// --- Profile Creation ---
export const createProfile = async (req: AuthenticatedRequest, res: Response) => {
  const { uid, email } = req.user!;
  const { role, ...profileData } = req.body;

  if (!role || (role !== 'homeowner' && role !== 'contractor')) {
    return res.status(400).send({ error: 'A valid role ("homeowner" or "contractor") is required.' });
  }

  try {
    // Set a custom claim for role-based access control
    await admin.auth().setCustomUserClaims(uid, { role });

    if (role === 'homeowner') {
      const newHomeowner: HomeownerProfile = {
        uid,
        email: email!,
        role: 'homeowner',
        displayName: profileData.displayName || 'New User',
        createdAt: admin.firestore.Timestamp.now(),
        updatedAt: admin.firestore.Timestamp.now(),
        ...profileData,
      };
      await db.collection('users').doc(uid).set(newHomeowner);
      return res.status(201).send(newHomeowner);
    }

    if (role === 'contractor') {
      const newContractor: ContractorProfile = {
        uid,
        email: email!,
        role: 'contractor',
        businessName: profileData.businessName || 'New Contractor Business',
        contactName: profileData.contactName || '',
        vettingStatus: 'pending',
        isCAPSCertified: false,
        serviceAreas: [],
        specializations: [],
        performanceMetrics: { averageRating: 0, totalJobsCompleted: 0, leadConversionRate: 0 },
        profile: { bio: '', portfolioImageUrls: [] },
        createdAt: admin.firestore.Timestamp.now(),
        updatedAt: admin.firestore.Timestamp.now(),
        ...profileData,
      };
      await db.collection('contractors').doc(uid).set(newContractor);
      return res.status(201).send(newContractor);
    }
  } catch (error) {
    console.error('Error creating profile:', error);
    return res.status(500).send({ error: 'Something went wrong creating the profile.' });
  }
};


// --- Profile Retrieval ---
export const getMyProfile = async (req: AuthenticatedRequest, res: Response) => {
  const { uid, role } = req.user!;
  const collection = role === 'homeowner' ? 'users' : 'contractors';

  try {
    const doc = await db.collection(collection).doc(uid).get();
    if (!doc.exists) {
      return res.status(404).send({ error: 'Profile not found.' });
    }
    return res.status(200).send(doc.data());
  } catch (error) {
    console.error('Error fetching profile:', error);
    return res.status(500).send({ error: 'Something went wrong fetching the profile.' });
  }
};

// --- Profile Updates ---
export const updateMyProfile = async (req: AuthenticatedRequest, res: Response) => {
    const { uid, role } = req.user!;
    const collection = role === 'homeowner' ? 'users' : 'contractors';
    const dataToUpdate = {
        ...req.body,
        updatedAt: admin.firestore.Timestamp.now(),
    };
    // Prevent critical fields from being updated via this generic endpoint
    delete dataToUpdate.uid;
    delete dataToUpdate.role;
    delete dataToUpdate.email;
    delete dataToUpdate.createdAt;
    delete dataToUpdate.vettingStatus; // Vetting has its own endpoint

    try {
        const docRef = db.collection(collection).doc(uid);
        await docRef.update(dataToUpdate);
        const updatedDoc = await docRef.get();
        return res.status(200).send(updatedDoc.data());
    } catch (error) {
        console.error('Error updating profile:', error);
        return res.status(500).send({ error: 'Something went wrong updating the profile.' });
    }
};

// --- Contractor-Specific Vetting Submission ---
export const submitVettingInfo = async (req: AuthenticatedRequest, res: Response) => {
    const { uid } = req.user!;
    const { licenseNumber, insuranceInfo } = req.body;

    if (!licenseNumber || !insuranceInfo) {
        return res.status(400).send({ error: 'License number and insurance information are required.' });
    }

    const dataToUpdate = {
        licenseNumber,
        insuranceInfo: {
            ...insuranceInfo,
            // Convert date string from client to Firestore Timestamp
            expirationDate: admin.firestore.Timestamp.fromDate(new Date(insuranceInfo.expirationDate))
        },
        vettingStatus: 'pending',
        updatedAt: admin.firestore.Timestamp.now(),
    };

    try {
        const docRef = db.collection('contractors').doc(uid);
        await docRef.update(dataToUpdate);
        return res.status(200).send({ message: 'Vetting information submitted successfully. Your profile is now under review.' });
    } catch (error) {
        console.error('Error submitting vetting info:', error);
        return res.status(500).send({ error: 'Something went wrong submitting vetting info.' });
    }
};
```

### **6. Define the API Routes**

This file connects the HTTP endpoints to their corresponding controller functions and applies the necessary middleware.

**File: `src/api/routes/profile.routes.ts`**
```typescript
import { Router } from 'express';
import { isAuthenticated, isContractor } from '../middleware/auth.middleware';
import { createProfile, getMyProfile, updateMyProfile, submitVettingInfo } from '../controllers/profile.controller';

const router = Router();

// POST /api/profile - Create a new user or contractor profile after signup.
router.post('/profile', isAuthenticated, createProfile);

// GET /api/profile - Get the currently authenticated user's profile.
router.get('/profile', isAuthenticated, getMyProfile);

// PUT /api/profile - Update the currently authenticated user's profile.
router.put('/profile', isAuthenticated, updateMyProfile);

// POST /api/profile/contractor/vetting - For contractors to submit their vetting details.
router.post('/profile/contractor/vetting', [isAuthenticated, isContractor], submitVettingInfo);

export default router;
```

### **7. Tie Everything Together in `index.ts`**

This is the main entry point that initializes the Firebase Admin SDK and sets up the Express app.

**File: `src/index.ts`**
```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import * as express from 'express';
import * as cors from 'cors';

import profileRouter from './api/routes/profile.routes';

// Initialize Firebase Admin SDK
admin.initializeApp();

const app = express();

// Automatically allow cross-origin requests
app.use(cors({ origin: true }));

// Parse JSON bodies
app.use(express.json());

// Mount the profile routes
app.use('/api', profileRouter);

// Expose Express API as a single Cloud Function
export const api = functions.https.onRequest(app);
```

### **8. Deployment**

To deploy these functions to your Firebase project, run the following command from your project's root directory:

```bash
firebase deploy --only functions
```

After deployment, you will get a URL for your API, which will look something like this:
`https://us-central1-your-project-id.cloudfunctions.net/api`

Your endpoints will be available at this base URL (e.g., `.../api/profile`).

### **How to Use These Endpoints from Your Next.js Frontend:**

1.  **User Signs Up:** A user signs up using the Firebase client-side SDK (`createUserWithEmailAndPassword`).
2.  **Create Profile:** Immediately after a successful sign-up, your frontend makes a `POST` request to `/api/profile`.
    *   **Header:** `Authorization: Bearer <firebase_auth_id_token>`
    *   **Body:** `{ "role": "contractor", "businessName": "My Remodeling Co." }`
3.  **Submit Vetting:** A contractor fills out a form with their license and insurance info.
    *   **Request:** `POST` to `/api/profile/contractor/vetting`.
    *   **Header:** `Authorization: Bearer <firebase_auth_id_token>`
    *   **Body:** `{ "licenseNumber": "TX-123", "insuranceInfo": { ... } }`
4.  **Fetch Profile:** To load a user's dashboard, make a `GET` request to `/api/profile`.
    *   **Header:** `Authorization: Bearer <firebase_auth_id_token>`

**Metadata:**
```json
{
  "subtask_id": "core_backend_functions",
  "title": "Create Core Cloud Functions for User & Contractor Profiles",
  "expertise": "Backend Developer"
}
```

### Frontend Developer Specialist

Here is the detailed implementation for the **Frontend Authentication and Profile Management** subtask. This guide provides the necessary code and steps to build the UI and integrate it with your Firebase backend.

### **Prerequisites**

1.  Ensure you have completed the `firebase_setup`, `nextjs_setup`, and `core_backend_functions` subtasks.
2.  Your Next.js project should be set up with Shadcn UI and Tailwind CSS.
3.  Your core backend Cloud Functions (`/api/profile`) should be deployed.

---

### **Step 1: Install Frontend Dependencies**

We'll use `react-hook-form` and `zod` for robust, type-safe form handling and validation.

Open your terminal in the `homease-frontend` directory and run:

```bash
npm install firebase react-hook-form zod @hookform/resolvers
```

Next, add the Shadcn UI components we'll need for our forms and notifications:

```bash
npx shadcn-ui@latest add form input label select toast card-header card-content card-footer card
```

### **Step 2: Configure Firebase Client SDK**

To communicate with Firebase services from the browser, you need to initialize the client SDK.

1.  **Get Firebase Config:**
    *   Go to your Firebase Console.
    *   Click the gear icon > **Project settings**.
    *   Under "Your apps", click the web icon (`</>`) to create a web app configuration if you haven't already.
    *   Name it `homease-webapp` and register the app.
    *   Copy the `firebaseConfig` object.

2.  **Create Environment Variables:**
    Create a file named `.env.local` in the root of your `homease-frontend` project and paste your config values there. This keeps your keys secure.

    **File: `.env.local`**
    ```env
    NEXT_PUBLIC_FIREBASE_API_KEY="AIza..."
    NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="homease-ai-f1a2b.firebaseapp.com"
    NEXT_PUBLIC_FIREBASE_PROJECT_ID="homease-ai-f1a2b"
    NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="homease-ai-f1a2b.appspot.com"
    NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="..."
    NEXT_PUBLIC_FIREBASE_APP_ID="1:..."

    # The URL of your deployed Cloud Functions API
    NEXT_PUBLIC_API_URL="https://us-central1-homease-ai-f1a2b.cloudfunctions.net/api"
    ```

3.  **Create Firebase Client Initializer:**
    Create a file to initialize Firebase on the client side.

    **File: `lib/firebase/client.ts`**
    ```typescript
    import { initializeApp, getApps, getApp } from 'firebase/app';
    import { getAuth } from 'firebase/auth';
    import { getFirestore } from 'firebase/firestore';

    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      messagingSender_id: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    };

    // Initialize Firebase
    const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
    const auth = getAuth(app);
    const db = getFirestore(app);

    export { app, auth, db };
    ```

### **Step 3: Create an Authentication Context and Provider**

A global context is the best way to manage the user's authentication state across the entire application.

1.  **Define Types:**
    First, create a types file for our auth context.

    **File: `types/auth.ts`**
    ```typescript
    import { User } from 'firebase/auth';
    import { HomeownerProfile, ContractorProfile } from './backend'; // We'll create this next

    export interface AuthContextType {
      user: User | null;
      profile: HomeownerProfile | ContractorProfile | null;
      loading: boolean;
      logout: () => Promise<void>;
    }
    ```

    Now, create a file for the backend types we defined in the Cloud Functions subtask. This avoids duplication and ensures consistency.

    **File: `types/backend.ts`**
    ```typescript
    // These types should mirror the ones in your Cloud Function's `profile.models.ts`

    interface BaseProfile {
      uid: string;
      email: string;
      role: 'homeowner' | 'contractor';
      phoneNumber?: string;
      // Use string for dates on the client, as Firestore Timestamps are not serializable
      createdAt: string;
      updatedAt: string;
    }

    export interface HomeownerProfile extends BaseProfile {
      role: 'homeowner';
      displayName: string;
      photoURL?: string;
    }

    export interface ContractorProfile extends BaseProfile {
      role: 'contractor';
      businessName: string;
      contactName: string;
      serviceAreas: string[];
      specializations: string[];
      vettingStatus: 'pending' | 'approved' | 'rejected' | 'needs_info';
      isCAPSCertified: boolean;
      // Add other contractor fields as needed
    }
    ```

2.  **Create the Auth Provider and Hook:**
    This component will listen for auth changes, fetch user profiles, and provide the data to its children.

    **File: `context/AuthContext.tsx`**
    ```tsx
    'use client';

    import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
    import { onAuthStateChanged, User } from 'firebase/auth';
    import { auth } from '@/lib/firebase/client';
    import { AuthContextType } from '@/types/auth';
    import { HomeownerProfile, ContractorProfile } from '@/types/backend';
    import { useRouter, usePathname } from 'next/navigation';

    const AuthContext = createContext<AuthContextType | undefined>(undefined);

    export const AuthProvider = ({ children }: { children: ReactNode }) => {
      const [user, setUser] = useState<User | null>(null);
      const [profile, setProfile] = useState<HomeownerProfile | ContractorProfile | null>(null);
      const [loading, setLoading] = useState(true);
      const router = useRouter();
      const pathname = usePathname();

      useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
          setLoading(true);
          if (user) {
            setUser(user);
            const token = await user.getIdToken();
            try {
              const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/profile`, {
                headers: { Authorization: `Bearer ${token}` },
              });
              if (res.ok) {
                const profileData = await res.json();
                setProfile(profileData);
              } else {
                // Profile might not exist yet if user just signed up
                setProfile(null);
              }
            } catch (error) {
              console.error("Failed to fetch profile:", error);
              setProfile(null);
            }
          } else {
            setUser(null);
            setProfile(null);
          }
          setLoading(false);
        });

        return () => unsubscribe();
      }, []);

      // Route protection
      useEffect(() => {
        if (loading) return; // Don't do anything while loading
        const isAuthPage = pathname === '/login' || pathname === '/register';
        
        // If user is not logged in and tries to access a protected page
        if (!user && !isAuthPage && pathname !== '/') {
            router.push('/login');
        }

        // If user is logged in and tries to access login/register
        if (user && isAuthPage) {
            router.push('/dashboard');
        }
      }, [user, loading, pathname, router]);


      const logout = async () => {
        await auth.signOut();
        router.push('/login');
      };

      const value = { user, profile, loading, logout };

      return (
        <AuthContext.Provider value={value}>
          {children}
        </AuthContext.Provider>
      );
    };

    export const useAuth = (): AuthContextType => {
      const context = useContext(AuthContext);
      if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
      }
      return context;
    };
    ```

3.  **Integrate Provider into Root Layout:**
    Wrap your entire application with the `AuthProvider` to make the context available everywhere. Also, add the `Toaster` for notifications.

    **File: `app/layout.tsx`**
    ```tsx
    // app/layout.tsx
    import type { Metadata } from "next";
    import { Inter } from "next/font/google";
    import "./globals.css";
    import { cn } from "@/lib/utils";
    import { AuthProvider } from "@/context/AuthContext"; // Import AuthProvider
    import { Toaster } from "@/components/ui/toaster"; // Import Toaster

    const fontSans = Inter({
      subsets: ["latin"],
      variable: "--font-sans",
    });

    export const metadata: Metadata = {
      title: "HOMEase | AI Business Plan",
      description: "AR-driven lead generation for aging-in-place home modifications.",
    };

    export default function RootLayout({
      children,
    }: Readonly<{
      children: React.ReactNode;
    }>) {
      return (
        <html lang="en" suppressHydrationWarning>
          <body
            className={cn(
              "min-h-screen bg-background font-sans antialiased",
              fontSans.variable
            )}
          >
            <AuthProvider> {/* Wrap with AuthProvider */}
              {children}
              <Toaster /> {/* Add Toaster component */}
            </AuthProvider>
          </body>
        </html>
      );
    }
    ```

### **Step 4: Build the Registration Page**

Create a form for users to sign up.

**File: `app/register/page.tsx`**
```tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useRouter } from 'next/navigation';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { auth } from '@/lib/firebase/client';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/components/ui/use-toast';
import Link from 'next/link';

const formSchema = z.object({
  email: z.string().email({ message: 'Invalid email address.' }),
  password: z.string().min(6, { message: 'Password must be at least 6 characters.' }),
  role: z.enum(['homeowner', 'contractor'], { required_error: 'You must select a role.' }),
  name: z.string().min(2, { message: 'Name must be at least 2 characters.' }),
});

export default function RegisterPage() {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: { email: '', password: '', name: '' },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true);
    try {
      // 1. Create user in Firebase Auth
      const userCredential = await createUserWithEmailAndPassword(auth, values.email, values.password);
      const user = userCredential.user;

      // 2. Get the ID token
      const token = await user.getIdToken();

      // 3. Create profile in Firestore via our backend
      const profileData = {
        role: values.role,
        ...(values.role === 'homeowner' ? { displayName: values.name } : { businessName: values.name, contactName: '' }),
      };

      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/profile`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(profileData),
      });

      if (!response.ok) {
        throw new Error('Failed to create profile.');
      }

      toast({ title: 'Success!', description: 'Your account has been created.' });
      router.push('/dashboard'); // Redirect to dashboard after successful registration
    } catch (error: any) {
      console.error(error);
      toast({
        title: 'Registration Failed',
        description: error.message || 'An unexpected error occurred.',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-slate-50 p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl">Create an Account</CardTitle>
          <CardDescription>Join HOMEase | AI to get started.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>{form.watch('role') === 'contractor' ? 'Business Name' : 'Full Name'}</FormLabel>
                    <FormControl>
                      <Input placeholder={form.watch('role') === 'contractor' ? 'Your Company LLC' : 'John Doe'} {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input placeholder="you@example.com" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input type="password" placeholder="••••••" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="role"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>I am a...</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select your role" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="homeowner">Homeowner</SelectItem>
                        <SelectItem value="contractor">Contractor</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? 'Creating Account...' : 'Register'}
              </Button>
            </form>
          </Form>
        </CardContent>
        <CardFooter className="flex justify-center">
            <p className="text-sm text-muted-foreground">
                Already have an account?{' '}
                <Link href="/login" className="font-semibold text-primary hover:underline">
                    Log in
                </Link>
            </p>
        </CardFooter>
      </Card>
    </div>
  );
}
```

### **Step 5: Build the Login Page**

Create a similar form for existing users to sign in.

**File: `app/login/page.tsx`**
```tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useRouter } from 'next/navigation';
import { signInWithEmailAndPassword } from 'firebase/auth';
import { auth } from '@/lib/firebase/client';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { useToast } from '@/components/ui/use-toast';
import Link from 'next/link';

const formSchema = z.object({
  email: z.string().email({ message: 'Invalid email address.' }),
  password: z.string().min(1, { message: 'Password is required.' }),
});

export default function LoginPage() {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: { email: '', password: '' },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true);
    try {
      await signInWithEmailAndPassword(auth, values.email, values.password);
      toast({ title: 'Login Successful!', description: 'Welcome back.' });
      router.push('/dashboard');
    } catch (error: any) {
      console.error(error);
      toast({
        title: 'Login Failed',
        description: 'Invalid email or password.',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-slate-50 p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl">Welcome Back</CardTitle>
          <CardDescription>Log in to your HOMEase | AI account.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input placeholder="you@example.com" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input type="password" placeholder="••••••" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? 'Logging in...' : 'Log In'}
              </Button>
            </form>
          </Form>
        </CardContent>
        <CardFooter className="flex justify-center">
            <p className="text-sm text-muted-foreground">
                Don't have an account?{' '}
                <Link href="/register" className="font-semibold text-primary hover:underline">
                    Register
                </Link>
            </p>
        </CardFooter>
      </Card>
    </div>
  );
}
```

### **Step 6: Build a Simple Dashboard and Profile Page**

This will be the main area for logged-in users. We'll add a simple profile display and a logout button.

1.  **Create a Dashboard Layout:**
    This layout can contain a shared header for all dashboard pages.

    **File: `app/dashboard/layout.tsx`**
    ```tsx
    'use client';
    import { useAuth } from '@/context/AuthContext';
    import { Button } from '@/components/ui/button';
    import { LogOut } from 'lucide-react';
    import Link from 'next/link';
    
    export default function DashboardLayout({ children }: { children: React.ReactNode }) {
      const { profile, logout, loading } = useAuth();
    
      if (loading) {
        return <div className="flex h-screen items-center justify-center">Loading...</div>;
      }
    
      return (
        <div className="min-h-screen bg-slate-50">
          <header className="bg-white shadow-sm">
            <nav className="container mx-auto flex h-16 items-center justify-between px-4">
              <Link href="/dashboard" className="text-xl font-bold text-blue-600">
                HOMEase | AI
              </Link>
              <div className="flex items-center gap-4">
                <span className="text-sm text-muted-foreground">
                  Welcome, {profile?.role === 'homeowner' ? profile.displayName : profile?.businessName}
                </span>
                <Button variant="ghost" size="icon" onClick={logout}>
                  <LogOut className="h-5 w-5" />
                </Button>
              </div>
            </nav>
          </header>
          <main className="container mx-auto p-4">{children}</main>
        </div>
      );
    }
    ```

2.  **Create the Main Dashboard Page:**
    This page will welcome the user and show their profile information.

    **File: `app/dashboard/page.tsx`**
    ```tsx
    'use client';

    import { useAuth } from '@/context/AuthContext';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

    export default function DashboardPage() {
      const { profile } = useAuth();

      return (
        <div>
          <h1 className="mb-6 text-3xl font-bold">Dashboard</h1>
          <Card>
            <CardHeader>
              <CardTitle>My Profile</CardTitle>
            </CardHeader>
            <CardContent>
              {profile ? (
                <div className="space-y-2">
                  <p><strong>Email:</strong> {profile.email}</p>
                  <p><strong>Role:</strong> <span className="capitalize">{profile.role}</span></p>
                  {profile.role === 'homeowner' && <p><strong>Name:</strong> {profile.displayName}</p>}
                  {profile.role === 'contractor' && (
                    <>
                      <p><strong>Business Name:</strong> {profile.businessName}</p>
                      <p><strong>Vetting Status:</strong> <span className="capitalize">{profile.vettingStatus}</span></p>
                    </>
                  )}
                </div>
              ) : (
                <p>Loading profile...</p>
              )}
            </CardContent>
          </Card>
        </div>
      );
    }
    ```

You have now successfully implemented a complete authentication and profile management flow on the frontend. Users can register, log in, view their profile data fetched from Firestore, and log out. The system is secure, scalable, and provides a seamless user experience.

**Metadata:**
```json
{
  "subtask_id": "frontend_auth",
  "title": "Implement Frontend Authentication and Profile Management",
  "expertise": "Frontend Developer"
}
```

### Full-Stack Developer Specialist

Here is a detailed plan and implementation for the **Contractor Vetting and Tiering System**. This system consists of secure backend endpoints for admin actions and a protected admin dashboard in the Next.js frontend.

This builds directly upon the `core_backend_functions` by adding admin-specific capabilities.

---

### **Part 1: Backend Enhancements (Firebase Cloud Functions)**

We will add new admin-only endpoints to our Express API to manage contractors.

#### **1. Create Admin Middleware**

First, we need a way to verify that a user has an `admin` role. This is done by checking the custom claims on their ID token.

**File: `functions/src/api/middleware/auth.middleware.ts` (Add this new function)**

```typescript
// ... existing isAuthenticated and isContractor functions

// Middleware to check if the authenticated user is an admin
export const isAdmin = (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    // Check for the admin custom claim set on the user's token
    if (req.user?.admin === true) {
        next();
    } else {
        res.status(403).send({ error: 'Forbidden: User does not have admin privileges.' });
    }
};
```

#### **2. Create Admin Controller Logic**

This file will contain the logic for fetching and updating contractor data, accessible only to admins.

**File: `functions/src/api/controllers/admin.controller.ts` (New File)**

```typescript
import * as admin from 'firebase-admin';
import { Request, Response } from 'express';

const db = admin.firestore();
const contractorsCollection = db.collection('contractors');

// Define Tiers
export const TIERS = ['Bronze', 'Silver', 'Gold', 'Platinum'] as const;
export type ContractorTier = typeof TIERS[number];

// Get a list of all contractors, with filtering by vettingStatus
export const getAllContractors = async (req: Request, res: Response) => {
    const status = req.query.status as string;

    try {
        let query: admin.firestore.Query = contractorsCollection;

        if (status && ['pending', 'approved', 'rejected', 'needs_info'].includes(status)) {
            query = query.where('vettingStatus', '==', status);
        }

        const snapshot = await query.orderBy('createdAt', 'desc').get();
        const contractors = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        return res.status(200).send(contractors);
    } catch (error) {
        console.error('Error fetching contractors:', error);
        return res.status(500).send({ error: 'Failed to fetch contractors.' });
    }
};

// Get a single contractor's full details
export const getContractorById = async (req: Request, res: Response) => {
    const { id } = req.params;
    try {
        const doc = await contractorsCollection.doc(id).get();
        if (!doc.exists) {
            return res.status(404).send({ error: 'Contractor not found.' });
        }
        return res.status(200).send({ id: doc.id, ...doc.data() });
    } catch (error) {
        console.error(`Error fetching contractor ${id}:`, error);
        return res.status(500).send({ error: 'Failed to fetch contractor details.' });
    }
};


// Update a contractor's vetting status and tier
export const updateContractorStatus = async (req: Request, res: Response) => {
    const { id } = req.params;
    const { vettingStatus, tier, rejectionReason } = req.body;

    if (!vettingStatus && !tier) {
        return res.status(400).send({ error: 'vettingStatus or tier is required.' });
    }

    const dataToUpdate: { [key: string]: any } = {
        updatedAt: admin.firestore.Timestamp.now(),
    };

    if (vettingStatus) {
        if (

**Metadata:**
```json
{
  "subtask_id": "contractor_vetting",
  "title": "Develop Contractor Vetting and Tiering System",
  "expertise": "Full-Stack Developer"
}
```

### AR/VR Developer Specialist

Here is a detailed plan for developing the **AR Home Assessment Module**.

### **Executive Summary & Architectural Decision**

The core value of HOMEase | AI lies in its ability to capture accurate, dimensional data of a user's home. The business plan specifies leveraging LiDAR technology for this, which provides the highest fidelity.

After analyzing the available technologies, a **hybrid architecture is the only robust and production-ready solution**.

*   **Why not pure WebXR?** While promising, the WebXR API in modern browsers does **not** provide the low-level access to LiDAR mesh data (`ARMeshAnchor`) that is required for generating accurate floor plans. Relying on it would lead to a subpar product that fails to meet the business plan's core promise.
*   **The Hybrid Solution:** We will build a small, dedicated **native iOS app** using Swift and ARKit to handle the scanning. The main Next.js web application will act as the orchestrator, launching the native app and displaying the results.

This approach gives us the best of both worlds:
1.  **Maximum Power:** Full access to Apple's ARKit and LiDAR sensor for unparalleled accuracy.
2.  **Seamless User Experience:** The user journey starts and ends in the web app, with the native app feeling like an integrated "camera mode."
3.  **Focused Development:** The native app has one job: scan and upload. The Next.js app handles everything else (UI, user management, contractor matching).

The implementation is broken down into three parts:
*   **Part A:** The bridge connecting the Next.js web app to the native iOS app.
*   **Part B:** The native iOS AR Scanner app itself.
*   **Part C:** Integrating the scan results back into the Next.js frontend.

---

### **Part A: The Web-to-Native Bridge**

This part enables the Next.js app to launch the native iOS app with the correct user context.

#### **1. Firestore Data Model for Scans**

First, define the data model for a scan job in Firestore.

**Collection:** `scans`
**Document ID:** (auto-generated)
**Fields:**
*   `uid`: `string` (The homeowner's Firebase Auth UID)
*   `status`: `string` ('pending', 'processing', 'completed', 'failed')
*   `createdAt`: `Timestamp`
*   `completedAt`: `Timestamp` (optional)
*   `scanResultUrl`: `string` (URL to the JSON file in Cloud Storage, optional)
*   `thumbnailUrl`: `string` (URL to a preview image in Cloud Storage, optional)
*   `error`: `string` (optional)

#### **2. Backend: Create a "Create Scan" Cloud Function**

This function creates the initial scan document in Firestore and returns its ID.

**File: `homease-backend/functions/src/scans/scans.controller.ts`**
```typescript
import { https, Response } from 'firebase-functions';
import { db } from '../config/firebase';

// This would be called via POST /api/scans
export const createScan = async (req: https.Request, res: Response) => {
  try {
    // The auth middleware has already verified the user and attached the UID
    const uid = (req as any).user.uid;

    const scanRef = db.collection('scans').doc();
    const scanData = {
      uid,
      status: 'pending',
      createdAt: new Date(),
    };

    await scanRef.set(scanData);

    res.status(201).send({ scanId: scanRef.id });
  } catch (error) {
    console.error("Error creating scan:", error);
    res.status(500).send({ error: 'Failed to create scan job.' });
  }
};
```
*Remember to add the route for this in your main `index.ts` file.*

#### **3. Frontend: The "Start Scan" Component (Next.js)**

This component initiates the process. When a user on an iPhone clicks the button, it calls our backend to create a scan job and then attempts to open the native app via a Universal Link.

**File: `app/dashboard/components/StartScanButton.tsx`**
```tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/context/AuthContext';
import { Button } from '@/components/ui/button';
import { useToast } from '@/components/ui/use-toast';
import { ScanLine } from 'lucide-react';
import { useRouter } from 'next/navigation';

export function StartScanButton() {
  const { user } = useAuth();
  const { toast } = useToast();
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  const handleStartScan = async () => {
    if (!user) return;
    setIsLoading(true);

    try {
      // Step 1: Check if user is on a compatible device (iOS)
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (!isIOS) {
        toast({
          title: 'Device Not Supported',
          description: 'AR scanning is currently only available on LiDAR-equipped iPhones and iPads.',
          variant: 'destructive',
        });
        setIsLoading(false);
        return;
      }

      // Step 2: Get a Firebase Auth ID token
      const token = await user.getIdToken();

      // Step 3: Call the backend to create a new scan document
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/scans`, {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}` },
      });

      if (!response.ok) throw new Error('Could not create scan job.');

      const { scanId } = await response.json();

      // Step 4: Construct the Universal Link and redirect
      // The token is passed to allow the native app to authenticate seamlessly
      const universalLink = `homease://scan?scanId=${scanId}&token=${token}`;
      
      // Redirect to the native app
      window.location.href = universalLink;

      // After a short delay, redirect to the scan results page in the web app.
      // This page will listen for the scan to complete.
      setTimeout(() => {
        router.push(`/dashboard/scans/${scanId}`);
      }, 500);

    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message || 'Could not start scan.',
        variant: 'destructive',
      });
    } finally {
      // Don't set isLoading to false immediately, as we are navigating away
    }
  };

  return (
    <Button onClick={handleStartScan} disabled={isLoading} size="lg">
      <ScanLine className="mr-2 h-5 w-5" />
      {isLoading ? 'Preparing Scan...' : 'Start New Home Scan'}
    </Button>
  );
}
```

#### **4. iOS: Configure Universal Links**

1.  **Associated Domains:** In your Xcode project, go to `Signing & Capabilities` > `+ Capability` and add **Associated Domains**. Add your Firebase Hosting domain in the format `applinks:your-project-id.web.app`.
2.  **Apple App Site Association (AASA) file:** You must host a file named `apple-app-site-association` (with no extension) on your Firebase Hosting site at the root (`/.well-known/apple-app-site-association`). This JSON file tells iOS that your website is associated with your app.

    **File: `homease-frontend/public/.well-known/apple-app-site-association`**
    ```json
    {
      "applinks": {
        "apps": [],
        "details": [
          {
            "appID": "YOUR_TEAM_ID.com.yourcompany.homease",
            "paths": [ "/scans/*" ] // Or a specific path to trigger the app
          }
        ]
      }
    }
    ```
    *You get `YOUR_TEAM_ID` from your Apple Developer account.*

---

### **Part B: The Native iOS AR Scanner App**

This is a simplified but functional guide to building the core scanner.

**Technology:** Swift, SwiftUI, ARKit, RealityKit, Firebase SDK for iOS.

#### **1. Project Setup & Firebase SDK**

*   Create a new Xcode project.
*   Add the Firebase SDK using Swift Package Manager:
    *   `https://github.com/firebase/firebase-ios-sdk`
    *   Add packages: `FirebaseAuth`, `FirebaseFirestore`, `FirebaseStorage`.
*   Add a `GoogleService-Info.plist` file from your Firebase project settings.
*   In your `Info.plist`, add the `Privacy - Camera Usage Description` key.

#### **2. Handling the Universal Link**

In your main `App` struct, use the `.onOpenURL` modifier to catch the incoming link and start the scan.

**File: `HomeaseApp.swift`**
```swift
import SwiftUI
import FirebaseCore

class AppDelegate: NSObject, UIApplicationDelegate {
  func application(_ application: UIApplication,
                   didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    FirebaseApp.configure()
    return true
  }
}

@main
struct HomeaseApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .onOpenURL { url in
                    // Handle the incoming URL here
                    // e.g., parse scanId and token
                    // Then navigate to the ARScanView
                }
        }
    }
}
```

#### **3. The AR View (Core Logic)**

We use `RealityKit`'s `ARView` because it simplifies mesh generation.

**File: `ARScanView.swift`**
```swift
import SwiftUI
import RealityKit
import ARKit
import FirebaseStorage
import FirebaseFirestore
import FirebaseAuth

struct ARScanView: View {
    var scanId: String
    var authToken: String
    @State private var isSaving = false

    var body: some View {
        ZStack(alignment: .bottom) {
            ARViewContainer(scanId: scanId, authToken: authToken, isSaving: $isSaving)
                .edgesIgnoringSafeArea(.all)

            if isSaving {
                ProgressView("Saving Scan...")
                    .padding()
                    .background(Color.black.opacity(0.5))
                    .cornerRadius(10)
                    .foregroundColor(.white)
            }
        }
    }
}

struct ARViewContainer: UIViewRepresentable {
    var scanId: String
    var authToken: String
    @Binding var isSaving: Bool
    
    func makeUIView(context: Context) -> ARView {
        let arView = ARView(frame: .zero)
        
        // Configure the session for LiDAR scanning
        let config = ARWorldTrackingConfiguration()
        config.sceneReconstruction = .mesh
        config.planeDetection = [.horizontal, .vertical]
        
        // For debugging: show mesh, feature points, etc.
        arView.debugOptions = [.showSceneUnderstanding, .showFeaturePoints]
        
        arView.session.run(config)
        
        // Add a "Done" button to the view coordinator
        context.coordinator.arView = arView
        let doneButton = UIButton(type: .system)
        doneButton.setTitle("Done", for: .normal)
        doneButton.backgroundColor = .blue
        doneButton.setTitleColor(.white, for: .normal)
        doneButton.layer.cornerRadius = 10
        doneButton.addTarget(context.coordinator, action: #selector(Coordinator.handleDoneTapped), for: .touchUpInside)
        
        arView.addSubview(doneButton)
        // Layout button constraints...
        
        return arView
    }
    
    func updateUIView(_ uiView: ARView, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    // Coordinator to handle UI events and AR session logic
    class Coordinator: NSObject {
        var parent: ARViewContainer
        weak var arView: ARView?

        init(_ parent: ARViewContainer) {
            self.parent = parent
        }

        @objc func handleDoneTapped() {
            guard let arView = arView else { return }
            parent.isSaving = true
            
            // 1. Get all mesh anchors from the current session
            guard let frame = arView.session.currentFrame else { return }
            let meshAnchors = frame.anchors.compactMap { $0 as? ARMeshAnchor }
            
            // 2. Process anchors into a serializable format (our JSON structure)
            let scanResult = processMeshAnchors(meshAnchors)
            
            // 3. Convert to JSON data
            guard let jsonData = try? JSONEncoder().encode(scanResult) else {
                print("Failed to encode JSON")
                parent.isSaving = false
                return
            }
            
            // 4. Authenticate with Firebase using the token
            Auth.auth().signIn(withCustomToken: parent.authToken) { authResult, error in
                guard let user = authResult?.user, error == nil else {
                    print("Firebase Auth failed: \(error?.localizedDescription ?? "Unknown error")")
                    self.parent.isSaving = false
                    return
                }

                // 5. Upload JSON to Firebase Storage
                let storageRef = Storage.storage().reference().child("scans/\(user.uid)/\(self.parent.scanId)/data.json")
                storageRef.putData(jsonData, metadata: nil) { metadata, error in
                    guard error == nil else {
                        print("Upload failed: \(error!.localizedDescription)")
                        self.parent.isSaving = false
                        return
                    }
                    
                    // 6. Update Firestore document with completion status
                    let db = Firestore.firestore()
                    db.collection("scans").document(self.parent.scanId).updateData([
                        "status": "completed",
                        "completedAt": FieldValue.serverTimestamp(),
                        "scanResultUrl": "gs://\(storageRef.bucket)/\(storageRef.fullPath)"
                    ]) { err in
                        if let err = err {
                            print("Error updating document: \(err)")
                        } else {
                            print("Scan saved successfully!")
                            // Could close the app or show a success message
                        }
                        self.parent.isSaving = false
                    }
                }
            }
        }
    }
}
```

#### **4. Data Processing & JSON Structure**

The `processMeshAnchors` function is where the magic happens. A full implementation is complex, but here's the concept and the output structure.

**File: `ScanProcessor.swift`**
```swift
// This would be a separate file for processing logic

struct ScanResult: Codable {
    let floorplan: [Point] // A 2D polygon of the main floor
    let walls: [[Point]] // An array of wall lines
    let mesh: MeshData // The raw 3D mesh for later rendering
    // Add other identified features like doors, windows
}

struct Point: Codable {
    let x, y, z: Float
}

struct MeshData: Codable {
    let vertices: [Point]
    let faces: [[Int]] // Each sub-array is a triangle of vertex indices
}

func processMeshAnchors(_ anchors: [ARMeshAnchor]) -> ScanResult {
    // This is a highly complex Computer Vision task.
    // A simplified approach:
    // 1. Combine all vertices and faces from all anchors into one big mesh.
    // 2. Identify the largest, flattest horizontal surface near y=0 (the floor).
    // 3. Extract the boundary of this surface to create the `floorplan` polygon.
    // 4. Identify large vertical surfaces (walls).
    // 5. Return the full, simplified mesh in `mesh`.
    
    // For now, we'll just package the raw data
    var allVertices: [Point] = []
    var allFaces: [[Int]] = []
    
    for anchor in anchors {
        // ... logic to get vertices and faces from anchor.geometry ...
    }
    
    return ScanResult(
        floorplan: [], // Placeholder
        walls: [], // Placeholder
        mesh: MeshData(vertices: allVertices, faces: allFaces)
    )
}
```

---

### **Part C: Displaying Results in the Frontend**

Now, the user is redirected back to the Next.js app to see their scan results.

#### **1. Create the Scan Results Page**

This page listens to the Firestore document in real-time.

**File: `app/dashboard/scans/[scanId]/page.tsx`**
```tsx
'use client';

import { useEffect, useState } from 'react';
import { useAuth } from '@/context/AuthContext';
import { doc, onSnapshot } from 'firebase/firestore';
import { db } from '@/lib/firebase/client';
import { getStorage, ref, getDownloadURL } from 'firebase/storage';

// A simple component to render the 2D floorplan
const FloorplanRenderer = ({ data }: { data: any }) => {
    // In a real app, use a library like D3.js or an SVG canvas
    return (
        <div className="p-4 border rounded-lg bg-gray-50">
            <h3 className="font-semibold mb-2">Scan Data (JSON)</h3>
            <pre className="text-xs bg-gray-900 text-white p-4 rounded-md overflow-x-auto">
                {JSON.stringify(data, null, 2)}
            </pre>
        </div>
    );
};


export default function ScanResultPage({ params }: { params: { scanId: string } }) {
  const { user } = useAuth();
  const [scanData, setScanData] = useState<any | null>(null);
  const [scanStatus, setScanStatus] = useState('loading');
  const [scanResult, setScanResult] = useState<any | null>(null);

  useEffect(() => {
    if (!user) return;

    const docRef = doc(db, 'scans', params.scanId);
    const unsubscribe = onSnapshot(docRef, async (docSnap) => {
      if (docSnap.exists()) {
        const data = docSnap.data();
        setScanData(data);
        setScanStatus(data.status);

        if (data.status === 'completed' && data.scanResultUrl) {
          try {
            const storage = getStorage();
            // Note: scanResultUrl is a gs:// path. We need to get the download URL.
            const url = await getDownloadURL(ref(storage, data.scanResultUrl));
            const response = await fetch(url);
            const jsonData = await response.json();
            setScanResult(jsonData);
          } catch (error) {
            console.error("Failed to fetch scan result JSON:", error);
            setScanStatus('failed');
          }
        }
      } else {
        setScanStatus('not_found');
      }
    });

    return () => unsubscribe();
  }, [user, params.scanId]);

  return (
    <div>
      <h1 className="text-3xl font-bold mb-2">Scan Results</h1>
      <p className="text-muted-foreground mb-6">Scan ID: {params.scanId}</p>

      {scanStatus === 'loading' && <p>Loading scan status...</p>}
      {scanStatus === 'pending' && <p>Scan in progress. Please complete the scan on your iPhone/iPad.</p>}
      {scanStatus === 'completed' && scanResult && (
        <div>
          <p className="text-green-600 font-bold mb-4">Scan Completed Successfully!</p>
          <FloorplanRenderer data={scanResult} />
        </div>
      )}
      {scanStatus === 'failed' && <p className="text-red-600 font-bold">Scan failed. Please try again.</p>}
      {scanStatus === 'not_found' && <p className="text-red-600 font-bold">Scan not found.</p>}
    </div>
  );
}
```

This completes the end-to-end flow for the AR Home Assessment module, providing a technically sound and powerful foundation for the HOMEase | AI platform.

**Metadata:**
```json
{
  "subtask_id": "ar_module",
  "title": "Build AR Home Assessment Module",
  "expertise": "AR/VR Developer"
}
```

### Backend Developer Specialist

Of course. Here is a detailed implementation for the backend Cloud Function that processes the AR scan data, analyzes it for aging-in-place needs, and generates a detailed assessment report.

This function will be triggered when a scan's status is updated to `completed` in Firestore. It will then fetch the raw scan data from Cloud Storage, apply a rule-based analysis engine, and store the results in a new `assessments` collection.

---

### **1. Update Project Structure & Data Models**

First, let's add the necessary files and update our data models to include the new `Assessment` and `ScanResult` structures.

**New File Structure:**
```
functions/
├── src/
│   ├── api/
│   ├── models/
│   │   ├── profile.models.ts
│   │   └── assessment.models.ts  // <-- NEW FILE
│   ├── processing/
│   │   ├── assessment.logic.ts   // <-- NEW FILE (The "AI" rules engine)
│   │   └── assessment.controller.ts// <-- NEW FILE (The Cloud Function trigger)
│   └── index.ts
├── ...
```

**File: `src/models/assessment.models.ts`**
```typescript
import { Timestamp } from "firebase-admin/firestore";

// --- Input Model (from the AR Scan App) ---
// This defines the structure of the JSON file in Cloud Storage.
// We assume the native app does some pre-processing to identify features.
export interface Point {
    x: number;
    y: number;
    z: number;
}

export interface ArchitecturalFeature {
    id: string;
    type: 'doorway' | 'window' | 'stairs' | 'toilet' | 'shower_curb';
    centerPoint: Point;
    dimensions: {
        width?: number; // in inches
        height?: number; // in inches
        depth?: number; // in inches
    };
    room: string; // e.g., 'bathroom_1', 'main_entry'
}

export interface RawScanResult {
    uid: string;
    scanId: string;
    floorplanPolygon: Point[];
    walls: { start: Point; end: Point }[];
    features: ArchitecturalFeature[];
}


// --- Output Model (The Assessment Report) ---
// This is the structure of the document we will save to the 'assessments' collection.
export interface IdentifiedNeed {
    needId: string;
    category: 'Entryway' | 'Bathroom' | 'Kitchen' | 'Hallway' | 'General Accessibility';
    type: 'DoorwayWidth' | 'GrabBar' | 'Ramp' | 'CurblessShower' | 'CounterHeight' | 'Lighting';
    severity: 'Critical' | 'Recommended' | 'Informational';
    description: string;
    location: Point;
    suggestedModification: string;
    estimatedCostRange: {
        min: number;
        max: number;
    };
    featureId: string; // The ID of the feature from the raw scan that triggered this need
}

export interface Assessment {
    uid: string;
    scanId: string;
    createdAt: Timestamp;
    status: 'completed' | 'failed';
    summary: {
        critical: number;
        recommended: number;
        informational: number;
        total: number;
    };
    identifiedNeeds: IdentifiedNeed[];
    rawScanDataUrl: string; // gs:// path to the original JSON
}
```

### **2. The "AI" Analysis Engine**

This file contains the core rule-based logic for identifying AIP needs. It's designed to be modular so you can easily add more rules or replace it with a true machine-learning model later.

**File: `src/processing/assessment.logic.ts`**
```typescript
import { RawScanResult, IdentifiedNeed, Point } from "../models/assessment.models";
import { v4 as uuidv4 } from 'uuid';

// --- Configuration & Constants ---
const ADA_DOORWAY_WIDTH_INCHES = 32;
const ADA_HALLWAY_WIDTH_INCHES = 36; // Example for future use

// --- Cost Estimation Lookup Table ---
// Based on the business plan's "Common Aging-in-Place Home Modifications" table
const modificationCosts = {
    WidenDoor: { min: 200, max: 7000 },
    InstallRamp: { min: 875, max: 3000 },
    InstallGrabBars: { min: 90, max: 300 },
    CurblessShower: { min: 2500, max: 9000 },
};

// --- Rule Functions ---

/**
 * Checks all doorways for ADA compliance.
 */
function checkDoorwayWidths(scanData: RawScanResult): IdentifiedNeed[] {
    const needs: IdentifiedNeed[] = [];
    const doorways = scanData.features.filter(f => f.type === 'doorway');

    for (const door of doorways) {
        if (door.dimensions.width && door.dimensions.width < ADA_DOORWAY_WIDTH_INCHES) {
            needs.push({
                needId: uuidv4(),
                category: 'General Accessibility',
                type: 'DoorwayWidth',
                severity: 'Critical',
                description: `Doorway in ${door.room.replace('_', ' ')} is ${door.dimensions.width.toFixed(1)}" wide, which is less than the recommended ${ADA_DOORWAY_WIDTH_INCHES}" for accessibility.`,
                location: door.centerPoint,
                suggestedModification: 'Widen doorway to at least 32" clear width.',
                estimatedCostRange: modificationCosts.WidenDoor,
                featureId: door.id,
            });
        }
    }
    return needs;
}

/**
 * Recommends grab bars near toilets and in showers.
 */
function checkForGrabBarNeeds(scanData: RawScanResult): IdentifiedNeed[] {
    const needs: IdentifiedNeed[] = [];
    const toilets = scanData.features.filter(f => f.type === 'toilet');
    const showers = scanData.features.filter(f => f.type === 'shower_curb');

    for (const toilet of toilets) {
         needs.push({
            needId: uuidv4(),
            category: 'Bathroom',
            type: 'GrabBar',
            severity: 'Recommended',
            description: `No grab bars detected near the toilet in ${toilet.room.replace('_', ' ')}. Installing grab bars enhances safety and stability.`,
            location: toilet.centerPoint,
            suggestedModification: 'Install ADA-compliant grab bars on adjacent walls.',
            estimatedCostRange: modificationCosts.InstallGrabBars,
            featureId: toilet.id,
        });
    }
    // Add similar logic for showers
    return needs;
}

/**
 * Identifies entry steps and recommends a ramp.
 */
function checkEntrywayForRamp(scanData: RawScanResult): IdentifiedNeed[] {
    const needs: IdentifiedNeed[] = [];
    const stairs = scanData.features.filter(f => f.type === 'stairs' && f.room === 'main_entry');

    for (const stair of stairs) {
        needs.push({
            needId: uuidv4(),
            category: 'Entryways & Outdoors',
            type: 'Ramp',
            severity: 'Critical',
            description: `Stairs detected at the main entry, creating an accessibility barrier.`,
            location: stair.centerPoint,
            suggestedModification: 'Install a ramp with a compliant slope (1:12 ratio).',
            estimatedCostRange: modificationCosts.InstallRamp,
            featureId: stair.id,
        });
    }
    return needs;
}

/**
 * Identifies shower curbs and recommends a curbless/roll-in shower.
 */
function checkShowerCurbs(scanData: RawScanResult): IdentifiedNeed[] {
    const needs: IdentifiedNeed[] = [];
    const showerCurbs = scanData.features.filter(f => f.type === 'shower_curb');

    for (const curb of showerCurbs) {
        needs.push({
            needId: uuidv4(),
            category: 'Bathroom',
            type: 'CurblessShower',
            severity: 'Recommended',
            description: `A shower curb in ${curb.room.replace('_', ' ')} was identified, which can be a significant trip hazard.`,
            location: curb.centerPoint,
            suggestedModification: 'Convert to a curbless or roll-in shower for safe, easy access.',
            estimatedCostRange: modificationCosts.CurblessShower,
            featureId: curb.id,
        });
    }
    return needs;
}


// --- Main Analysis Function ---

export function analyzeScanForAipNeeds(scanData: RawScanResult): IdentifiedNeed[] {
    console.log("Starting AIP needs analysis...");

    const allNeeds: IdentifiedNeed[] = [
        ...checkDoorwayWidths(scanData),
        ...checkForGrabBarNeeds(scanData),
        ...checkEntrywayForRamp(scanData),
        ...checkShowerCurbs(scanData),
        // Add more rule function calls here as they are developed
    ];

    console.log(`Analysis complete. Found ${allNeeds.length} potential needs.`);
    return allNeeds;
}
```

### **3. The Cloud Function Controller & Trigger**

This file contains the Firestore trigger that orchestrates the entire process.

**File: `src/processing/assessment.controller.ts`**
```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { analyzeScanForAipNeeds } from './assessment.logic';
import { RawScanResult, Assessment, IdentifiedNeed } from '../models/assessment.models';

const db = admin.firestore();
const storage = admin.storage();

export const processArScan = functions.firestore
    .document('scans/{scanId}')
    .onUpdate(async (change, context) => {
        const scanId = context.params.scanId;
        const newData = change.after.data();
        const oldData = change.before.data();

        // --- Trigger Condition ---
        // Only run if status changed from something else to 'completed'
        if (newData.status !== 'completed' || oldData.status === 'completed') {
            return null;
        }
        
        console.log(`Processing scanId: ${scanId}`);
        const scanResultUrl = newData.scanResultUrl; // gs://<bucket>/scans/<uid>/<scanId>/data.json
        
        if (!scanResultUrl) {
            console.error(`Scan ${scanId} is 'completed' but has no scanResultUrl.`);
            await db.collection('scans').doc(scanId).update({ status: 'processing_failed', error: 'Missing scanResultUrl.' });
            return null;
        }

        try {
            // 1. Download the raw scan data from Cloud Storage
            const bucket = storage.bucket();
            const filePath = scanResultUrl.substring(scanResultUrl.indexOf('/', 5) + 1); // Remove gs://<bucket>/
            const file = bucket.file(filePath);
            const [data] = await file.download();
            const rawScanData: RawScanResult = JSON.parse(data.toString());

            // 2. Run the analysis engine
            const identifiedNeeds = analyzeScanForAipNeeds(rawScanData);

            // 3. Create the assessment report document
            const summary = identifiedNeeds.reduce((acc, need) => {
                if (need.severity === 'Critical') acc.critical++;
                if (need.severity === 'Recommended') acc.recommended++;
                if (need.severity === 'Informational') acc.informational++;
                acc.total++;
                return acc;
            }, { critical: 0, recommended: 0, informational: 0, total: 0 });

            const assessment: Assessment = {
                uid: newData.uid,
                scanId: scanId,
                createdAt: admin.firestore.Timestamp.now(),
                status: 'completed',
                summary,
                identifiedNeeds,
                rawScanDataUrl: scanResultUrl,
            };

            // 4. Save the new assessment to Firestore
            await db.collection('assessments').doc(scanId).set(assessment);

            // 5. Update the original scan document to prevent re-processing
            await db.collection('scans').doc(scanId).update({
                status: 'processed',
                assessmentId: scanId,
            });

            console.log(`Successfully processed and created assessment for scan ${scanId}.`);
            return null;

        } catch (error) {
            console.error(`Failed to process scan ${scanId}:`, error);
            await db.collection('scans').doc(scanId).update({
                status: 'processing_failed',
                error: error.message,
            });
            return null;
        }
    });

```

### **4. Update `index.ts` to Export the New Function**

Finally, make sure your new function is exported so Firebase knows to deploy it.

**File: `src/index.ts`**
```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import * as express from 'express';
import * as cors from 'cors';
import { v4 as uuidv4 } from 'uuid'; // <-- Make sure uuid is installed

// Import routers and controllers
import profileRouter from './api/routes/profile.routes';
import { processArScan } from './processing/assessment.controller'; // <-- IMPORT

// Initialize Firebase Admin SDK
admin.initializeApp();

// --- API ---
const app = express();
app.use(cors({ origin: true }));
app.use(express.json());
app.use('/api', profileRouter);
// ... add other routers as needed ...

export const api = functions.https.onRequest(app);

// --- Background Triggers ---
export const processARScanOnCompletion = processArScan; // <-- EXPORT
```

### **5. Deployment**

1.  Make sure you have `uuid` installed in your `functions` directory:
    ```bash
    cd functions
    npm install uuid
    npm install --save-dev @types/uuid
    ```
2.  Deploy the function:
    ```bash
    firebase deploy --only functions
    ```

Now, whenever a scan document in your Firestore `scans` collection is updated with `status: 'completed'`, this function will automatically trigger, perform the analysis, and generate a rich, actionable assessment report for the homeowner and, eventually, for the contractors.

**Metadata:**
```json
{
  "subtask_id": "process_ar_data",
  "title": "Develop Backend for AR Data Processing",
  "expertise": "Backend Developer"
}
```

### Backend Developer Specialist

Of course. Here is the detailed implementation for creating `Lead` documents and matching them with qualified contractors using Cloud Functions.

This implementation involves two chained Cloud Functions:
1.  **`createLeadFromAssessment`**: Triggers when a new assessment is created, preparing a `Lead` document.
2.  **`matchLeadToContractors`**: Triggers when a new lead is created, finding and assigning suitable contractors.

---

### **1. Update Project Structure & Data Models**

First, let's introduce the necessary files and data models for leads, assignments, and contractor profiles.

**New File Structure:**
```
functions/
├── src/
│   ├── api/
│   ├── models/
│   │   ├── profile.models.ts       // <-- UPDATE
│   │   ├── assessment.models.ts
│   │   └── lead.models.ts          // <-- NEW FILE
│   ├── processing/
│   │   └── assessment.controller.ts
│   ├── matching/
│   │   ├── matching.logic.ts       // <-- NEW FILE (The matching algorithm)
│   │   └── matching.controller.ts  // <-- NEW FILE (The Cloud Function triggers)
│   └── index.ts
├── ...
```

**File: `src/models/profile.models.ts` (Updated)**

Add the required fields to the `ContractorProfile` to enable matching.

```typescript
import { Timestamp } from "firebase-admin/firestore";

// ... (UserProfile remains the same)

export type ContractorSpecialty = 
    'Bathroom Modifications' | 
    'Kitchen Modifications' | 
    'Ramp Installation' | 
    'Doorway Widening' | 
    'Grab Bar Installation' |
    'Stairlift Installation' |
    'Smart Home Integration';

export interface ContractorProfile {
    uid: string;
    email: string;
    companyName: string;
    contactName: string;
    phone: string;
    website?: string;
    serviceAreas: { // For geographic matching
        states: string[]; // e.g., ['TX', 'FL']
        zipCodes: string[];
    };
    specialties: ContractorSpecialty[]; // For skill-based matching
    isVerified: boolean;
    status: 'active' | 'inactive' | 'pending_verification';
    performanceTier: 'top_tier' | 'standard' | 'new'; // For prioritizing leads
    capsCertified: boolean; // Certified Aging-in-Place Specialist
    createdAt: Timestamp;
    updatedAt: Timestamp;
}
```

**File: `src/models/lead.models.ts` (New)**

```typescript
import { Timestamp } from "firebase-admin/firestore";

export interface Lead {
    leadId: string; // Same as assessmentId
    uid: string; // Homeowner's UID
    assessmentId: string;
    createdAt: Timestamp;
    status: 'new' | 'matching' | 'matched' | 'in_progress' | 'closed';
    location: {
        city: string;
        state: string;
        zip: string;
    };
    projectSummary: {
        categories: string[]; // e.g., ['Bathroom', 'Entryways & Outdoors']
        criticalNeedsCount: number;
        totalNeedsCount: number;
    };
    matchedContractorCount: number;
}

// This will live in a subcollection: /leads/{leadId}/assignments/{contractorId}
export interface LeadAssignment {
    contractorId: string;
    homeownerId: string;
    leadId: string;
    assignedAt: Timestamp;
    status: 'pending' | 'viewed' | 'accepted' | 'rejected' | 'contacted';
    // Denormalized data for easier display on contractor dashboard
    contractorInfo: {
        companyName: string;
        contactName: string;
        performanceTier: string;
    };
}
```

### **2. The Contractor Matching Algorithm**

This file contains the core logic for finding the best contractors for a given lead. It filters based on location, skills, and performance.

**File: `src/matching/matching.logic.ts` (New)**

```typescript
import { ContractorProfile, ContractorSpecialty } from "../models/profile.models";
import { Lead } from "../models/lead.models";
import * as admin from 'firebase-admin';

const db = admin.firestore();

// Maps broad assessment categories to specific contractor specialties
const categoryToSpecialtyMap: { [key: string]: ContractorSpecialty[] } = {
    'Bathroom': ['Bathroom Modifications', 'Grab Bar Installation'],
    'Entryways & Outdoors': ['Ramp Installation', 'Doorway Widening'],
    'Kitchens': ['Kitchen Modifications'],
    'General Accessibility': ['Doorway Widening', 'Stairlift Installation', 'Smart Home Integration'],
};

/**
 * Finds the best-matching contractors for a given lead.
 * @param lead The lead object containing project details.
 * @param limit The maximum number of contractors to return.
 * @returns A promise that resolves to an array of matched ContractorProfile objects.
 */
export async function findMatchingContractors(lead: Lead, limit = 5): Promise<ContractorProfile[]> {
    console.log(`Starting contractor search for lead ${lead.leadId} in ${lead.location.state}`);

    // 1. Get all active and verified contractors
    const contractorsSnapshot = await db.collection('contractorProfiles')
        .where('status', '==', 'active')
        .where('isVerified', '==', true)
        .where('serviceAreas.states', 'array-contains', lead.location.state)
        .get();

    if (contractorsSnapshot.empty) {
        console.log(`No active contractors found for state: ${lead.location.state}`);
        return [];
    }

    const allContractors = contractorsSnapshot.docs.map(doc => doc.data() as ContractorProfile);

    // 2. Determine required specialties from the lead
    const requiredSpecialties = new Set<ContractorSpecialty>();
    lead.projectSummary.categories.forEach(category => {
        const specialties = categoryToSpecialtyMap[category];
        if (specialties) {
            specialties.forEach(spec => requiredSpecialties.add(spec));
        }
    });

    // 3. Filter contractors by specialty
    const qualifiedContractors = allContractors.filter(contractor => 
        contractor.specialties.some(specialty => requiredSpecialties.has(specialty))
    );

    if (qualifiedContractors.length === 0) {
        console.log(`No contractors with required specialties for lead ${lead.leadId}`);
        return [];
    }
    
    // 4. Score and sort the qualified contractors
    const tierScores = { 'top_tier': 3, 'standard': 2, 'new': 1 };

    qualifiedContractors.sort((a, b) => {
        const scoreA = tierScores[a.performanceTier] ?? 0;
        const scoreB = tierScores[b.performanceTier] ?? 0;
        
        // Sort by tier first (descending), then by CAPS certification (true comes first)
        if (scoreB !== scoreA) {
            return scoreB - scoreA;
        }
        return (b.capsCertified ? 1 : 0) - (a.capsCertified ? 1 : 0);
    });

    console.log(`Found ${qualifiedContractors.length} qualified contractors. Returning top ${limit}.`);
    
    // 5. Return the top N matches
    return qualifiedContractors.slice(0, limit);
}
```

### **3. The Cloud Function Controllers & Triggers**

This file defines the two Firestore triggers that automate the lead creation and matching process.

**File: `src/matching/matching.controller.ts` (New)**

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { Assessment } from '../models/assessment.models';
import { Lead, LeadAssignment } from '../models/lead.models';
import { UserProfile } from '../models/profile.models';
import { findMatchingContractors } from './matching.logic';

const db = admin.firestore();

/**
 * Triggered when a new assessment is created.
 * Creates a corresponding Lead document to kick off the matching process.
 */
export const createLeadFromAssessment = functions.firestore
    .document('assessments/{assessmentId}')
    .onCreate(async (snap, context) => {
        const assessment = snap.data() as Assessment;
        const assessmentId = context.params.assessmentId;
        console.log(`New assessment ${assessmentId} created, generating lead...`);

        try {
            // 1. Get homeowner's profile for location info
            const userProfileSnap = await db.collection('userProfiles').doc(assessment.uid).get();
            if (!userProfileSnap.exists) {
                throw new Error(`UserProfile not found for uid: ${assessment.uid}`);
            }
            const userProfile = userProfileSnap.data() as UserProfile;

            // 2. Extract unique categories from the assessment
            const categories = [...new Set(assessment.identifiedNeeds.map(need => need.category))];

            // 3. Create the new Lead document
            const newLead: Lead = {
                leadId: assessmentId,
                uid: assessment.uid,
                assessmentId: assessmentId,
                createdAt: admin.firestore.Timestamp.now(),
                status: 'new', // The next function will pick this up
                location: userProfile.location,
                projectSummary: {
                    categories,
                    criticalNeedsCount: assessment.summary.critical,
                    totalNeedsCount: assessment.summary.total,
                },
                matchedContractorCount: 0,
            };

            await db.collection('leads').doc(assessmentId).set(newLead);
            console.log(`Successfully created lead ${assessmentId}.`);
            return null;
        } catch (error) {
            console.error(`Error creating lead for assessment ${assessmentId}:`, error);
            // Optionally update assessment status to 'lead_failed'
            return null;
        }
    });

/**
 * Triggered when a new lead is created.
 * Finds matching contractors and creates assignments for them.
 */
export const matchLeadToContractors = functions.firestore
    .document('leads/{leadId}')
    .onCreate(async (snap, context) => {
        const lead = snap.data() as Lead;
        const leadId = context.params.leadId;
        console.log(`New lead ${leadId} received, starting matching process...`);

        try {
            // 1. Find the best contractors for this lead
            const matchedContractors = await findMatchingContractors(lead);

            if (matchedContractors.length === 0) {
                console.warn(`No contractors found for lead ${leadId}.`);
                await db.collection('leads').doc(leadId).update({ status: 'closed', notes: 'No matching contractors found.' });
                return null;
            }

            // 2. Create a batch write to create all assignments atomically
            const batch = db.batch();
            matchedContractors.forEach(contractor => {
                const assignmentRef = db.collection('leads').doc(leadId).collection('assignments').doc(contractor.uid);
                
                const newAssignment: LeadAssignment = {
                    contractorId: contractor.uid,
                    homeownerId: lead.uid,
                    leadId: leadId,
                    assignedAt: admin.firestore.Timestamp.now(),
                    status: 'pending',
                    contractorInfo: {
                        companyName: contractor.companyName,
                        contactName: contractor.contactName,
                        performanceTier: contractor.performanceTier,
                    },
                };
                batch.set(assignmentRef, newAssignment);
            });

            // 3. Update the lead's status and count
            const leadRef = db.collection('leads').doc(leadId);
            batch.update(leadRef, {
                status: 'matched',
                matchedContractorCount: matchedContractors.length,
            });

            // 4. Commit the batch
            await batch.commit();

            console.log(`Successfully matched lead ${leadId} to ${matchedContractors.length} contractors.`);
            // TODO: In a future step, trigger notifications to these contractors.

            return null;
        } catch (error) {
            console.error(`Error matching contractors for lead ${leadId}:`, error);
            await db.collection('leads').doc(leadId).update({ status: 'closed', notes: `Matching failed: ${error.message}` });
            return null;
        }
    });
```

### **4. Update `index.ts` to Export New Functions**

Finally, export the new functions so Firebase can deploy them.

**File: `src/index.ts`**
```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import * as express from 'express';
import * as cors from 'cors';

// Import routers and controllers
import profileRouter from './api/routes/profile.routes';
import { processArScan } from './processing/assessment.controller';
import { createLeadFromAssessment, matchLeadToContractors } from './matching/matching.controller'; // <-- IMPORT

// Initialize Firebase Admin SDK
admin.initializeApp();

// --- API ---
const app = express();
app.use(cors({ origin: true }));
app.use(express.json());
app.use('/api', profileRouter);

export const api = functions.https.onRequest(app);

// --- Background Triggers ---
export const processARScanOnCompletion = processArScan;
export const onAssessmentCreate = createLeadFromAssessment; // <-- EXPORT
export const onLeadCreate = matchLeadToContractors;       // <-- EXPORT
```

### **5. Deployment**

Deploy your updated functions to Firebase:

```bash
firebase deploy --only functions
```

With this setup, the entire process from assessment completion to contractor assignment is fully automated. When an AR scan is processed and an `assessment` document is created, it will automatically generate a `lead`, which in turn triggers the matching algorithm to find and assign the most suitable contractors for the job.

**Metadata:**
```json
{
  "subtask_id": "lead_matching",
  "title": "Implement Lead Creation and Contractor Matching Logic",
  "expertise": "Backend Developer"
}
```

### Backend Developer Specialist

Of course. Here is the detailed implementation for a notification system that alerts contractors about new leads via both push notifications (FCM) and email (SendGrid).

This system will be triggered whenever a new `LeadAssignment` is created, ensuring contractors are notified instantly.

### 1. Prerequisite: Set up the "Trigger Email" Firebase Extension

For email notifications, the most robust and maintainable method is to use the official Firebase Extension for SendGrid.

**Follow these steps in your Firebase Console:**

1.  **Navigate to Extensions**: In the "Build" section of the left-hand menu, click on **Extensions**.
2.  **Install New Extension**: Click "Install" on the **Trigger Email** extension.
3.  **Configuration - Step 1**:
    *   Acknowledge the billing and IAM roles that will be created.
4.  **Configuration - Step 2**:
    *   **Cloud Functions location**: Choose the same location as your other functions (e.g., `us-central1`).
    *   **SendGrid API Key**: Create an API key in your [SendGrid account](https://app.sendgrid.com/settings/api_keys) with "Full Access" permissions. Paste the key into the `SendGrid API Key` field.
    *   **Email documents collection**: This is the crucial part. Set this to `mail`. Our function will write documents to this collection to trigger emails.
    *   **Default FROM address**: Enter a verified sender email from your SendGrid account (e.g., `noreply@homease.ai`).
    *   **Default REPLY-TO address**: (Optional) You can set a reply-to address.
5.  **Install Extension**: Click the "Install extension" button. It will take a few minutes to provision the necessary resources.

Once installed, any document added to the `mail` collection will automatically be processed and sent as an email via SendGrid.

### 2. Update Project Structure & Data Models

We need a place to store the contractor's device tokens for push notifications and a new controller for the notification logic.

**Updated File Structure:**
```
functions/
├── src/
│   ├── api/
│   ├── models/
│   │   ├── profile.models.ts       // <-- UPDATE
│   │   ├── assessment.models.ts
│   │   └── lead.models.ts
│   ├── processing/
│   ├── matching/
│   ├── notifications/                // <-- NEW FOLDER
│   │   ├── notification.logic.ts   // <-- NEW FILE
│   │   └── notification.controller.ts// <-- NEW FILE
│   └── index.ts                      // <-- UPDATE
├── ...
```

**File: `src/models/profile.models.ts` (Updated)**

Add the `fcmTokens` array to the `ContractorProfile` interface. This will be updated by the frontend whenever a contractor logs in.

```typescript
import { Timestamp } from "firebase-admin/firestore";

// ... (UserProfile remains the same)
// ... (ContractorSpecialty remains the same)

export interface ContractorProfile {
    uid: string;
    email: string;
    companyName: string;
    // ... other fields
    status: 'active' | 'inactive' | 'pending_verification';
    performanceTier: 'top_tier' | 'standard' | 'new';
    capsCertified: boolean;
    fcmTokens: string[]; // For push notifications. Can have multiple tokens for different devices.
    createdAt: Timestamp;
    updatedAt: Timestamp;
}
```

### 3. Implement Notification Logic

This file will contain the reusable functions for sending FCM push notifications and queuing emails.

**File: `src/notifications/notification.logic.ts` (New)**

```typescript
import * as admin from 'firebase-admin';
import { ContractorProfile } from '../models/profile.models';

const db = admin.firestore();
const messaging = admin.messaging();

/**
 * Sends a push notification to a contractor's devices.
 * @param contractor The contractor's profile object.
 * @param title The title of the notification.
 * @param body The body message of the notification.
 * @param leadId The ID of the lead to link to.
 */
export async function sendFcmNotification(contractor: ContractorProfile, title: string, body: string, leadId: string): Promise<void> {
    if (!contractor.fcmTokens || contractor.fcmTokens.length === 0) {
        console.log(`No FCM tokens found for contractor ${contractor.uid}. Skipping push notification.`);
        return;
    }

    const payload: admin.messaging.MessagingPayload = {
        notification: {
            title,
            body,
            icon: 'https://your-domain.com/favicon.ico', // Optional: URL to your logo
            clickAction: `https://your-app-url/dashboard/leads/${leadId}` // Deep link
        },
        data: {
            leadId,
            link: `https://your-app-url/dashboard/leads/${leadId}`
        }
    };

    try {
        const response = await messaging.sendToDevice(contractor.fcmTokens, payload);
        console.log(`Successfully sent FCM message to contractor ${contractor.uid}.`);
        
        // Clean up stale tokens
        const tokensToRemove: string[] = [];
        response.results.forEach((result, index) => {
            const error = result.error;
            if (error) {
                console.error(`Failure sending notification to token ${contractor.fcmTokens[index]}`, error);
                if (error.code === 'messaging/invalid-registration-token' || error.code === 'messaging/registration-token-not-registered') {
                    tokensToRemove.push(contractor.fcmTokens[index]);
                }
            }
        });

        if (tokensToRemove.length > 0) {
            console.log(`Removing ${tokensToRemove.length} stale tokens for contractor ${contractor.uid}`);
            await db.collection('contractorProfiles').doc(contractor.uid).update({
                fcmTokens: admin.firestore.FieldValue.arrayRemove(...tokensToRemove)
            });
        }
    } catch (error) {
        console.error('Error sending FCM message:', error);
    }
}

/**
 * Queues an email to be sent by the Trigger Email extension.
 * @param contractorEmail The recipient's email address.
 * @param templateData The dynamic data for the SendGrid template.
 */
export async function sendEmailNotification(contractorEmail: string, templateData: object): Promise<void> {
    try {
        await db.collection('mail').add({
            to: [contractorEmail],
            template: {
                name: 'newLeadAlert', // This should match the name of your SendGrid Dynamic Template
                data: templateData,
            },
        });
        console.log(`Successfully queued email for ${contractorEmail}`);
    } catch (error) {
        console.error('Error queuing email for SendGrid:', error);
    }
}
```

### 4. Create the Cloud Function Trigger

This function will be triggered upon the creation of a `LeadAssignment` and will orchestrate the sending of notifications.

**File: `src/notifications/notification.controller.ts` (New)**

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { LeadAssignment } from '../models/lead.models';
import { ContractorProfile } from '../models/profile.models';
import { Lead } from '../models/lead.models';
import { sendFcmNotification, sendEmailNotification } from './notification.logic';

const db = admin.firestore();

/**
 * Triggered when a new lead assignment is created.
 * Sends a push notification and an email to the matched contractor.
 */
export const sendNotificationOnLeadAssignment = functions.firestore
    .document('leads/{leadId}/assignments/{contractorId}')
    .onCreate(async (snap, context) => {
        const { leadId, contractorId } = context.params;
        const assignment = snap.data() as LeadAssignment;

        console.log(`New assignment for lead ${leadId} to contractor ${contractorId}. Preparing notifications.`);

        try {
            // 1. Fetch the contractor's profile for FCM tokens and email
            const contractorSnap = await db.collection('contractorProfiles').doc(contractorId).get();
            if (!contractorSnap.exists) {
                throw new Error(`Contractor profile ${contractorId} not found.`);
            }
            const contractor = contractorSnap.data() as ContractorProfile;

            // 2. Fetch the lead details for notification content
            const leadSnap = await db.collection('leads').doc(leadId).get();
            if (!leadSnap.exists) {
                throw new Error(`Lead document ${leadId} not found.`);
            }
            const lead = leadSnap.data() as Lead;

            // 3. Construct Notification Content
            const title = `New Lead in ${lead.location.city}, ${lead.location.state}!`;
            const body = `A homeowner needs help with: ${lead.projectSummary.categories.join(', ')}.`;
            const leadUrl = `https://your-app-url/dashboard/leads/${leadId}`;

            // 4. Send FCM Push Notification
            await sendFcmNotification(contractor, title, body, leadId);

            // 5. Send Email Notification via SendGrid Extension
            const emailTemplateData = {
                contractorName: contractor.contactName,
                leadLocation: `${lead.location.city}, ${lead.location.state}`,
                projectSummary: lead.projectSummary.categories.join(', '),
                criticalNeeds: lead.projectSummary.criticalNeedsCount,
                leadUrl: leadUrl,
                companyName: contractor.companyName
            };
            await sendEmailNotification(contractor.email, emailTemplateData);

            return null;

        } catch (error) {
            console.error(`Failed to send notifications for assignment on lead ${leadId} to contractor ${contractorId}:`, error);
            return null;
        }
    });

```

### 5. Update `index.ts` to Export the New Function

**File: `src/index.ts` (Updated)**

```typescript
// ... other imports
import { createLeadFromAssessment, matchLeadToContractors } from './matching/matching.controller';
import { sendNotificationOnLeadAssignment } from './notifications/notification.controller'; // <-- IMPORT

// ... admin.initializeApp() and api setup

// --- Background Triggers ---
export const processARScanOnCompletion = processArScan;
export const onAssessmentCreate = createLeadFromAssessment;
export const onLeadCreate = matchLeadToContractors;
export const onLeadAssignment = sendNotificationOnLeadAssignment; // <-- EXPORT
```

### 6. Frontend Responsibility (Next.js)

The backend is now ready. The final piece is for the frontend to request notification permission from the contractor and save the resulting FCM token to their profile.

Here's a conceptual example of how this would be done in your Next.js app:

```javascript
// In a component that runs after a contractor logs in

import { getMessaging, getToken } from "firebase/messaging";
import { doc, updateDoc, arrayUnion } from "firebase/firestore";
import { firebaseApp, firestore, auth } from '../lib/firebase'; // Your firebase config

const requestNotificationPermission = async () => {
    try {
        const messaging = getMessaging(firebaseApp);
        
        // You need a firebase-messaging-sw.js file in your /public directory
        const currentToken = await getToken(messaging, { 
            vapidKey: 'YOUR_FIREBASE_CLOUD_MESSAGING_VAPID_KEY' 
        });

        if (currentToken) {
            console.log('FCM Token:', currentToken);
            // Save the token to the contractor's profile in Firestore
            const contractorId = auth.currentUser.uid;
            const contractorRef = doc(firestore, 'contractorProfiles', contractorId);
            
            await updateDoc(contractorRef, {
                // Use arrayUnion to avoid adding duplicate tokens
                fcmTokens: arrayUnion(currentToken)
            });
            console.log('Token saved to profile.');
        } else {
            console.log('No registration token available. Request permission to generate one.');
        }
    } catch (error) {
        console.error('An error occurred while retrieving token. ', error);
    }
}
```

### 7. Deployment

Deploy the new and updated functions to Firebase:

```bash
firebase deploy --only functions
```

With this complete setup, every time the matching function assigns a lead to a contractor, that contractor will receive an immediate push notification on their device and a detailed email in their inbox, dramatically reducing response times and improving engagement.

**Metadata:**
```json
{
  "subtask_id": "notification_system",
  "title": "Create Lead Notification System for Contractors",
  "expertise": "Backend Developer"
}
```

### Full-Stack Developer Specialist

Of course. Here is a detailed plan and implementation for the in-app communication tool, allowing secure, real-time messaging between homeowners and contractors using Firebase.

This implementation includes:
1.  **Data Models** for chats and messages.
2.  **A Cloud Function Trigger** to keep chat metadata updated.
3.  **An HTTPS Callable Function** to securely initiate new chat sessions.
4.  **Firestore Security Rules** to protect conversations.
5.  **Frontend Implementation Guide** for Next.js.

---

### **1. Update Project Structure & Data Models**

First, let's create the necessary files and data models for the chat feature.

**New/Updated File Structure:**
```
functions/
├── src/
│   ├── api/
│   │   └── routes/
│   │       ├── profile.routes.ts
│   │       └── chat.routes.ts          // <-- NEW FILE
│   ├── models/
│   │   ├── profile.models.ts
│   │   ├── assessment.models.ts
│   │   ├── lead.models.ts
│   │   └── chat.models.ts              // <-- NEW FILE
│   ├── processing/
│   ├── matching/
│   ├── chat/                           // <-- NEW FOLDER
│   │   └── chat.controller.ts          // <-- NEW FILE
│   └── index.ts
├── ...
```

**File: `src/models/chat.models.ts` (New)**

This file defines the structure for conversations and individual messages.

```typescript
import { Timestamp } from "firebase-admin/firestore";

// Stored in the top-level 'chats' collection
export interface Chat {
    chatId: string;
    leadId: string;
    participants: string[]; // [homeownerId, contractorId]
    participantInfo: {
        [uid: string]: {
            name: string;
            role: 'homeowner' | 'contractor';
            companyName?: string; // For contractors
        }
    };
    createdAt: Timestamp;
    updatedAt: Timestamp;
    lastMessage: {
        text: string;
        timestamp: Timestamp;
        senderId: string;
    } | null;
}

// Stored in the subcollection 'chats/{chatId}/messages'
export interface Message {
    messageId: string;
    chatId: string;
    senderId: string;
    text: string;
    timestamp: Timestamp;
    isRead: boolean;
}
```

### **2. Backend Logic: Controllers & Triggers**

This file contains the core logic for initiating chats and updating them when new messages are sent.

**File: `src/chat/chat.controller.ts` (New)**

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { Chat, Message } from '../models/chat.models';
import { LeadAssignment } from '../models/lead.models';
import { UserProfile, ContractorProfile } from '../models/profile.models';

const db = admin.firestore();

/**
 * HTTPS Callable function to initiate a chat between a homeowner and a contractor.
 * Ensures that a valid lead assignment exists before creating the chat.
 */
export const initiateChat = functions.https.onCall(async (data, context) => {
    const { leadId, contractorId, homeownerId } = data;

    // 1. Authentication & Validation
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'You must be logged in to start a chat.');
    }
    if (!leadId || !contractorId || !homeownerId) {
        throw new functions.https.HttpsError('invalid-argument', 'Missing required data: leadId, contractorId, homeownerId.');
    }

    const callerUid = context.auth.uid;
    if (callerUid !== contractorId && callerUid !== homeownerId) {
        throw new functions.https.HttpsError('permission-denied', 'You are not a participant in this lead.');
    }

    // 2. Verify a valid lead assignment exists
    const assignmentRef = db.collection('leads').doc(leadId).collection('assignments').doc(contractorId);
    const assignmentDoc = await assignmentRef.get();

    if (!assignmentDoc.exists || (assignmentDoc.data() as LeadAssignment).homeownerId !== homeownerId) {
        throw new functions.https.HttpsError('not-found', 'A valid lead assignment does not exist for these participants.');
    }

    // 3. Check if a chat already exists to prevent duplicates
    const chatsRef = db.collection('chats');
    const existingChatQuery = await chatsRef
        .where('leadId', '==', leadId)
        .where('participants', 'array-contains', contractorId)
        .get();
    
    // Additional client-side filtering as Firestore doesn't support multiple array-contains on the same field
    const existingChat = existingChatQuery.docs.find(doc => doc.data().participants.includes(homeownerId));

    if (existingChat) {
        console.log(`Chat already exists for lead ${leadId}. Returning existing chatId: ${existingChat.id}`);
        return { chatId: existingChat.id };
    }

    // 4. Create the new chat document if none exists
    console.log(`Creating new chat for lead ${leadId}...`);
    const chatRef = chatsRef.doc(); // Generate a new unique ID

    const homeownerProfile = (await db.collection('userProfiles').doc(homeownerId).get()).data() as UserProfile;
    const contractorProfile = (await db.collection('contractorProfiles').doc(contractorId).get()).data() as ContractorProfile;

    const newChat: Chat = {
        chatId: chatRef.id,
        leadId,
        participants: [homeownerId, contractorId],
        participantInfo: {
            [homeownerId]: { name: homeownerProfile.name, role: 'homeowner' },
            [contractorId]: { name: contractorProfile.contactName, role: 'contractor', companyName: contractorProfile.companyName },
        },
        createdAt: admin.firestore.Timestamp.now(),
        updatedAt: admin.firestore.Timestamp.now(),
        lastMessage: null,
    };

    await chatRef.set(newChat);
    console.log(`Successfully created new chat with id: ${chatRef.id}`);
    return { chatId: chatRef.id };
});


/**
 * Firestore Trigger that updates the parent chat document's metadata
 * whenever a new message is added to its 'messages' subcollection.
 */
export const updateChatOnNewMessage = functions.firestore
    .document('chats/{chatId}/messages/{messageId}')
    .onCreate(async (snap, context) => {
        const message = snap.data() as Message;
        const chatId = context.params.chatId;

        const chatRef = db.collection('chats').doc(chatId);

        console.log(`New message in chat ${chatId}. Updating lastMessage metadata.`);

        try {
            await chatRef.update({
                updatedAt: message.timestamp,
                lastMessage: {
                    text: message.text,
                    timestamp: message.timestamp,
                    senderId: message.senderId,
                },
            });
            console.log(`Successfully updated metadata for chat ${chatId}.`);
            return null;
        } catch (error) {
            console.error(`Failed to update chat metadata for ${chatId}:`, error);
            return null;
        }
    });
```

### **3. Update API Router & Main `index.ts`**

Now, expose the `initiateChat` function through the API structure for consistency, even though it's a callable function.

**File: `src/api/routes/chat.routes.ts` (New)**

```typescript
// This file is more of a placeholder to keep the project structure consistent.
// Callable functions are exported directly from index.ts.
// We document its existence here for clarity.

/**
 * @route   POST /api/chat/initiate
 * @desc    Initiates a chat session (Handled by a Callable Function)
 * @access  Private (Authenticated Homeowner or Contractor)
 * @body    { leadId: string, contractorId: string, homeownerId: string }
 */

// No router export needed as it's a callable function.
```

**File: `src/index.ts` (Updated)**

Export the new callable and trigger functions.

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import * as express from 'express';
import * as cors from 'cors';

// Import routers and controllers
import profileRouter from './api/routes/profile.routes';
import { processArScan } from './processing/assessment.controller';
import { createLeadFromAssessment, matchLeadToContractors } from './matching/matching.controller';
import { initiateChat, updateChatOnNewMessage } from './chat/chat.controller'; // <-- IMPORT

// Initialize Firebase Admin SDK
admin.initializeApp();

// --- API ---
const app = express();
app.use(cors({ origin: true }));
app.use(express.json());
app.use('/api', profileRouter);

export const api = functions.https.onRequest(app);

// --- Callable Functions ---
export const startChat = initiateChat; // <-- EXPORT

// --- Background Triggers ---
export const processARScanOnCompletion = processArScan;
export const onAssessmentCreate = createLeadFromAssessment;
export const onLeadCreate = matchLeadToContractors;
export const onNewMessage = updateChatOnNewMessage; // <-- EXPORT
```

### **4. Firestore Security Rules**

These rules are crucial for ensuring that only authorized participants can access chat data. Add these to your `firestore.rules` file.

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ... other rules for profiles, assessments, leads ...

    // --- CHAT RULES ---
    match /chats/{chatId} {
      // Helper function to check if the user is a participant
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }

      // Allow read only to participants of the chat
      allow read: if isParticipant();

      // Allow create only if the caller is one of the participants being added.
      // Deeper validation is handled in the 'initiateChat' cloud function.
      allow create: if request.auth.uid in request.resource.data.participants;

      // Only allow updating the lastMessage via the cloud function trigger.
      // Direct client updates are denied.
      allow update: if false;
      allow delete: if false;

      // --- MESSAGES SUBCOLLECTION RULES ---
      match /messages/{messageId} {
        // Allow read only to participants of the parent chat
        allow read: if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);

        // Allow create if the user is a participant and the senderId is their own UID.
        allow create: if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid])
                      && request.resource.data.senderId == request.auth.uid;

        // Do not allow updates or deletes to preserve chat history.
        allow update, delete: if false;
      }
    }
  }
}
```

### **5. Frontend Implementation Guide (Next.js & React)**

Here’s how you would build the frontend components to use this backend functionality.

**1. Firebase SDK Setup (Client-side)**

Ensure you have a file to initialize Firebase on the client and export the necessary services.

`lib/firebase.ts`
```typescript
import { initializeApp, getApps } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getFunctions, httpsCallable } from 'firebase/functions';

const firebaseConfig = { /* your client-side firebase config */ };

const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];

export const auth = getAuth(app);
export const db = getFirestore(app);
export const functions = getFunctions(app);

// Typed callable function for initiating a chat
export const initiateChatCallable = httpsCallable<{ leadId: string; contractorId: string; homeownerId: string }, { chatId: string }>(functions, 'startChat');
```

**2. Chat Components**

**a. `useChat.ts` (Custom Hook)**
A hook to manage fetching chats and sending messages.

```typescript
import { useState, useEffect } from 'react';
import { db, auth } from '../lib/firebase';
import { collection, query, where, onSnapshot, orderBy, addDoc, serverTimestamp, doc } from 'firebase/firestore';
import { Chat, Message } from '../models/chat.models'; // Assuming you have these models client-side

export function useChatList() {
    const [chats, setChats] = useState<Chat[]>([]);
    const [loading, setLoading] = useState(true);
    const user = auth.currentUser;

    useEffect(() => {
        if (!user) return;
        
        const q = query(
            collection(db, 'chats'),
            where('participants', 'array-contains', user.uid),
            orderBy('updatedAt', 'desc')
        );

        const unsubscribe = onSnapshot(q, (querySnapshot) => {
            const chatsData = querySnapshot.docs.map(doc => ({ ...doc.data(), chatId: doc.id }) as Chat);
            setChats(chatsData);
            setLoading(false);
        });

        return () => unsubscribe();
    }, [user]);

    return { chats, loading };
}

export function useMessages(chatId: string) {
    const [messages, setMessages] = useState<Message[]>([]);
    
    useEffect(() => {
        if (!chatId) return;

        const q = query(collection(db, `chats/${chatId}/messages`), orderBy('timestamp', 'asc'));

        const unsubscribe = onSnapshot(q, (querySnapshot) => {
            const messagesData = querySnapshot.docs.map(doc => doc.data() as Message);
            setMessages(messagesData);
        });

        return () => unsubscribe();
    }, [chatId]);

    const sendMessage = async (text: string) => {
        if (!text.trim() || !auth.currentUser) return;
        
        await addDoc(collection(db, `chats/${chatId}/messages`), {
            text,
            chatId,
            senderId: auth.currentUser.uid,
            timestamp: serverTimestamp(),
            isRead: false
        });
    };

    return { messages, sendMessage };
}
```

**b. `ChatWindow.tsx` (Component)**
The main UI for a single conversation.

```tsx
import React, { useState } from 'react';
import { useMessages } from '../hooks/useChat';
import { auth } from '../lib/firebase';

interface ChatWindowProps {
    chatId: string;
}

export const ChatWindow: React.FC<ChatWindowProps> = ({ chatId }) => {
    const { messages, sendMessage } = useMessages(chatId);
    const [newMessage, setNewMessage] = useState('');
    const currentUser = auth.currentUser;

    const handleSend = (e: React.FormEvent) => {
        e.preventDefault();
        sendMessage(newMessage);
        setNewMessage('');
    };

    return (
        <div className="flex flex-col h-full">
            <div className="flex-grow p-4 overflow-y-auto">
                {messages.map((msg, index) => (
                    <div key={index} className={`flex ${msg.senderId === currentUser?.uid ? 'justify-end' : 'justify-start'} mb-2`}>
                        <div className={`rounded-lg px-4 py-2 ${msg.senderId === currentUser?.uid ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
                            {msg.text}
                        </div>
                    </div>
                ))}
            </div>
            <form onSubmit={handleSend} className="p-4 border-t">
                <input
                    type="text"
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    placeholder="Type a message..."
                    className="w-full px-3 py-2 border rounded-full"
                />
            </form>
        </div>
    );
};
```

**c. "Contact" Button Logic**
This logic would exist on a Lead Details page.

```tsx
import { initiateChatCallable } from '../lib/firebase';
import { useRouter } from 'next/router';

// Inside your component...
const router = useRouter();

const handleContactContractor = async (leadId: string, contractorId: string, homeownerId: string) => {
    try {
        const result = await initiateChatCallable({ leadId, contractorId, homeownerId });
        const { chatId } = result.data;
        // Navigate to the chat page
        router.push(`/dashboard/chat/${chatId}`);
    } catch (error) {
        console.error("Error starting chat:", error);
        // Handle error with a toast notification
    }
};
```

### **6. Deployment**

Deploy your updated functions and rules to Firebase:

```bash
firebase deploy --only functions,firestore:rules
```

This completes the implementation of a robust, secure, and real-time messaging system, fully integrated into the HOMEase | AI platform.

**Metadata:**
```json
{
  "subtask_id": "communication_tool",
  "title": "Build In-App Communication Tool",
  "expertise": "Full-Stack Developer"
}
```

### Results Integrator

Of course. Based on your comprehensive business plan for HOMEase | AI, here is a detailed technical implementation plan to build the platform using a Next.js frontend, Firebase Hosting, and a Firebase Cloud Functions backend.

This plan synthesizes the necessary steps, from initial setup to deploying a full-featured application, providing a clear roadmap for your development team.

---

### **Phase 1: Backend Foundation & Setup**

This phase establishes the core infrastructure for your application on Firebase.

#### **Step 1: Firebase Project Initialization**

First, create and configure your Firebase project, which will serve as the central hub for your backend services.

1.  **Create the Project:**
    *   Navigate to the [Firebase Console](https://console.firebase.google.com/).
    *   Click **+ Add project**, name it `HOMEase-AI`, and enable **Google Analytics** when prompted. Analytics is crucial for tracking user funnels and conversions, which are central to your business model.

2.  **Enable Core Services:**
    *   **Authentication:** In the console, go to **Build > Authentication** and click "Get started". Enable the **Email/Password** and **Google** sign-in providers. These will be used for both homeowner and contractor accounts.
    *   **Firestore Database:** Go to **Build > Firestore Database** and create a new database. Start in **test mode** for initial development (this allows open access), but we will secure it with rules later. Select a server location close to your target market (e.g., `us-central`).
    *   **Cloud Functions & Hosting:** These will be initialized via the command line in the next steps.

#### **Step 2: Firestore Database Schema Design**

A well-designed schema is critical for performance and scalability. Here are the core data models for your Firestore database.

*   **`/users/{userId}`** (For Homeowners)
    *   Stores homeowner profiles. The document ID is their Firebase Auth `uid`.
    ```json
    {
      "email": "sandra.p@example.com",
      "displayName": "Sandra Peterson",
      "role": "homeowner",
      "address": { "city": "Austin", "state": "TX", "zipCode": "78701" },
      "createdAt": "2025-01-15T10:00:00Z"
    }
    ```

*   **`/contractors/{contractorId}`**
    *   Stores contractor profiles, including vetting and performance data. The document ID is their Firebase Auth `uid`.
    ```json
    {
      "email": "contact@reliable-remodeling.com",
      "businessName": "Reliable Remodeling LLC",
      "role": "contractor",
      "serviceAreas": ["78701", "78704"],
      "specializations": ["bathroom_remodel", "ramp_installation"],
      "vettingStatus": "approved", // 'pending', 'approved', 'rejected'
      "isCAPSCertified": true,
      "performanceTier": "Gold", // 'Bronze', 'Silver', 'Gold', 'Platinum'
      "fcmTokens": ["token1", "token2"], // For push notifications
      "createdAt": "2025-02-01T09:00:00Z"
    }
    ```

*   **`/assessments/{assessmentId}`**
    *   Stores the processed results from the AR scan analysis.
    ```json
    {
      "homeownerUid": "user_uid_here",
      "scanId": "original_scan_id",
      "status": "completed",
      "summary": { "critical": 1, "recommended": 2, "total": 3 },
      "identifiedNeeds": [
        {
          "needId": "uuid_here",
          "category": "General Accessibility",
          "type": "DoorwayWidth",
          "severity": "Critical",
          "description": "Doorway is 29.5\" wide, less than the recommended 32\".",
          "suggestedModification": "Widen doorway.",
          "estimatedCostRange": { "min": 200, "max": 7000 }
        }
      ],
      "createdAt": "2025-03-10T14:30:00Z"
    }
    ```

*   **`/leads/{leadId}`**
    *   The central transactional collection for the marketplace. The `leadId` will be the same as the `assessmentId`.
    ```json
    {
      "homeownerUid": "user_uid_here",
      "assessmentId": "assessment_id_here",
      "status": "matched", // 'new', 'matched', 'contacted', 'won', 'lost'
      "matchedContractors": [
        {
          "contractorUid": "contractor_uid_here",
          "status": "contacted",
          "paymentStatus": "paid",
          "price": 40.00
        }
      ],
      "createdAt": "2025-03-10T14:45:00Z"
    }
    ```

*   **`/chats/{chatId}`**
    *   Manages conversation metadata between a homeowner and a contractor.
    ```json
    {
      "chatId": "auto_generated_id",
      "leadId": "lead_id_here",
      "participants": ["homeowner_uid", "contractor_uid"],
      "lastMessage": {
        "text": "Hello, I'd like to discuss the assessment.",
        "timestamp": "2025-03-11T09:00:00Z",
        "senderId": "homeowner_uid"
      },
      "updatedAt": "2025-03-11T09:00:00Z"
    }
    ```
    *   **Subcollection:** `/chats/{chatId}/messages/{messageId}` will store the actual message content.

#### **Step 3: Core Backend API (User & Contractor Profiles)**

We'll use an Express.js app running within a single Cloud Function for an organized and performant API.

1.  **Initialize Firebase in your local project:**
    *   Run `firebase login`.
    *   Run `firebase init` and select **Firestore**, **Functions**, and **Hosting**. Choose your `HOMEase-AI` project.
    *   For Functions, select **TypeScript**.
    *   For Hosting, set the public directory to your Next.js build output (we'll configure this later).

2.  **Install Dependencies** in the `functions` directory:
    ```bash
    cd functions
    npm install express cors
    npm install --save-dev @types/express @types/cors
    ```

3.  **Create the API Endpoints:** Set up a file structure as detailed in the subtasks. The core logic involves creating, retrieving, and updating user and contractor profiles. An authentication middleware will protect these routes by verifying the user's Firebase ID token.

    **Example Controller Function (`profile.controller.ts`):**
    ```typescript
    import * as admin from 'firebase-admin';
    import { Response } from 'express';
    // ... other imports

    // This function runs after a user signs up on the frontend.
    export const createProfile = async (req: AuthenticatedRequest, res: Response) => {
      const { uid, email } = req.user!;
      const { role, ...profileData } = req.body;

      // Set a custom claim for role-based access control
      await admin.auth().setCustomUserClaims(uid, { role });

      const collection = role === 'contractor' ? 'contractors' : 'users';
      const newProfile = {
        uid,
        email: email!,
        role,
        createdAt: admin.firestore.Timestamp.now(),
        updatedAt: admin.firestore.Timestamp.now(),
        ...(role === 'contractor' ? { vettingStatus: 'pending', performanceTier: 'Bronze' } : {}),
        ...profileData,
      };

      await db.collection(collection).doc(uid).set(newProfile);
      return res.status(201).send(newProfile);
    };
    ```

4.  **Deploy the API:**
    ```bash
    firebase deploy --only functions
    ```
    This gives you a base API URL to use in your frontend.

---

### **Phase 2: Frontend Foundation & User Management**

Now, we'll build the Next.js frontend and connect it to our backend.

#### **Step 4: Next.js Frontend Setup**

1.  **Initialize Project:** Create a new Next.js app with TypeScript, ESLint, Tailwind CSS, and the App Router.
    ```bash
    npx create-next-app@latest homease-frontend
    ```

2.  **Integrate Shadcn UI:** This provides a beautiful and highly customizable component library.
    ```bash
    cd homease-frontend
    npx shadcn-ui@latest init
    ```
    Follow the prompts, accepting the defaults. This will configure Tailwind CSS and create helper files.

3.  **Install Initial Components:**
    ```bash
    npx shadcn-ui@latest add button card form input label select toast
    ```

4.  **Establish Project Structure:** Organize your `app` directory with route groups like `(auth)` for login/register pages and `(main)` for the core application dashboard. Create folders for `components`, `hooks`, `lib`, and `types`.

#### **Step 5: Frontend Authentication & Profile Management**

1.  **Configure Firebase Client:** Create a file (`lib/firebase/client.ts`) to initialize the Firebase client SDK using your project's web configuration keys (stored in a `.env.local` file for security).

2.  **Create an `AuthContext`:** This React Context will manage the global authentication state, providing the current `user` object and their `profile` data (fetched from your `/api/profile` endpoint) to the entire application. It will also handle route protection, redirecting unauthenticated users from protected pages.

3.  **Build Registration & Login Pages:**
    *   Use `react-hook-form` and `zod` for robust, type-safe form validation.
    *   **Registration Flow:**
        1.  User fills out the form (name, email, password, role).
        2.  Call Firebase Auth's `createUserWithEmailAndPassword`.
        3.  On success, get the user's ID token.
        4.  Make a `POST` request to your backend's `/api/profile` endpoint, sending the token in the `Authorization` header and the chosen role in the body.
        5.  Redirect to the dashboard.
    *   **Login Flow:**
        1.  User fills out the form (email, password).
        2.  Call Firebase Auth's `signInWithEmailAndPassword`.
        3.  The `AuthContext` will automatically detect the state change, fetch the user's profile, and redirect to the dashboard.

---

### **Phase 3: The Core Feature - AR Assessment & Lead Generation**

This is the most innovative and complex part of the application. A hybrid native/web approach is required for the best results.

#### **Step 6: The AR Home Assessment Module (Hybrid Approach)**

**Why a Hybrid App?** The WebXR API in browsers does not currently provide the low-level LiDAR mesh data needed for accurate room scanning. Therefore, a small, dedicated **native iOS app** using Swift and ARKit is the most robust solution. The main Next.js app will orchestrate the process.

1.  **Web-to-Native Bridge (Next.js):**
    *   When the user clicks "Start Scan" on an iPhone, the Next.js app makes a `POST` request to a Cloud Function to create a `scan` document in Firestore with a `pending` status.
    *   The function returns the `scanId`.
    *   The Next.js app then redirects the user to a **Universal Link** (e.g., `homease://scan?scanId=...&token=...`), passing the `scanId` and a Firebase Auth token. This link opens the native iOS app.

2.  **Native iOS Scanner App (Swift & ARKit):**
    *   The app launches and receives the `scanId` and auth `token`.
    *   It uses the token to authenticate with Firebase silently.
    *   It starts an `ARWorldTrackingConfiguration` with `sceneReconstruction` enabled to capture the room's LiDAR mesh.
    *   When the user finishes, the app processes the `ARMeshAnchor` data into a structured JSON format (containing vertices, faces, and identified features like doorways).
    *   It uploads this JSON file to a private folder in **Firebase Storage** (e.g., `/scans/{userId}/{scanId}/data.json`).
    *   Finally, it updates the `scan` document in Firestore, setting the `status` to `completed` and adding the `scanResultUrl`.

3.  **Displaying Results (Next.js):**
    *   The user is directed back to a results page in the Next.js app (e.g., `/dashboard/scans/{scanId}`).
    *   This page uses a real-time Firestore listener (`onSnapshot`) to watch the `scan` document. When the status changes to `completed`, it downloads the JSON from Storage and displays the results.

#### **Step 7: Backend AR Data Processing**

This is the "AI" part of your platform, where raw scan data is turned into actionable insights.

*   **Create a Cloud Function Trigger:** This function (`processArScan`) is triggered `onUpdate` of any document in the `scans` collection.
*   **Logic:**
    1.  It runs only when a scan's `status` changes to `completed`.
    2.  It downloads the raw `data.json` file from Firebase Storage.
    3.  It runs the data through a **rule-based analysis engine** (`assessment.logic.ts`). This engine checks for common aging-in-place issues based on predefined constants (e.g., `ADA_DOORWAY_WIDTH_INCHES = 32`).
    4.  It identifies needs like narrow doorways, lack of grab bars, or trip hazards (shower curbs).
    5.  It generates a new document in the `assessments` collection containing a list of `identifiedNeeds`, their severity, and estimated cost ranges based on your business plan's data.

#### **Step 8: Lead Creation & Contractor Matching**

This automated workflow converts a completed assessment into a paid lead for contractors.

1.  **`createLeadFromAssessment` Function:** A Cloud Function triggered `onCreate` of a document in the `assessments` collection. It creates a corresponding `lead` document, populating it with a summary of the project and the homeowner's location.

2.  **`matchLeadToContractors` Function:** A second Cloud Function triggered `onCreate` of a document in the `leads` collection.
    *   It queries all `active` and `approved` contractors in the `contractors` collection.
    *   It filters them based on **location** (service area zip codes) and **specialization** (matching project needs like "bathroom remodel" to contractor skills).
    *   It scores and sorts the remaining contractors based on their **performance tier** (`Platinum` > `Gold`, etc.) and **CAPS certification**.
    *   It selects the top 3-5 matches and creates entries in the `matchedContractors` array within the lead document.

---

### **Phase 4: Building the Marketplace & Admin Tools**

These features bring the two-sided marketplace to life.

#### **Step 9: Contractor Lead Notification System**

Instant notifications are key to contractor engagement.

1.  **Setup SendGrid Extension:** Install the "Trigger Email" Firebase Extension. Configure it to watch a `mail` collection.
2.  **Create Notification Function:** A Cloud Function (`sendNotificationOnLeadAssignment`) is triggered `onCreate` of a `matchedContractor` entry in a lead.
3.  **Logic:**
    *   It fetches the contractor's profile to get their email and FCM push notification tokens.
    *   **Email:** It creates a document in the `mail` collection with the contractor's email and dynamic template data (project location, summary, link to the lead). The SendGrid extension handles the rest.
    *   **Push Notification (FCM):** It uses the Firebase Admin SDK to send a push notification directly to the contractor's devices, alerting them to the new lead instantly.

#### **Step 10: In-App Communication Tool**

A secure, real-time chat connects homeowners and contractors.

1.  **Backend:**
    *   Create a **Callable Cloud Function** (`initiateChat`) that a user can call to start a conversation. This function verifies that a valid lead exists between the two parties before creating a new `chat` document.
    *   Create a **Firestore Trigger** (`updateChatOnNewMessage`) that listens for new messages in the `/chats/{chatId}/messages` subcollection. It updates the parent `chat` document with the `lastMessage` metadata for display in a chat list.

2.  **Security Rules:** Implement strict Firestore rules to ensure only participants of a chat can read or write messages to it.

3.  **Frontend:**
    *   Build a `ChatWindow` component.
    *   Use a custom React hook (`useMessages`) with a real-time listener (`onSnapshot`) to display messages as they arrive.
    *   A "Contact Contractor" button on the lead details page calls the `initiateChat` function to start the conversation.

#### **Step 11: Contractor Vetting & Admin Dashboard**

Maintaining a high-quality contractor network is paramount.

1.  **Admin Backend Endpoints:**
    *   Create a new `admin.controller.ts` file for your Cloud Function API.
    *   Add an `isAdmin` middleware that checks for a custom claim (`admin: true`) on the user's token. You can set this claim manually on your staff's accounts using the Firebase Admin SDK.
    *   Create secure endpoints like `GET /api/admin/contractors?status=pending` to list contractors needing review and `PUT /api/admin/contractors/{id}/status` to approve/reject them or update their performance tier.

2.  **Admin Dashboard (Frontend):**
    *   Create a new route group in Next.js, such as `/admin`.
    *   Protect this entire route group in a layout file that checks for the user's `admin` custom claim. If the claim is missing, redirect the user away.
    *   Build UI tables and forms that call the secure admin endpoints to display contractor information, review their uploaded credentials (licenses, insurance), and update their status and tier.

---

### **Deployment & Next Steps**

1.  **Configure Hosting:** In your `firebase.json` file, configure Firebase Hosting to serve your Next.js application. This involves setting up rewrites to direct all requests to the Next.js server-side rendering function.
2.  **Deploy:** Run `firebase deploy` to push your Hosting configuration, Firestore rules, and all Cloud Functions to production.

This technical plan provides a robust, scalable, and secure foundation for HOMEase | AI. It directly implements the core value propositions of your business plan, from the innovative AR assessment to the efficient, high-quality lead generation marketplace.

**Metadata:**
```json
{
  "subtask_count": 11
}
```
