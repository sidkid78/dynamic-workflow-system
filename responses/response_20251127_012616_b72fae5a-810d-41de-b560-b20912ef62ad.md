# Agent Response - orchestrator_workers

**Session ID**: b72fae5a-810d-41de-b560-b20912ef62ad
**Processing Time**: 569.81 seconds

## Final Response

Of course. Let's build out the Expense Splitter App. This is an excellent project that combines user authentication, database management, file storage, and core business logic, making it a perfect showcase for Next.js and Firebase.

Here is a comprehensive, step-by-step guide to building the application from project initialization to final deployment.

### **Executive Summary**

We will construct a full-stack Expense Splitter web application using the Next.js App Router for the frontend and Firebase for the backend. The application will allow users to register, create groups, invite members, add shared expenses with optional receipt uploads, and automatically view a simplified breakdown of who owes whom. The project is broken down into four key phases:

1.  **Foundation & Setup:** Initializing the Next.js project, configuring Firebase services (Auth, Firestore, Storage), and designing the database schema.
2.  **Core Functionality:** Implementing user authentication, creating protected routes, and building the features for creating, viewing, and managing groups.
3.  **Expense & Calculation Logic:** Developing the systems for adding expenses, uploading receipts, and implementing the core algorithm to calculate and display group balances.
4.  **Polishing & Deployment:** Applying a professional UI/UX design, securing the backend with robust rules, and deploying the final application to the web using Vercel.

---

### **Phase 1: Project Foundation and Data Modeling**

First, we'll set up our development environment and design the database structure that will power the entire application.

#### **1. Project Initialization (Next.js)**

Begin by creating a new Next.js project with the recommended modern stack.

1.  **Create the App:** Open your terminal and run:
    ```bash
    npx create-next-app@latest expense-splitter
    ```
2.  **Select Options:** Use the following settings for a robust setup:
    *   TypeScript: **Yes**
    *   ESLint: **Yes**
    *   Tailwind CSS: **Yes**
    *   `src/` directory: **Yes**
    *   App Router: **Yes**
    *   Customize import alias: **No**
3.  **Navigate and Install Firebase:**
    ```bash
    cd expense-splitter
    npm install firebase
    ```

#### **2. Firebase Backend Configuration**

Next, set up the necessary Firebase services.

1.  **Create a Firebase Project:** Go to the [Firebase Console](https://console.firebase.google.com/), click "Add project," and follow the setup wizard.
2.  **Enable Services:**
    *   **Firestore Database:** From the "Build" menu, create a Firestore database. Start in **Test mode** for now; we will secure it later.
    *   **Authentication:** Go to the Authentication service and enable the **Email/Password** and **Google** sign-in providers.
    *   **Storage:** Go to the Storage service and create a storage bucket, also starting in **Test mode**.
3.  **Connect App to Firebase:**
    *   In your Firebase project settings, register a new **Web app (`</>`)**.
    *   Firebase will provide a `firebaseConfig` object. Copy these credentials.
4.  **Set Up Environment Variables:**
    *   In your project root, create a file named `.env.local`.
    *   Add your Firebase credentials, prefixed with `NEXT_PUBLIC_`:
        ```.env.local
        NEXT_PUBLIC_FIREBASE_API_KEY="AIzaSy..."
        NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="your-project-id.firebaseapp.com"
        NEXT_PUBLIC_FIREBASE_PROJECT_ID="your-project-id"
        // ...and so on for all keys.
        ```
5.  **Create Firebase Initializer:** Centralize your Firebase configuration. Create `src/lib/firebase/config.ts`:
    ```typescript
    // src/lib/firebase/config.ts
    import { initializeApp, getApps, getApp } from "firebase/app";
    import { getAuth } from "firebase/auth";
    import { getFirestore } from "firebase/firestore";
    import { getStorage } from "firebase/storage";

    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    };

    const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
    const db = getFirestore(app);
    const auth = getAuth(app);
    const storage = getStorage(app);

    export { app, db, auth, storage };
    ```

#### **3. Firestore Schema Design**

A well-planned schema is essential for performance and scalability. We'll use three top-level collections.

*   **`users` Collection:** Stores individual user profiles. The Document ID will be the user's UID from Firebase Auth.
    *   Path: `/users/{userId}`
    *   Fields: `uid`, `email`, `displayName`, `photoURL`, `createdAt`, `groups` (Array of group IDs).

*   **`groups` Collection:** Stores information about each expense-sharing group.
    *   Path: `/groups/{groupId}`
    *   Fields: `groupName`, `createdBy` (user UID), `createdAt`, `inviteCode`, `members` (Array of member objects with `uid`, `displayName`, `photoURL`), and `memberUids` (a simple Array of member UIDs for efficient security rule checks).

*   **`expenses` Subcollection:** Each group document will contain a subcollection of its expenses. This is a highly efficient way to query for all expenses related to a single group.
    *   Path: `/groups/{groupId}/expenses/{expenseId}`
    *   Fields: `description`, `amount` (in cents), `createdAt`, `paidBy` (user UID), `paidByDisplayName`, `receiptUrl` (optional), `splitMethod`, and `participants` (Array of objects detailing who owes what, e.g., `{ uid, amountOwed }`).

**Note on Balances:** We will not store running balances in the database. Instead, balances will be calculated dynamically on the client side by fetching all expenses for a group. This approach is more robust and less prone to data synchronization errors.

---

### **Phase 2: User Authentication and Group Management**

With the foundation laid, we'll build the app's core interactive features.

#### **1. Global Authentication State**

We'll use React Context to manage the user's authentication state across the entire application. This context will also handle the crucial task of creating a user document in Firestore the first time a user signs in.

*   Create `src/context/AuthContext.tsx`. This provider will:
    *   Use Firebase's `onAuthStateChanged` listener to track the current user.
    *   When a user logs in, it will check if a corresponding document exists in `/users/{uid}`. If not, it creates one.
    *   Provide the `user` object, a `loading` state, and a `logout` function to all child components.
*   Wrap the application's root layout (`src/app/layout.tsx`) with this `AuthProvider` to make it globally accessible.

#### **2. Authentication Pages and Protected Routes**

Users need a way to sign in, sign up, and be restricted from accessing content they aren't authorized to see.

1.  **Create Auth Pages:** Build the UI for `/login` and `/signup` pages using simple forms. These forms will use the Firebase SDK functions (`signInWithEmailAndPassword`, `createUserWithEmailAndPassword`, `signInWithPopup` for Google) to handle authentication.
2.  **Implement Protected Routes:** Create a `ProtectedRoute` component (`src/components/ProtectedRoute.tsx`). This component will:
    *   Use the `useAuth` hook to access the current user and loading state.
    *   If `loading` is true, it can show a spinner.
    *   If `loading` is false and no `user` exists, it will redirect to the `/login` page using Next.js's `useRouter`.
    *   Wrap any page that requires authentication (like the dashboard) with this `ProtectedRoute` component.

#### **3. Group Management Features**

Once authenticated, users should be able to create and view their groups.

1.  **Firestore Service Functions:** Create a file `src/lib/firebase/firestore.ts` to house all database interactions.
    *   `createGroup(groupName, user)`: Creates a new document in the `groups` collection, populates it with the creator's info, generates a unique invite code (using a library like `nanoid`), and adds the new group's ID to the creator's document in the `users` collection.
    *   `getUserGroups(userId)`: Fetches the user's document, retrieves their list of group IDs, and then queries the `groups` collection to get the full details for each group.
2.  **UI Components:**
    *   **CreateGroupModal:** A modal form that takes a group name and calls the `createGroup` service function on submission.
    *   **GroupList:** A component that calls `getUserGroups` and maps over the results to display a list of `GroupCard` components. Each card shows the group's name, number of members, and the invite code.
3.  **Dashboard Page:** Update the `/dashboard` page to be the main hub. It will display a "Create Group" button that opens the modal and will render the `GroupList` component.

---

### **Phase 3: Expense Tracking and Debt Calculation**

This is the core "splitter" functionality of the application.

#### **1. Expense Creation and Receipt Uploads**

We'll build a dedicated page for each group where users can add and view expenses.

1.  **Create Dynamic Group Page:** Create a dynamic route at `src/app/group/[groupId]/page.tsx`. This page will be the central view for a single group.
2.  **Extend Firestore Service:** Add functions to `firestore.ts`:
    *   `getGroupDetails(groupId)`: Fetches a single group's document.
    *   `addExpenseToGroup(expenseData)`: Creates a new document in the `/groups/{groupId}/expenses` subcollection.
    *   `getGroupExpenses(groupId)`: Fetches all documents from a group's `expenses` subcollection.
3.  **Implement Receipt Uploads:**
    *   Create a storage service file, `src/lib/firebase/storage.ts`.
    *   Implement an `uploadReceipt(file, groupId)` function that uses Firebase Storage to upload an image to a path like `receipts/{groupId}/{unique_file_name}` and returns the public download URL. Use `uuid` to generate unique file names.
4.  **Build UI Components:**
    *   **AddExpenseModal:** A comprehensive modal form with fields for description, amount, who paid (a dropdown of group members), and an optional file input for the receipt. On submit, it will first upload the receipt (if present) to get the URL, then call `addExpenseToGroup` with all the data.
    *   **ExpenseList:** A component that displays a list of expenses for the group. Each item shows the description, amount, payer, and a link to "View Receipt" if a `receiptUrl` exists.

#### **2. Debt Calculation Logic**

The "magic" happens here. We'll write a pure function to process expenses and determine who owes whom.

1.  **Create Calculation Utility:** Create a file `src/utils/debtCalculator.ts`.
2.  **Implement `calculateBalances` Function:** This function will accept two arguments: an array of `expenses` and an array of group `members`.
    *   **Step 1: Tally Balances:** It iterates through all expenses. For each expense, it credits the `paidBy` user with the full amount and debits each `participant` by their `amountOwed`. This results in a map of each user's net balance (positive means they are owed money, negative means they owe money).
    *   **Step 2: Simplify Debts:** It implements a greedy algorithm to simplify the list of debts. It separates users into debtors (negative balance) and creditors (positive balance) and creates the minimum number of transactions required to settle all balances. For example, if A owes B $10 and B owes C $10, the algorithm simplifies this to A pays C $10.
3.  **Create Balance Summary UI:** Build a `BalanceSummary` component that takes the simplified debt list and displays it in a clear, human-readable format (e.g., "Alice owes Bob $15.50").

#### **3. Integrate on Group Page**

Update the dynamic group page (`/group/[groupId]/page.tsx`) to tie everything together.

*   On page load, it will fetch both the group details and all its expenses in parallel.
*   It will then pass this data to the `calculateBalances` function.
*   Finally, it will render the `BalanceSummary` component with the calculated debts at the top of the page, followed by the full `ExpenseList`.

---

### **Phase 4: UI/UX, Security, and Deployment**

The final phase focuses on making the app professional, secure, and publicly accessible.

#### **1. UI/UX Design and Styling**

We'll use Tailwind CSS to create a consistent, modern, and responsive design.

1.  **Establish a Design System:** Extend the `tailwind.config.ts` file with a custom color palette (e.g., `brand.primary`, `success`, `danger`). Refine base styles in `globals.css` for buttons, inputs, and cards.
2.  **Create a Reusable Layout:** Build a `MainLayout` component that includes a consistent header with the app logo, user information, and a logout button. Use this layout on all authenticated pages.
3.  **Refine Components:** Systematically style all components—modals, cards, forms, and lists—using the defined color palette and utility classes. Add hover effects, transitions, and icons (e.g., from `heroicons`) to improve user experience.

#### **2. Firebase Security Rules**

This is a critical, non-negotiable step before deployment to protect user data.

1.  **Firestore Rules:** In the Firebase console, go to Firestore > Rules. Replace the test rules with production rules that enforce:
    *   **Users:** A user can only read and write their own document (`/users/{userId}`).
    *   **Groups:** A user can only read/write group data if their UID is present in the group's `memberUids` array.
    *   **Expenses:** A user can only create an expense if they are a member of the group and are listed as the payer.
2.  **Storage Rules:** Go to Storage > Rules. Implement rules that:
    *   Allow image uploads only for authenticated users who are members of the corresponding group.
    *   Validate uploads to ensure they are images and within a reasonable size limit (e.g., < 5MB).
    *   Allow reads (downloads) only for members of the group.

#### **3. Deployment to Vercel**

Finally, we'll deploy the application to the web.

1.  **Prepare for Deployment:**
    *   Initialize a Git repository and push your project to a provider like GitHub.
    *   Ensure your `.gitignore` file includes `.env.local` to prevent committing secret keys.
2.  **Import to Vercel:**
    *   Sign up for Vercel using your GitHub account.
    *   Import your project repository from the Vercel dashboard.
3.  **Configure Environment Variables:** In the Vercel project settings, navigate to "Environment Variables." Copy every key-value pair from your local `.env.local` file into Vercel's UI. This securely provides your production deployment with the Firebase credentials.
4.  **Deploy:** Click the "Deploy" button. Vercel will automatically build and deploy your application, providing you with a public URL (e.g., `expense-splitter.vercel.app`).

Congratulations! You have now successfully designed, built, secured, and deployed a feature-rich Expense Splitter application. With Vercel's CI/CD, every future `git push` to your main branch will automatically trigger a new deployment, keeping your live application up-to-date.

## Intermediate Steps



**Metadata:**
```json
{
  "subtasks": [
    {
      "required_expertise": "Next.js, Firebase Console",
      "dependencies": [],
      "title": "Project Setup and Firebase Configuration",
      "id": "project-setup",
      "priority": 1,
      "description": "Initialize a new Next.js project using the App Router. Create a corresponding Firebase project, enabling and configuring Firestore, Firebase Authentication (Email/Password and Google), and Firebase Storage. Securely set up environment variables for Firebase configuration within the Next.js application."
    },
    {
      "required_expertise": "Firestore, NoSQL Database Design",
      "priority": 2,
      "dependencies": [
        "project-setup"
      ],
      "id": "schema-design",
      "description": "Design the NoSQL database schema for Firestore. This includes defining the collections for users, groups, and expenses. Specify the document structure for each, including fields, data types, and relationships (e.g., how users are linked to groups and expenses to users/groups).",
      "title": "Firestore Database Schema Design"
    },
    {
      "title": "Implement User Authentication",
      "priority": 3,
      "required_expertise": "Next.js, React, Firebase Authentication",
      "description": "Create the UI and logic for user registration, login, and logout using the Firebase Authentication SDK. Implement protected routes to restrict access to the main application features to authenticated users only. Manage the global authentication state using React Context or a similar state management solution.",
      "id": "user-auth",
      "dependencies": [
        "project-setup"
      ]
    },
    {
      "required_expertise": "Next.js, React, Firestore",
      "priority": 4,
      "title": "Build Group Management Features",
      "dependencies": [
        "user-auth",
        "schema-design"
      ],
      "description": "Develop the functionality for users to create new groups, view their existing groups, and invite other users (e.g., via a unique invite code). This involves creating the UI components and the Firestore queries/mutations to manage group data.",
      "id": "group-management"
    },
    {
      "priority": 5,
      "title": "Implement Expense Creation and Tracking",
      "id": "expense-creation",
      "dependencies": [
        "group-management"
      ],
      "required_expertise": "Next.js, React Forms, Firestore",
      "description": "Create the form and underlying logic for adding an expense to a group. The form should capture the expense description, total amount, the user who paid, and the split method (e.g., split equally, by specific amounts). This data will be saved as a new document in the 'expenses' collection in Firestore."
    },
    {
      "id": "receipt-upload",
      "required_expertise": "Firebase Storage, React File Handling",
      "title": "Add Receipt Upload Functionality",
      "priority": 6,
      "description": "Integrate Firebase Storage to allow users to upload receipt images when creating an expense. The uploaded image's URL will be stored as a field in the corresponding expense document in Firestore.",
      "dependencies": [
        "expense-creation"
      ]
    },
    {
      "priority": 7,
      "dependencies": [
        "expense-creation"
      ],
      "id": "debt-calculation",
      "title": "Develop Debt Calculation and Dashboard Logic",
      "description": "Develop the core algorithm to calculate the net balance for each member within a group. This logic will process all expenses to determine who owes whom. Display these balances on a clear, intuitive dashboard for each group, providing a summary of debts.",
      "required_expertise": "Algorithm Design, Data Processing, Next.js"
    },
    {
      "id": "ui-styling",
      "description": "Design and apply a consistent and responsive UI/UX across the application using a modern CSS framework like Tailwind CSS or a component library. Ensure all components, from authentication forms to the group dashboard, are user-friendly and visually appealing.",
      "title": "UI/UX Design and Styling",
      "dependencies": [
        "user-auth",
        "group-management",
        "expense-creation",
        "debt-calculation"
      ],
      "required_expertise": "UI/UX Design, CSS, Tailwind CSS",
      "priority": 8
    },
    {
      "required_expertise": "Firebase Security Rules",
      "priority": 9,
      "title": "Implement Firebase Security Rules",
      "description": "Write and enforce security rules for Firestore and Firebase Storage to protect user data, ensuring that users can only access and modify data they are authorized to. This is a critical step before deployment.",
      "id": "security-rules",
      "dependencies": [
        "project-setup",
        "ui-styling",
        "debt-calculation"
      ]
    },
    {
      "title": "Deploy the Application to Vercel",
      "description": "Deploy the completed Next.js application to a hosting platform like Vercel. Configure the production environment, including setting up the necessary environment variables and ensuring the domain is set up correctly.",
      "priority": 10,
      "required_expertise": "Vercel, CI/CD",
      "dependencies": [
        "security-rules"
      ],
      "id": "deployment"
    }
  ],
  "execution_strategy": "The project will be executed in a phased, sequential manner, starting with foundational setup and progressively building features. Phase 1 focuses on setting up the Next.js project and Firebase backend, including user authentication. Phase 2 will implement the core application logic for group and expense management. Phase 3 will develop the debt calculation logic and the main user dashboard. Phase 4 will handle the UI/UX polishing and final deployment. This ensures that a solid foundation is built before adding complex features.",
  "task_understanding": "The user wants to build a personal finance application using Next.js (App Router) and Firebase. From the provided options, the 'Expense Splitter App' is the most suitable project to plan. The goal is to create a web application where users can form groups, track shared expenses, upload receipts, and easily see who owes whom, with all data stored and managed in Firebase."
}
```

### Next.js, Firebase Console Specialist

Excellent choice! An Expense Splitter App is a practical and feature-rich project to build. Let's get started with the foundational step: setting up our Next.js project and configuring Firebase.

### **Subtask: Project Setup and Firebase Configuration**

In this phase, we will initialize a new Next.js application using the App Router, create a corresponding Firebase project, and securely connect the two using environment variables.

---

### **Step 1: Initialize the Next.js Project**

First, let's create a new Next.js project. Make sure you have Node.js (version 18.17 or later) installed.

1.  **Open your terminal** and run the following command. We'll name our project `expense-splitter`.

    ```bash
    npx create-next-app@latest expense-splitter
    ```

2.  You'll be prompted with a series of questions. For a modern and robust setup, I recommend these selections:

    ```text
    ✔ Would you like to use TypeScript? … Yes
    ✔ Would you like to use ESLint? … Yes
    ✔ Would you like to use Tailwind CSS? … Yes
    ✔ Would you like to use `src/` directory? … Yes
    ✔ Would you like to use App Router? (recommended) … Yes
    ✔ Would you like to customize the default import alias (@/*)? … No
    ```

3.  Once the installation is complete, navigate into your new project directory:

    ```bash
    cd expense-splitter
    ```

You now have a clean Next.js project ready to go.

### **Step 2: Create and Configure the Firebase Project**

Now, let's set up the backend services on Firebase.

1.  **Go to the Firebase Console:** [https://console.firebase.google.com/](https://console.firebase.google.com/)
2.  **Create a New Project:** Click on "Add project", give it a name (e.g., "Expense Splitter App"), and follow the on-screen steps. You can disable Google Analytics for this project if you wish.
3.  Once your project is created, you'll be taken to the project dashboard. We need to enable three core services:

    **A. Enable Firestore Database:**
    *   In the left-hand menu under "Build", click on **Firestore Database**.
    *   Click **Create database**.
    *   Choose to start in **Test mode**. This allows for easy read/write access during development.
        > **⚠️ Security Warning:** Test mode rules expire after 30 days and leave your data open. We will write secure rules in a later step before going to production.
    *   Select a Cloud Firestore location (choose one close to your target users).
    *   Click **Enable**.

    **B. Enable Firebase Authentication:**
    *   In the left-hand menu under "Build", click on **Authentication**.
    *   Click **Get started**.
    *   In the "Sign-in method" tab, you'll see a list of providers. Enable the following two:
        *   **Email/Password**: Click on it, toggle the "Enable" switch, and click "Save".
        *   **Google**: Click on it, toggle the "Enable" switch, provide a project support email, and click "Save".

    **C. Enable Firebase Storage:**
    *   In the left-hand menu under "Build", click on **Storage**.
    *   Click **Get started**.
    *   Follow the prompts to create a storage bucket, again starting in **Test mode**.
    *   Choose the same location you selected for Firestore.

Your Firebase backend is now configured with the necessary services.

### **Step 3: Connect Firebase to Your Next.js App**

Now we need to get the configuration keys from Firebase to let our Next.js app know how to connect to it.

1.  In your Firebase project dashboard, click the **Gear icon** (Project settings) next to "Project Overview".
2.  Under the "General" tab, scroll down to the "Your apps" section.
3.  Click on the **Web icon (`</>`)** to register a new web app.
4.  Give your app a nickname (e.g., "Expense Splitter Web") and click **Register app**.
5.  Firebase will generate a configuration object. **Copy the `firebaseConfig` object**. It will look something like this:

    ```javascript
    const firebaseConfig = {
      apiKey: "AIzaSy...",
      authDomain: "your-project-id.firebaseapp.com",
      projectId: "your-project-id",
      storageBucket: "your-project-id.appspot.com",
      messagingSenderId: "...",
      appId: "1:..."
    };
    ```

### **Step 4: Securely Set Up Environment Variables**

Never hardcode your Firebase credentials directly into your application code. We'll use environment variables.

1.  In the root of your `expense-splitter` project, create a new file named `.env.local`.
2.  Open `.env.local` and add the keys from the `firebaseConfig` object you copied, prefixing each with `NEXT_PUBLIC_`. This prefix is required by Next.js to expose the variable to the browser.

    ```.env.local
    NEXT_PUBLIC_FIREBASE_API_KEY="AIzaSy..."
    NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="your-project-id.firebaseapp.com"
    NEXT_PUBLIC_FIREBASE_PROJECT_ID="your-project-id"
    NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="your-project-id.appspot.com"
    NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="..."
    NEXT_PUBLIC_FIREBASE_APP_ID="1:..."
    ```

3.  **Important:** The `.gitignore` file that `create-next-app` generates should already include `.env.local`. Double-check to ensure it's there so you don't accidentally commit your secret keys to version control.

### **Step 5: Create a Firebase Initialization File**

Let's create a centralized file to initialize Firebase and export its services for use throughout our app.

1.  **Install the Firebase SDK:** In your terminal, run:

    ```bash
    npm install firebase
    ```

2.  **Create the config file:** Inside the `src` directory, create a new folder structure and file: `src/lib/firebase/config.ts`.

3.  **Add the initialization code:** Paste the following code into `src/lib/firebase/config.ts`. This code safely initializes Firebase on the client side.

    ```typescript
    // src/lib/firebase/config.ts
    import { initializeApp, getApps, getApp } from "firebase/app";
    import { getAuth } from "firebase/auth";
    import { getFirestore } from "firebase/firestore";
    import { getStorage } from "firebase/storage";

    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    };

    // Initialize Firebase for SSR
    const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

    const firestore = getFirestore(app);
    const auth = getAuth(app);
    const storage = getStorage(app);

    export { app, firestore, auth, storage };
    ```

4.  **Restart your development server:** Since you've added environment variables, you need to stop your dev server (if it's running) with `Ctrl + C` and restart it to load them.

    ```bash
    npm run dev
    ```

---

**Congratulations!** You have successfully:
*   Initialized a new Next.js 14 project with the App Router, TypeScript, and Tailwind CSS.
*   Created a Firebase project and enabled Firestore, Authentication, and Storage.
*   Securely connected your Next.js app to Firebase using environment variables.
*   Set up a centralized Firebase initialization file.

Your project's foundation is now solid and ready for the next step: building the authentication system.

**Metadata:**
```json
{
  "subtask_id": "project-setup",
  "title": "Project Setup and Firebase Configuration",
  "expertise": "Next.js, Firebase Console"
}
```

### Firestore, NoSQL Database Design Specialist

Excellent, the project foundation is set. Now, let's design the heart of our application: the database schema. A well-designed schema is crucial for performance, scalability, and ease of development. We will use Firestore, a NoSQL document database, which gives us flexibility.

Our schema will be built around three core entities: **Users**, **Groups**, and **Expenses**.

---

### **Subtask: Firestore Database Schema Design**

Here is the detailed NoSQL schema for our Expense Splitter application.

### 1. `users` Collection

This collection stores information for each registered user. The Document ID for each user document should be their unique UID provided by Firebase Authentication. This creates a direct and secure link between the authenticated user and their data.

**Collection Path:** `/users/{userId}`

**Document Structure:**

```json
{
  "uid": "auth_generated_uid_123",
  "email": "jane.doe@example.com",
  "displayName": "Jane Doe",
  "photoURL": "https://example.com/path/to/photo.jpg",
  "createdAt": "2023-10-27T10:00:00Z", // Firestore Timestamp
  "groups": [
    "group_id_abc",
    "group_id_xyz"
  ]
}
```

**Field Descriptions:**

*   **`uid` (String):** The user's unique ID from Firebase Auth. Stored for convenience, but the Document ID is the primary key.
*   **`email` (String):** The user's email address, used for identification and communication.
*   **`displayName` (String):** The user's full name, which will be displayed throughout the app.
*   **`photoURL` (String, nullable):** A URL to the user's profile picture.
*   **`createdAt` (Timestamp):** The timestamp of when the user account was created.
*   **`groups` (Array<String>):** An array of `groupId`s. This is a form of **denormalization** that allows us to quickly fetch all groups a user belongs to without performing a complex query across the entire `groups` collection.

---

### 2. `groups` Collection

This collection stores all the groups created by users. Each group is a container for members and their shared expenses.

**Collection Path:** `/groups/{groupId}`

**Document Structure:**

```json
{
  "groupName": "Hawaii Trip 2024",
  "groupImageURL": "https://example.com/path/to/group_image.jpg",
  "createdBy": "auth_generated_uid_123", // References users.uid
  "createdAt": "2023-11-15T14:30:00Z", // Firestore Timestamp
  "defaultCurrency": "USD",
  "members": [
    {
      "uid": "auth_generated_uid_123",
      "displayName": "Jane Doe",
      "photoURL": "https://example.com/path/to/photo.jpg",
      "email": "jane.doe@example.com",
      "joinedAt": "2023-11-15T14:30:00Z" // Firestore Timestamp
    },
    {
      "uid": "auth_generated_uid_456",
      "displayName": "John Smith",
      "photoURL": "https://example.com/path/to/johns_photo.jpg",
      "email": "john.smith@example.com",
      "joinedAt": "2023-11-16T09:00:00Z" // Firestore Timestamp
    }
  ]
}
```

**Field Descriptions:**

*   **`groupName` (String):** The user-defined name for the group (e.g., "Apartment Bills").
*   **`groupImageURL` (String, nullable):** An optional URL for a group cover photo.
*   **`createdBy` (String):** The `uid` of the user who created the group.
*   **`createdAt` (Timestamp):** The timestamp of when the group was created.
*   **`defaultCurrency` (String):** The default currency for the group (e.g., "USD", "EUR").
*   **`members` (Array<Object>):** An array of member objects. We **denormalize** user data here (like `displayName` and `photoURL`) to avoid fetching each user's profile individually every time we load a group. This significantly improves performance for the group dashboard view.

---

### 3. `expenses` Collection

This collection holds every individual transaction. Each expense document is linked to a single group. This design allows us to query all expenses for a specific group efficiently.

**Collection Path:** `/expenses/{expenseId}`

**Document Structure:**

```json
{
  "groupId": "group_id_abc", // Foreign key to the groups collection
  "description": "Dinner at Luigi's",
  "totalAmount": 150.75,
  "currency": "USD",
  "date": "2023-11-17T20:00:00Z", // Firestore Timestamp (when the expense occurred)
  "createdAt": "2023-11-17T22:05:00Z", // Firestore Timestamp (when the record was created)
  "addedBy": "auth_generated_uid_456", // References users.uid
  "receiptURL": "https://firebasestorage.googleapis.com/...",
  "notes": "Split the appetizer three ways, but Jane paid for the wine.",
  "payment": [
    { "paidBy": "auth_generated_uid_456", "amountPaid": 150.75 }
  ],
  "splitDetails": [
    { "splitWith": "auth_generated_uid_123", "amountOwed": 50.25 },
    { "splitWith": "auth_generated_uid_456", "amountOwed": 50.25 },
    { "splitWith": "auth_generated_uid_789", "amountOwed": 50.25 }
  ]
}
```

**Field Descriptions:**

*   **`groupId` (String):** A crucial field that links the expense to its parent group. We will create a Firestore index on this field for fast queries.
*   **`description` (String):** A brief description of the expense.
*   **`totalAmount` (Number):** The total monetary value of the transaction.
*   **`currency` (String):** The currency of the transaction.
*   **`date` (Timestamp):** The actual date and time the expense occurred.
*   **`createdAt` (Timestamp):** The timestamp of when the expense was logged in the app.
*   **`addedBy` (String):** The `uid` of the user who entered this expense record.
*   **`receiptURL` (String, nullable):** A URL pointing to the receipt image stored in Firebase Storage.
*   **`notes` (String, nullable):** Optional field for additional details.
*   **`payment` (Array<Object>):** An array defining who paid and how much. This supports simple cases (one person paid all) and complex ones (multiple people contributed to the payment).
    *   `paidBy` (String): The `uid` of the user who paid.
    *   `amountPaid` (Number): The amount they paid.
*   **`splitDetails` (Array<Object>):** An array defining how the expense is allocated among members. The frontend logic will calculate these values based on the split type (e.g., equally, by amount, by percentage).
    *   `splitWith` (String): The `uid` of the user who is part of the split.
    *   `amountOwed` (Number): The calculated share of the total amount this user is responsible for.

### How Balances Are Calculated

With this schema, we **do not** store running balances (e.g., "Jane owes John $20") in the database. This is difficult to maintain and prone to errors. Instead, balances are calculated dynamically on the client-side:

1.  Fetch all expenses for a given group.
2.  For each user, iterate through all expenses and calculate:
    *   **Total Paid:** Sum of `amountPaid` where `paidBy` is their `uid`.
    *   **Total Share:** Sum of `amountOwed` where `splitWith` is their `uid`.
3.  **Net Balance = Total Paid - Total Share.**
    *   A positive balance means the group owes them money.
    *   A negative balance means they owe the group money.

The app's UI can then run a simplification algorithm on these net balances to show the simplest set of transactions to settle up (e.g., "You pay John $15.50").

This schema is normalized where it matters (separating users, groups, and expenses) but uses denormalization strategically to optimize for common read operations, providing a solid and performant foundation for our application.

**Metadata:**
```json
{
  "subtask_id": "schema-design",
  "title": "Firestore Database Schema Design",
  "expertise": "Firestore, NoSQL Database Design"
}
```

### Next.js, React, Firebase Authentication Specialist

Excellent, the foundation is set. Now, let's implement the core user authentication system. This will allow users to sign up, log in, and log out, and will protect the main parts of our application from unauthorized access.

We will use React's Context API to manage the user's authentication state globally across the application.

---

### **Step 1: Create the Authentication Context**

The Auth Context will be the single source of truth for the current user's status. It will provide the user object, a loading state, and authentication functions (login, logout, etc.) to any component that needs them.

1.  Create a new directory and file: `src/context/AuthContext.tsx`.
2.  Paste the following code into the file. Read the comments to understand how it works.

    ```typescript
    // src/context/AuthContext.tsx
    'use client';

    import {
      ReactNode,
      createContext,
      useContext,
      useEffect,
      useState,
    } from 'react';
    import {
      User,
      onAuthStateChanged,
      signOut as firebaseSignOut,
    } from 'firebase/auth';
    import { auth } from '@/lib/firebase/config'; // Our initialized auth instance
    import { useRouter } from 'next/navigation';

    // Define the shape of the context data
    interface AuthContextType {
      user: User | null;
      loading: boolean;
      logout: () => Promise<void>;
    }

    // Create the context with a default value
    const AuthContext = createContext<AuthContextType | undefined>(undefined);

    // Create the provider component
    export const AuthProvider = ({ children }: { children: ReactNode }) => {
      const [user, setUser] = useState<User | null>(null);
      const [loading, setLoading] = useState(true);
      const router = useRouter();

      useEffect(() => {
        // Subscribe to Firebase auth state changes
        const unsubscribe = onAuthStateChanged(auth, (user) => {
          if (user) {
            setUser(user);
          } else {
            setUser(null);
          }
          setLoading(false);
        });

        // Cleanup subscription on unmount
        return () => unsubscribe();
      }, []);

      const logout = async () => {
        await firebaseSignOut(auth);
        router.push('/login'); // Redirect to login page after logout
      };

      const value = {
        user,
        loading,
        logout,
      };

      // We don't render anything until the initial auth check is complete
      return (
        <AuthContext.Provider value={value}>
          {!loading && children}
        </AuthContext.Provider>
      );
    };

    // Create a custom hook for easy access to the context
    export const useAuth = () => {
      const context = useContext(AuthContext);
      if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
      }
      return context;
    };
    ```

### **Step 2: Integrate the Auth Provider into the App**

To make the authentication context available to all pages and components, we need to wrap our root layout with the `AuthProvider`.

1.  Open `src/app/layout.tsx`.
2.  Import `AuthProvider` and wrap the `{children}` with it.

    ```tsx
    // src/app/layout.tsx
    import type { Metadata } from 'next';
    import { Inter } from 'next/font/google';
    import './globals.css';
    import { AuthProvider } from '@/context/AuthContext'; // Import the provider

    const inter = Inter({ subsets: ['latin'] });

    export const metadata: Metadata = {
      title: 'Expense Splitter',
      description: 'Split bills with ease',
    };

    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body className={inter.className}>
            <AuthProvider>{children}</AuthProvider> {/* Wrap here */}
          </body>
        </html>
      );
    }
    ```

### **Step 3: Create the Login and Sign Up Pages**

Now, let's build the UI for users to log in and create new accounts. We'll use a route group `(auth)` to keep these pages organized.

1.  **Create the file structure:**
    *   `src/app/(auth)/login/page.tsx`
    *   `src/app/(auth)/signup/page.tsx`

2.  **Code for the Login Page (`src/app/(auth)/login/page.tsx`):**

    ```tsx
    // src/app/(auth)/login/page.tsx
    'use client';

    import { useState } from 'react';
    import { useRouter } from 'next/navigation';
    import Link from 'next/link';
    import {
      signInWithEmailAndPassword,
      signInWithPopup,
      GoogleAuthProvider,
    } from 'firebase/auth';
    import { auth } from '@/lib/firebase/config';

    export default function LoginPage() {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [error, setError] = useState<string | null>(null);
      const router = useRouter();

      const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        try {
          await signInWithEmailAndPassword(auth, email, password);
          router.push('/dashboard'); // Redirect to a protected route on success
        } catch (err: any) {
          setError(err.message);
        }
      };

      const handleGoogleSignIn = async () => {
        const provider = new GoogleAuthProvider();
        try {
          await signInWithPopup(auth, provider);
          router.push('/dashboard');
        } catch (err: any) {
          setError(err.message);
        }
      };

      return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100">
          <div className="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
            <h2 className="text-2xl font-bold text-center">Login</h2>
            <form onSubmit={handleLogin} className="space-y-6">
              <div>
                <label className="label">Email</label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                  className="input"
                />
              </div>
              <div>
                <label className="label">Password</label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                  className="input"
                />
              </div>
              {error && <p className="text-red-500 text-sm">{error}</p>}
              <button type="submit" className="button w-full">
                Login
              </button>
            </form>
            <div className="divider">OR</div>
            <button
              onClick={handleGoogleSignIn}
              className="button-secondary w-full"
            >
              Sign in with Google
            </button>
            <p className="text-sm text-center">
              Don't have an account?{' '}
              <Link href="/signup" className="text-blue-600 hover:underline">
                Sign Up
              </Link>
            </p>
          </div>
        </div>
      );
    }
    ```

3.  **Code for the Sign Up Page (`src/app/(auth)/signup/page.tsx`):**

    ```tsx
    // src/app/(auth)/signup/page.tsx
    'use client';

    import { useState } from 'react';
    import { useRouter } from 'next/navigation';
    import Link from 'next/link';
    import { createUserWithEmailAndPassword } from 'firebase/auth';
    import { auth } from '@/lib/firebase/config';

    export default function SignUpPage() {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [error, setError] = useState<string | null>(null);
      const router = useRouter();

      const handleSignUp = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        try {
          await createUserWithEmailAndPassword(auth, email, password);
          router.push('/dashboard'); // Redirect to a protected route on success
        } catch (err: any) {
          setError(err.message);
        }
      };

      return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100">
          <div className="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
            <h2 className="text-2xl font-bold text-center">Create an Account</h2>
            <form onSubmit={handleSignUp} className="space-y-6">
              <div>
                <label className="label">Email</label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                  className="input"
                />
              </div>
              <div>
                <label className="label">Password</label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                  className="input"
                />
              </div>
              {error && <p className="text-red-500 text-sm">{error}</p>}
              <button type="submit" className="button w-full">
                Sign Up
              </button>
            </form>
            <p className="text-sm text-center">
              Already have an account?{' '}
              <Link href="/login" className="text-blue-600 hover:underline">
                Login
              </Link>
            </p>
          </div>
        </div>
      );
    }
    ```

4.  **Add some basic styles** to `src/app/globals.css` to make the forms look decent.

    ```css
    /* src/app/globals.css */
    @tailwind base;
    @tailwind components;
    @tailwind utilities;

    @layer components {
      .input {
        @apply w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500;
      }
      .label {
        @apply block text-sm font-medium text-gray-700 mb-1;
      }
      .button {
        @apply flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
      }
      .button-secondary {
        @apply flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
      }
      .divider {
        @apply relative my-4;
      }
      .divider::before {
        @apply content-[''] absolute left-0 top-1/2 w-[45%] h-px bg-gray-300;
      }
      .divider::after {
        @apply content-[''] absolute right-0 top-1/2 w-[45%] h-px bg-gray-300;
      }
    }
    ```

### **Step 4: Create a Protected Route and a Dashboard Page**

Now for the crucial part: ensuring only logged-in users can access certain pages. We'll create a simple `/dashboard` page and protect it.

1.  **Create a ProtectedRoute component:** This component will check the auth state and redirect if the user is not logged in.
    *   Create the file: `src/components/ProtectedRoute.tsx`

    ```tsx
    // src/components/ProtectedRoute.tsx
    'use client';

    import { useEffect } from 'react';
    import { useRouter } from 'next/navigation';
    import { useAuth } from '@/context/AuthContext';

    const ProtectedRoute = ({ children }: { children: React.ReactNode }) => {
      const { user, loading } = useAuth();
      const router = useRouter();

      useEffect(() => {
        // Wait until the loading is finished before checking the user
        if (!loading && !user) {
          router.push('/login');
        }
      }, [user, loading, router]);

      // If loading, you can show a spinner or a blank page
      if (loading) {
        return <div>Loading...</div>; // Or a proper loading spinner component
      }

      // If the user is authenticated, render the children
      if (user) {
        return <>{children}</>;
      }

      // If not authenticated and not loading, return null (or redirect)
      // The useEffect will handle the redirect, but this prevents flashing the content.
      return null;
    };

    export default ProtectedRoute;
    ```

2.  **Create the Dashboard page:** This will be our main application page for authenticated users.
    *   Create the file: `src/app/dashboard/page.tsx`

    ```tsx
    // src/app/dashboard/page.tsx
    'use client';

    import ProtectedRoute from '@/components/ProtectedRoute';
    import { useAuth } from '@/context/AuthContext';

    function Dashboard() {
      const { user, logout } = useAuth();

      return (
        <div className="p-8">
          <div className="max-w-4xl mx-auto">
            <div className="flex justify-between items-center mb-8">
              <h1 className="text-3xl font-bold">Dashboard</h1>
              {user && (
                <div className="flex items-center gap-4">
                  <p className="text-gray-600">{user.email}</p>
                  <button onClick={logout} className="button">
                    Logout
                  </button>
                </div>
              )}
            </div>
            <div className="p-6 bg-white rounded-lg shadow-md">
              <h2 className="text-xl font-semibold">Welcome to your Expense Splitter!</h2>
              <p className="mt-2 text-gray-700">
                This is your protected dashboard. You can start creating groups and adding expenses here.
              </p>
            </div>
          </div>
        </div>
      );
    }

    // Wrap the Dashboard component with ProtectedRoute
    export default function DashboardPage() {
      return (
        <ProtectedRoute>
          <Dashboard />
        </ProtectedRoute>
      );
    }
    ```

3.  **Update the Home Page:** Let's make the root page (`/`) a simple landing page that directs users to login or the dashboard.
    *   Open `src/app/page.tsx` and replace its content.

    ```tsx
    // src/app/page.tsx
    import Link from 'next/link';

    export default function HomePage() {
      return (
        <main className="flex min-h-screen flex-col items-center justify-center p-24 bg-gray-50">
          <div className="text-center">
            <h1 className="text-4xl font-bold mb-4">Welcome to Expense Splitter</h1>
            <p className="text-lg text-gray-600 mb-8">
              The easiest way to split bills with friends and family.
            </p>
            <div className="space-x-4">
              <Link href="/login" className="button">
                Login
              </Link>
              <Link href="/dashboard" className="button-secondary">
                Go to Dashboard
              </Link>
            </div>
          </div>
        </main>
      );
    }
    ```

---

### **Summary and What's Next**

You have now successfully implemented a complete authentication flow!

*   **Global State:** `AuthContext` provides user status throughout the app.
*   **Sign Up/Login:** Users can create accounts with email/password or sign in with Google.
*   **Protected Routes:** The `/dashboard` route is now only accessible to logged-in users. Any attempt to access it while logged out will result in a redirect to the `/login` page.
*   **Logout:** The logout button on the dashboard securely signs the user out and redirects them.

You can now run your app (`npm run dev`) and test the entire flow. Try signing up, logging out, logging back in, and accessing `/dashboard` directly by typing it in the URL when you're logged out. You'll see the protection in action.

The next logical step is to start building the core features of the app, such as creating and managing expense groups.

**Metadata:**
```json
{
  "subtask_id": "user-auth",
  "title": "Implement User Authentication",
  "expertise": "Next.js, React, Firebase Authentication"
}
```

### Next.js, React, Firestore Specialist

With a solid authentication system and database schema in place, it's time to build the core group management functionality. Users need to be able to create groups to share expenses in, see a list of all the groups they belong to, and invite others to join.

We will update the dashboard to be the central hub for these actions. It will display a list of the user's groups and provide a way to create new ones.

---

### **Step 1: Create User Document in Firestore on Sign-Up**

Our schema relies on a `users` document for each authenticated user. However, Firebase Auth doesn't create this for us automatically. We need to ensure that whenever a user logs in for the first time, their corresponding document is created in our `users` collection. The best place to handle this is in our `AuthContext`.

1.  **Install Firestore:** If you haven't already, add the Firestore SDK to your project.
    ```bash
    npm install firebase
    ```

2.  **Update `AuthContext.tsx`:** Modify the `useEffect` hook to check for and create the user document.

    ```typescript
    // src/context/AuthContext.tsx
    'use client';

    import {
      ReactNode,
      createContext,
      useContext,
      useEffect,
      useState,
    } from 'react';
    import {
      User,
      onAuthStateChanged,
      signOut as firebaseSignOut,
    } from 'firebase/auth';
    import { auth, db } from '@/lib/firebase/config'; // Import db
    import { useRouter } from 'next/navigation';
    import { doc, getDoc, serverTimestamp, setDoc } from 'firebase/firestore'; // Import Firestore functions

    // ... (interface and createContext are the same)
    interface AuthContextType {
      user: User | null;
      loading: boolean;
      logout: () => Promise<void>;
    }
    const AuthContext = createContext<AuthContextType | undefined>(undefined);


    export const AuthProvider = ({ children }: { children: ReactNode }) => {
      const [user, setUser] = useState<User | null>(null);
      const [loading, setLoading] = useState(true);
      const router = useRouter();

      useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
          if (user) {
            // User is signed in, now check for/create Firestore doc
            const userDocRef = doc(db, 'users', user.uid);
            const userDocSnap = await getDoc(userDocRef);

            if (!userDocSnap.exists()) {
              // Create the user document if it doesn't exist
              await setDoc(userDocRef, {
                uid: user.uid,
                email: user.email,
                displayName: user.displayName || user.email?.split('@')[0], // Use a part of email as default
                photoURL: user.photoURL,
                createdAt: serverTimestamp(),
                groups: [], // Initialize with an empty groups array
              });
            }
            setUser(user);
          } else {
            setUser(null);
          }
          setLoading(false);
        });

        return () => unsubscribe();
      }, []);

      const logout = async () => {
        await firebaseSignOut(auth);
        router.push('/login');
      };

      const value = {
        user,
        loading,
        logout,
      };

      return (
        <AuthContext.Provider value={value}>
          {!loading && children}
        </AuthContext.Provider>
      );
    };

    // ... (useAuth hook is the same)
    export const useAuth = () => {
      const context = useContext(AuthContext);
      if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
      }
      return context;
    };
    ```

### **Step 2: Create Firestore Service Functions for Groups**

To keep our component logic clean, let's create a dedicated file for all Firestore interactions related to groups.

1.  **Install `nanoid`** for generating unique, short invite codes.
    ```bash
    npm install nanoid
    ```

2.  Create a new file: `src/lib/firebase/firestore.ts`.
3.  Add the following functions to manage group data.

    ```typescript
    // src/lib/firebase/firestore.ts
    import {
      doc,
      addDoc,
      collection,
      serverTimestamp,
      updateDoc,
      arrayUnion,
      getDoc,
      query,
      where,
      documentId,
      getDocs,
    } from 'firebase/firestore';
    import { db } from './config';
    import { User } from 'firebase/auth';
    import { customAlphabet } from 'nanoid';

    // Define the structure for a Group
    export interface Group {
      id: string;
      groupName: string;
      createdBy: string;
      createdAt: any; // Firestore Timestamp
      members: any[]; // Array of member objects
      inviteCode: string;
    }

    // Function to generate a unique 6-character invite code
    const generateInviteCode = () => {
      const nanoid = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', 6);
      return nanoid();
    };

    /**
     * Creates a new group in Firestore.
     * @param groupName The name of the new group.
     * @param user The user object of the creator.
     */
    export const createGroup = async (groupName: string, user: User) => {
      if (!groupName || !user) {
        throw new Error('Group name and user are required.');
      }

      // 1. Fetch the user's profile from Firestore to get displayName, etc.
      const userDocRef = doc(db, 'users', user.uid);
      const userDocSnap = await getDoc(userDocRef);

      if (!userDocSnap.exists()) {
        throw new Error('User profile not found in Firestore.');
      }
      const userData = userDocSnap.data();

      // 2. Create the new group document
      const groupDocRef = await addDoc(collection(db, 'groups'), {
        groupName,
        createdBy: user.uid,
        createdAt: serverTimestamp(),
        inviteCode: generateInviteCode(),
        members: [
          {
            uid: user.uid,
            email: userData.email,
            displayName: userData.displayName,
            photoURL: userData.photoURL,
            joinedAt: serverTimestamp(),
          },
        ],
      });

      // 3. Add the new group's ID to the user's `groups` array
      await updateDoc(userDocRef, {
        groups: arrayUnion(groupDocRef.id),
      });

      return groupDocRef.id;
    };

    /**
     * Fetches all groups a user belongs to.
     * @param userId The UID of the user.
     * @returns A promise that resolves to an array of group objects.
     */
    export const getUserGroups = async (userId: string): Promise<Group[]> => {
      if (!userId) return [];

      // 1. Get the user's document to find their group IDs
      const userDocRef = doc(db, 'users', userId);
      const userDocSnap = await getDoc(userDocRef);

      if (!userDocSnap.exists() || !userDocSnap.data().groups?.length) {
        return []; // User has no groups
      }

      const groupIds = userDocSnap.data().groups;

      // 2. Query the 'groups' collection for documents with those IDs
      const groupsQuery = query(
        collection(db, 'groups'),
        where(documentId(), 'in', groupIds)
      );
      const querySnapshot = await getDocs(groupsQuery);

      const groups = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Group[];

      return groups;
    };
    ```

### **Step 3: Build the Group Management UI Components**

Let's create the components for displaying the group list and the modal for creating a new group.

1.  **Create the `CreateGroupModal` component:**
    *   File: `src/components/groups/CreateGroupModal.tsx`

    ```tsx
    // src/components/groups/CreateGroupModal.tsx
    'use client';

    import { useState } from 'react';
    import { useAuth } from '@/context/AuthContext';
    import { createGroup } from '@/lib/firebase/firestore';

    interface CreateGroupModalProps {
      isOpen: boolean;
      onClose: () => void;
      onGroupCreated: () => void; // Callback to refresh group list
    }

    export default function CreateGroupModal({
      isOpen,
      onClose,
      onGroupCreated,
    }: CreateGroupModalProps) {
      const { user } = useAuth();
      const [groupName, setGroupName] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!user || !groupName.trim()) return;

        setIsLoading(true);
        setError(null);

        try {
          await createGroup(groupName, user);
          setGroupName('');
          onGroupCreated(); // Trigger refresh
          onClose(); // Close modal
        } catch (err: any) {
          setError(err.message);
        } finally {
          setIsLoading(false);
        }
      };

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h2 className="text-2xl font-bold mb-4">Create New Group</h2>
            <form onSubmit={handleSubmit}>
              <div className="mb-4">
                <label htmlFor="groupName" className="label">
                  Group Name
                </label>
                <input
                  id="groupName"
                  type="text"
                  value={groupName}
                  onChange={(e) => setGroupName(e.target.value)}
                  placeholder="e.g., Apartment Bills"
                  required
                  className="input"
                />
              </div>
              {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
              <div className="flex justify-end gap-4">
                <button
                  type="button"
                  onClick={onClose}
                  className="button-secondary"
                  disabled={isLoading}
                >
                  Cancel
                </button>
                <button type="submit" className="button" disabled={isLoading}>
                  {isLoading ? 'Creating...' : 'Create Group'}
                </button>
              </div>
            </form>
          </div>
        </div>
      );
    }
    ```

2.  **Create the `GroupList` component:**
    *   File: `src/components/groups/GroupList.tsx`

    ```tsx
    // src/components/groups/GroupList.tsx
    'use client';

    import { useAuth } from '@/context/AuthContext';
    import { Group, getUserGroups } from '@/lib/firebase/firestore';
    import { useEffect, useState } from 'react';

    // A simple card component to display group info
    function GroupCard({ group }: { group: Group }) {
        const [showCode, setShowCode] = useState(false);

        const copyToClipboard = () => {
            navigator.clipboard.writeText(group.inviteCode).then(() => {
                alert('Invite code copied to clipboard!');
            });
        };

        return (
            <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200">
                <h3 className="text-xl font-semibold text-gray-800">{group.groupName}</h3>
                <p className="text-sm text-gray-500 mt-1">
                    {group.members.length} member{group.members.length !== 1 ? 's' : ''}
                </p>
                <div className="mt-4">
                    <button onClick={() => setShowCode(!showCode)} className="text-sm text-blue-600 hover:underline">
                        {showCode ? 'Hide' : 'Show'} Invite Code
                    </button>
                    {showCode && (
                        <div className="mt-2 p-2 bg-gray-100 rounded-md flex items-center justify-between">
                            <span className="font-mono text-lg tracking-widest">{group.inviteCode}</span>
                            <button onClick={copyToClipboard} className="text-sm button-secondary py-1 px-2">Copy</button>
                        </div>
                    )}
                </div>
            </div>
        );
    }

    export default function GroupList() {
      const { user } = useAuth();
      const [groups, setGroups] = useState<Group[]>([]);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);

      const fetchGroups = async () => {
        if (!user) return;
        setIsLoading(true);
        setError(null);
        try {
          const userGroups = await getUserGroups(user.uid);
          setGroups(userGroups);
        } catch (err: any) {
          setError('Failed to fetch groups.');
          console.error(err);
        } finally {
          setIsLoading(false);
        }
      };

      useEffect(() => {
        fetchGroups();
      }, [user]); // Refetch when user changes

      if (isLoading) {
        return <p>Loading groups...</p>;
      }

      if (error) {
        return <p className="text-red-500">{error}</p>;
      }

      return (
        <div>
          {groups.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {groups.map((group) => (
                <GroupCard key={group.id} group={group} />
              ))}
            </div>
          ) : (
            <div className="text-center py-10 px-6 bg-gray-50 rounded-lg">
              <h3 className="text-lg font-medium text-gray-800">No groups yet!</h3>
              <p className="text-gray-600 mt-1">
                Create a new group to start splitting expenses.
              </p>
            </div>
          )}
        </div>
      );
    }
    ```

### **Step 4: Integrate into the Dashboard Page**

Finally, let's update the main dashboard page to use our new components.

*   Open `src/app/dashboard/page.tsx` and replace its content:

    ```tsx
    // src/app/dashboard/page.tsx
    'use client';

    import { useState } from 'react';
    import ProtectedRoute from '@/components/ProtectedRoute';
    import { useAuth } from '@/context/AuthContext';
    import CreateGroupModal from '@/components/groups/CreateGroupModal';
    import GroupList from '@/components/groups/GroupList';

    function Dashboard() {
      const { user, logout } = useAuth();
      const [isModalOpen, setIsModalOpen] = useState(false);

      // This function will be passed to the modal to refresh the list
      const handleGroupCreated = () => {
        // A simple way to refresh is to re-mount the GroupList component.
        // We can force this by changing a key, but for now, we'll rely
        // on the user seeing the new group after a manual refresh or navigation.
        // A more advanced solution would use a state management library or context.
        // For now, we just close the modal. The GroupList will be stale until refresh.
        // To fix this, we'll pass the fetch function down.
        // Let's refactor GroupList to accept a trigger. This is getting complex.
        // A simpler approach: let's just re-render the whole page.
        // window.location.reload(); // This is a bit heavy-handed.
        // Let's modify GroupList to expose its fetch function.
        // A better approach: Let's just create a key for the GroupList.
      };

      return (
        <div className="min-h-screen bg-gray-50">
          <header className="bg-white shadow-sm">
            <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
              <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
              {user && (
                <div className="flex items-center gap-4">
                  <p className="text-gray-600 hidden sm:block">{user.email}</p>
                  <button onClick={logout} className="button-secondary">
                    Logout
                  </button>
                </div>
              )}
            </div>
          </header>

          <main className="py-8">
            <div className="max-w-7xl mx-auto sm:px-6 lg:px-8">
              <div className="px-4 sm:px-0 mb-6 flex justify-between items-center">
                <h2 className="text-xl font-semibold text-gray-800">Your Groups</h2>
                <button onClick={() => setIsModalOpen(true)} className="button">
                  + Create Group
                </button>
              </div>

              <div className="px-4 sm:px-0">
                <GroupList />
              </div>
            </div>
          </main>

          <CreateGroupModal
            isOpen={isModalOpen}
            onClose={() => setIsModalOpen(false)}
            onGroupCreated={() => {
              // The simplest way to refresh the list is to reload the page.
              // For a better UX, you'd use a state management tool or context.
              window.location.reload();
            }}
          />
        </div>
      );
    }

    // Wrap the Dashboard component with ProtectedRoute
    export default function DashboardPage() {
      return (
        <ProtectedRoute>
          <Dashboard />
        </ProtectedRoute>
      );
    }
    ```
    *Note: The `window.location.reload()` is a simple but effective way to ensure the group list is up-to-date after creation. In a larger application, you might use a state management library like Zustand or React Query to manage data fetching and re-validation more elegantly.*

---

### **Summary and What's Next**

You have now successfully implemented the core group management features:

*   **User Onboarding:** New users automatically get a corresponding document in the `users` collection in Firestore.
*   **Group Creation:** Logged-in users can open a modal and create a new group. The data is saved correctly in both the `groups` and `users` collections.
*   **Group Viewing:** The dashboard now fetches and displays a list of all groups the current user is a member of.
*   **Invite System:** Each group has a unique invite code that can be shown and copied, laying the groundwork for adding new members.

The next logical step is to make these group cards clickable, leading to a dedicated page for each group where users can view and add expenses.

**Metadata:**
```json
{
  "subtask_id": "group-management",
  "title": "Build Group Management Features",
  "expertise": "Next.js, React, Firestore"
}
```

### Next.js, React Forms, Firestore Specialist

With group management in place, the next critical step is allowing users to add and track expenses within those groups. We will create a dedicated page for each group where members can see a list of expenses and add new ones.

This involves:
1.  Creating a dynamic route and page for individual groups (`/group/[groupId]`).
2.  Updating our Firestore service functions to handle expense creation and retrieval.
3.  Building UI components for adding a new expense (a modal form) and listing existing expenses.
4.  Making the group cards on the dashboard link to their respective detail pages.

---

### **Step 1: Update Firestore Service Functions for Expenses**

First, let's extend our `firestore.ts` file with functions to manage expenses. We'll add an `Expense` interface and functions to add and get expenses for a specific group. We will store expenses in a subcollection within each group document for better data organization and querying performance.

1.  **Define the `Expense` interface and update `Group` interface:**
    In `src/lib/firebase/firestore.ts`, add the `Expense` interface. Also, add the `members` type definition for clarity.

    ```typescript
    // src/lib/firebase/firestore.ts

    // ... (imports)

    // Add Member type definition
    export interface Member {
        uid: string;
        email: string;
        displayName: string;
        photoURL: string;
        joinedAt: any;
    }

    export interface Group {
      id: string;
      groupName: string;
      createdBy: string;
      createdAt: any;
      members: Member[]; // Use the Member type
      inviteCode: string;
    }

    // Define the structure for an Expense
    export interface Expense {
        id: string;
        description: string;
        amount: number; // Stored in cents
        paidBy: string; // UID of the user who paid
        paidByDisplayName: string; // Denormalized for easy display
        groupId: string;
        createdAt: any; // Firestore Timestamp
        splitMethod: 'equally'; // For now, we only support 'equally'
        participants: {
            uid: string;
            amountOwed: number; // Stored in cents
        }[];
    }

    // ... (existing createGroup and getUserGroups functions)
    ```

2.  **Create `addExpenseToGroup` and `getGroupExpenses` functions:**
    Add these new functions to `src/lib/firebase/firestore.ts`.

    ```typescript
    // src/lib/firebase/firestore.ts
    import {
      // ... existing imports
      getDoc,
      query,
      where,
      documentId,
      getDocs,
      orderBy, // Add orderBy
      Timestamp, // Add Timestamp
    } from 'firebase/firestore';
    // ...

    /**
     * Fetches details for a single group.
     * @param groupId The ID of the group.
     * @returns A promise that resolves to the group object or null if not found.
     */
    export const getGroupDetails = async (groupId: string): Promise<Group | null> => {
        if (!groupId) return null;
        const groupDocRef = doc(db, 'groups', groupId);
        const groupDocSnap = await getDoc(groupDocRef);

        if (groupDocSnap.exists()) {
            return { id: groupDocSnap.id, ...groupDocSnap.data() } as Group;
        } else {
            return null;
        }
    };


    /**
     * Adds a new expense to a group's 'expenses' subcollection.
     * @param expenseData The data for the new expense.
     */
    export const addExpenseToGroup = async (expenseData: {
      description: string;
      amount: number; // Should be in dollars from the form
      paidBy: string;
      groupId: string;
      participantsUids: string[];
    }) => {
      const { description, amount, paidBy, groupId, participantsUids } = expenseData;

      if (!description || amount <= 0 || !paidBy || !groupId || participantsUids.length === 0) {
        throw new Error('Missing required expense data.');
      }

      // 1. Fetch the payer's display name
      const userDocRef = doc(db, 'users', paidBy);
      const userDocSnap = await getDoc(userDocRef);
      if (!userDocSnap.exists()) {
        throw new Error('Payer user not found.');
      }
      const paidByDisplayName = userDocSnap.data().displayName;

      // 2. Calculate the split
      const amountInCents = Math.round(amount * 100);
      const splitAmount = Math.round(amountInCents / participantsUids.length);
      const participants = participantsUids.map(uid => ({
          uid,
          amountOwed: splitAmount,
      }));

      // 3. Create the expense document in the subcollection
      const groupExpensesColRef = collection(db, 'groups', groupId, 'expenses');
      await addDoc(groupExpensesColRef, {
        description,
        amount: amountInCents,
        paidBy,
        paidByDisplayName,
        groupId,
        createdAt: serverTimestamp(),
        splitMethod: 'equally',
        participants,
      });
    };

    /**
     * Fetches all expenses for a given group, ordered by creation date.
     * @param groupId The ID of the group.
     * @returns A promise that resolves to an array of expense objects.
     */
    export const getGroupExpenses = async (groupId: string): Promise<Expense[]> => {
        if (!groupId) return [];

        const expensesQuery = query(
            collection(db, 'groups', groupId, 'expenses'),
            orderBy('createdAt', 'desc')
        );

        const querySnapshot = await getDocs(expensesQuery);

        const expenses = querySnapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data(),
        })) as Expense[];

        return expenses;
    };
    ```

### **Step 2: Update Group Cards to be Clickable Links**

Modify the `GroupCard` component in `src/components/groups/GroupList.tsx` to link to the new group detail page.

```tsx
// src/components/groups/GroupList.tsx
'use client';

import { useAuth } from '@/context/AuthContext';
import { Group, getUserGroups } from '@/lib/firebase/firestore';
import Link from 'next/link'; // Import Link
import { useEffect, useState } from 'react';

// A simple card component to display group info
function GroupCard({ group }: { group: Group }) {
  const [showCode, setShowCode] = useState(false);

  const copyToClipboard = () => {
    navigator.clipboard.writeText(group.inviteCode).then(() => {
      alert('Invite code copied to clipboard!');
    });
  };

  return (
    // Wrap the entire card content in a Link component
    <Link href={`/group/${group.id}`} className="block hover:shadow-lg transition-shadow duration-200">
      <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200 h-full flex flex-col justify-between">
        <div>
          <h3 className="text-xl font-semibold text-gray-800">{group.groupName}</h3>
          <p className="text-sm text-gray-500 mt-1">
            {group.members.length} member{group.members.length !== 1 ? 's' : ''}
          </p>
        </div>
        <div className="mt-4">
          <button
            onClick={(e) => {
              e.preventDefault(); // Prevent link navigation
              setShowCode(!showCode);
            }}
            className="text-sm text-blue-600 hover:underline"
          >
            {showCode ? 'Hide' : 'Show'} Invite Code
          </button>
          {showCode && (
            <div className="mt-2 p-2 bg-gray-100 rounded-md flex items-center justify-between">
              <span className="font-mono text-lg tracking-widest">{group.inviteCode}</span>
              <button
                onClick={(e) => {
                  e.preventDefault(); // Prevent link navigation
                  copyToClipboard();
                }}
                className="text-sm button-secondary py-1 px-2"
              >
                Copy
              </button>
            </div>
          )}
        </div>
      </div>
    </Link>
  );
}

// ... (rest of GroupList component is the same)
export default function GroupList() {
    // ...
}
```

### **Step 3: Build the UI Components for Expenses**

We need a modal for adding expenses and a component to list them.

1.  **Create `AddExpenseModal.tsx`:**
    *   File: `src/components/expenses/AddExpenseModal.tsx`

    ```tsx
    // src/components/expenses/AddExpenseModal.tsx
    'use client';

    import { useState } from 'react';
    import { useAuth } from '@/context/AuthContext';
    import { addExpenseToGroup } from '@/lib/firebase/firestore';
    import { Member } from '@/lib/firebase/firestore';

    interface AddExpenseModalProps {
      isOpen: boolean;
      onClose: () => void;
      onExpenseAdded: () => void;
      groupId: string;
      members: Member[];
    }

    export default function AddExpenseModal({
      isOpen,
      onClose,
      onExpenseAdded,
      groupId,
      members,
    }: AddExpenseModalProps) {
      const { user } = useAuth();
      const [description, setDescription] = useState('');
      const [amount, setAmount] = useState('');
      const [paidBy, setPaidBy] = useState(user?.uid || '');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      // For this simple version, we assume the expense is split among all members
      const participantsUids = members.map(m => m.uid);

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!user || !description.trim() || !amount || !paidBy) return;

        const numericAmount = parseFloat(amount);
        if (isNaN(numericAmount) || numericAmount <= 0) {
          setError('Please enter a valid amount.');
          return;
        }

        setIsLoading(true);
        setError(null);

        try {
          await addExpenseToGroup({
            description,
            amount: numericAmount,
            paidBy,
            groupId,
            participantsUids,
          });
          setDescription('');
          setAmount('');
          onExpenseAdded();
          onClose();
        } catch (err: any) {
          setError(err.message);
        } finally {
          setIsLoading(false);
        }
      };

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h2 className="text-2xl font-bold mb-4">Add New Expense</h2>
            <form onSubmit={handleSubmit}>
              <div className="mb-4">
                <label htmlFor="description" className="label">Description</label>
                <input
                  id="description" type="text" value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="e.g., Groceries" required className="input"
                />
              </div>
              <div className="mb-4">
                <label htmlFor="amount" className="label">Amount ($)</label>
                <input
                  id="amount" type="number" value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                  placeholder="0.00" required className="input"
                  step="0.01" min="0.01"
                />
              </div>
              <div className="mb-4">
                <label htmlFor="paidBy" className="label">Paid by</label>
                <select id="paidBy" value={paidBy} onChange={(e) => setPaidBy(e.target.value)} className="input">
                  {members.map((member) => (
                    <option key={member.uid} value={member.uid}>
                      {member.displayName}
                    </option>
                  ))}
                </select>
              </div>
              <p className="text-sm text-gray-500 mb-4">
                This will be split equally among all {members.length} members.
              </p>
              {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
              <div className="flex justify-end gap-4">
                <button type="button" onClick={onClose} className="button-secondary" disabled={isLoading}>
                  Cancel
                </button>
                <button type="submit" className="button" disabled={isLoading}>
                  {isLoading ? 'Adding...' : 'Add Expense'}
                </button>
              </div>
            </form>
          </div>
        </div>
      );
    }
    ```

2.  **Create `ExpenseList.tsx`:**
    *   File: `src/components/expenses/ExpenseList.tsx`

    ```tsx
    // src/components/expenses/ExpenseList.tsx
    'use client';

    import { Expense, getGroupExpenses } from '@/lib/firebase/firestore';
    import { useEffect, useState } from 'react';
    import { Timestamp } from 'firebase/firestore';

    function ExpenseCard({ expense }: { expense: Expense }) {
        // Function to format Firestore Timestamp to a readable date
        const formatDate = (timestamp: Timestamp) => {
            if (!timestamp) return 'Date not available';
            return timestamp.toDate().toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
            });
        };

        return (
            <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 flex items-center justify-between">
                <div>
                    <p className="text-xs text-gray-500">{formatDate(expense.createdAt)}</p>
                    <p className="text-lg font-medium text-gray-800">{expense.description}</p>
                    <p className="text-sm text-gray-600">
                        Paid by {expense.paidByDisplayName}
                    </p>
                </div>
                <div className="text-right">
                    <p className="text-xl font-semibold text-gray-900">
                        ${(expense.amount / 100).toFixed(2)}
                    </p>
                    <p className="text-xs text-gray-500">
                        Split among {expense.participants.length} people
                    </p>
                </div>
            </div>
        );
    }


    export default function ExpenseList({ groupId, refreshTrigger }: { groupId: string, refreshTrigger: number }) {
      const [expenses, setExpenses] = useState<Expense[]>([]);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);

      useEffect(() => {
        const fetchExpenses = async () => {
          if (!groupId) return;
          setIsLoading(true);
          setError(null);
          try {
            const groupExpenses = await getGroupExpenses(groupId);
            setExpenses(groupExpenses);
          } catch (err) {
            setError('Failed to fetch expenses.');
            console.error(err);
          } finally {
            setIsLoading(false);
          }
        };

        fetchExpenses();
      }, [groupId, refreshTrigger]); // Refetch when groupId or the trigger changes

      if (isLoading) {
        return <p>Loading expenses...</p>;
      }

      if (error) {
        return <p className="text-red-500">{error}</p>;
      }

      return (
        <div>
          {expenses.length > 0 ? (
            <div className="space-y-4">
              {expenses.map((expense) => (
                <ExpenseCard key={expense.id} expense={expense} />
              ))}
            </div>
          ) : (
            <div className="text-center py-10 px-6 bg-gray-50 rounded-lg">
              <h3 className="text-lg font-medium text-gray-800">No expenses yet!</h3>
              <p className="text-gray-600 mt-1">
                Add an expense to get started.
              </p>
            </div>
          )}
        </div>
      );
    }
    ```

### **Step 4: Create the Group Detail Page**

Finally, create the dynamic page that brings everything together.

*   Create the file `src/app/group/[groupId]/page.tsx`:

    ```tsx
    // src/app/group/[groupId]/page.tsx
    'use client';

    import { useEffect, useState } from 'react';
    import { useParams, useRouter } from 'next/navigation';
    import ProtectedRoute from '@/components/ProtectedRoute';
    import { useAuth } from '@/context/AuthContext';
    import { Group, getGroupDetails } from '@/lib/firebase/firestore';
    import AddExpenseModal from '@/components/expenses/AddExpenseModal';
    import ExpenseList from '@/components/expenses/ExpenseList';
    import Link from 'next/link';

    function GroupDetailPage() {
      const { user } = useAuth();
      const router = useRouter();
      const params = useParams();
      const groupId = params.groupId as string;

      const [group, setGroup] = useState<Group | null>(null);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [refreshTrigger, setRefreshTrigger] = useState(0);

      useEffect(() => {
        if (!groupId || !user) return;

        const fetchGroupData = async () => {
          setIsLoading(true);
          setError(null);
          try {
            const groupDetails = await getGroupDetails(groupId);
            if (!groupDetails) {
              setError('Group not found.');
              return;
            }
            // Security check: ensure the current user is a member of this group
            const isMember = groupDetails.members.some(member => member.uid === user.uid);
            if (!isMember) {
              setError('You are not a member of this group.');
              // Optional: redirect them
              // router.push('/dashboard');
              return;
            }
            setGroup(groupDetails);
          } catch (err) {
            setError('Failed to load group details.');
            console.error(err);
          } finally {
            setIsLoading(false);
          }
        };

        fetchGroupData();
      }, [groupId, user, router]);

      const handleExpenseAdded = () => {
        // Increment the trigger to force ExpenseList to refetch data
        setRefreshTrigger(prev => prev + 1);
      };

      if (isLoading) {
        return <div className="p-8">Loading group...</div>;
      }
      if (error) {
        return <div className="p-8 text-red-500">{error}</div>;
      }
      if (!group) {
        return <div className="p-8">Group not found.</div>;
      }

      return (
        <div className="min-h-screen bg-gray-50">
          <header className="bg-white shadow-sm">
            <div className="max-w-4xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
              <div className="flex items-center gap-4">
                <Link href="/dashboard" className="text-blue-600 hover:underline">
                    &larr; Back to Dashboard
                </Link>
              </div>
              <h1 className="text-3xl font-bold text-gray-900 mt-2">{group.groupName}</h1>
            </div>
          </header>

          <main className="py-8">
            <div className="max-w-4xl mx-auto sm:px-6 lg:px-8">
              <div className="px-4 sm:px-0 mb-6 flex justify-between items-center">
                <h2 className="text-xl font-semibold text-gray-800">Expenses</h2>
                <button onClick={() => setIsModalOpen(true)} className="button">
                  + Add Expense
                </button>
              </div>
              <div className="px-4 sm:px-0">
                <ExpenseList groupId={group.id} refreshTrigger={refreshTrigger} />
              </div>
            </div>
          </main>

          {isModalOpen && (
            <AddExpenseModal
              isOpen={isModalOpen}
              onClose={() => setIsModalOpen(false)}
              onExpenseAdded={handleExpenseAdded}
              groupId={group.id}
              members={group.members}
            />
          )}
        </div>
      );
    }

    export default function GroupPage() {
      return (
        <ProtectedRoute>
          <GroupDetailPage />
        </ProtectedRoute>
      );
    }
    ```

---

### **Summary**

You have now implemented the complete flow for creating and viewing expenses within a group.

*   **Data Structure:** Expenses are stored in a subcollection under each group for efficient querying.
*   **Navigation:** Users can click on a group from their dashboard to navigate to a dedicated page for that group.
*   **Expense Creation:** A modal form allows users to add a new expense, specifying the description, amount, and who paid. For now, the cost is split equally among all members.
*   **Expense Tracking:** The group page displays a list of all expenses, showing key details like the description, amount, and payer. The list automatically refreshes when a new expense is added.
*   **Security:** A basic check is in place to ensure only group members can view the group's details.

The next step is to calculate and display the balances, showing who owes whom within the group.

**Metadata:**
```json
{
  "subtask_id": "expense-creation",
  "title": "Implement Expense Creation and Tracking",
  "expertise": "Next.js, React Forms, Firestore"
}
```

### Firebase Storage, React File Handling Specialist

Excellent, with expense creation and tracking in place, let's enhance it by adding the ability to upload and attach receipts. This is a perfect use case for Firebase Storage.

We will integrate Firebase Storage to handle image uploads. When a user adds an expense, they'll have an option to attach a receipt image. This image will be uploaded to a secure folder in your Storage bucket, and its public URL will be saved with the expense data in Firestore.

---

### **Step 1: Enable and Configure Firebase Storage**

Before writing any code, you need to enable Firebase Storage in your project.

1.  Go to your [Firebase Console](https://console.firebase.google.com/).
2.  Select your project.
3.  In the left-hand navigation pane, go to **Storage**.
4.  Click **"Get started"**.
5.  Follow the prompts to set up your storage bucket. When asked about Security Rules, choose **"Start in production mode"**. We will update the rules shortly.
6.  Select a location for your bucket (choose one close to your users).

#### **Update Storage Security Rules**

For security, we need to define rules for who can read and write files. Go to the **Rules** tab in the Firebase Storage section. Replace the default rules with the following:

```javascript
// Firebase Storage Security Rules
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
    // Match any file path for receipts
    // receipts/{groupId}/{fileName}
    match /receipts/{groupId}/{fileName} {
      // Allow read access to anyone with the URL (standard for displaying images)
      allow read;
      
      // Allow write (create, update) access only if the user is authenticated
      // A more robust rule would check if the user is a member of {groupId}
      // but for now, we'll keep it simple.
      allow write: if request.auth != null;
    }
  }
}
```

Click **Publish** to save your new rules. These rules allow any authenticated user to upload receipts and allow anyone with the link to view them.

---

### **Step 2: Create a Firebase Storage Service**

Let's create a dedicated file for our storage-related functions to keep our code organized.

1.  **Install `uuid` for generating unique file names:**
    This prevents users from overwriting each other's files if they happen to upload a file with the same name (e.g., `receipt.jpg`).

    ```bash
    npm install uuid
    npm install @types/uuid --save-dev
    ```

2.  **Create the storage service file:**
    *   File: `src/lib/firebase/storage.ts`

    ```typescript
    // src/lib/firebase/storage.ts
    import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';
    import { v4 as uuidv4 } from 'uuid';
    import { app } from './firebase'; // Your initialized Firebase app

    const storage = getStorage(app);

    /**
     * Uploads a receipt image to Firebase Storage.
     * @param file The image file to upload.
     * @param groupId The ID of the group this receipt belongs to.
     * @returns A promise that resolves with the public download URL of the uploaded file.
     */
    export const uploadReceipt = async (file: File, groupId: string): Promise<string> => {
        if (!file) {
            throw new Error("No file provided for upload.");
        }
        if (!groupId) {
            throw new Error("Group ID is required for upload.");
        }

        // Create a unique file name to avoid collisions
        const fileExtension = file.name.split('.').pop();
        const uniqueFileName = `${uuidv4()}.${fileExtension}`;

        // Create a reference to the file path in Storage
        const storageRef = ref(storage, `receipts/${groupId}/${uniqueFileName}`);

        try {
            // Upload the file
            const snapshot = await uploadBytes(storageRef, file);

            // Get the public download URL
            const downloadURL = await getDownloadURL(snapshot.ref);

            return downloadURL;
        } catch (error) {
            console.error("Error uploading file:", error);
            throw new Error("Failed to upload receipt. Please try again.");
        }
    };
    ```

---

### **Step 3: Update Firestore Interface and Function**

Now, we'll modify our Firestore logic to accommodate the new `receiptUrl` field.

1.  **Update the `Expense` interface:**
    In `src/lib/firebase/firestore.ts`, add the optional `receiptUrl` field.

    ```typescript
    // src/lib/firebase/firestore.ts

    // ... (imports and other interfaces)

    export interface Expense {
        id: string;
        description: string;
        amount: number; // Stored in cents
        paidBy: string; // UID of the user who paid
        paidByDisplayName:string;
        groupId: string;
        createdAt: any; // Firestore Timestamp
        splitMethod: 'equally';
        receiptUrl?: string; // <-- Add this optional field
        participants: {
            uid: string;
            amountOwed: number; // Stored in cents
        }[];
    }
    ```

2.  **Update the `addExpenseToGroup` function:**
    Modify the function to accept the `receiptUrl` and save it to the document.

    ```typescript
    // src/lib/firebase/firestore.ts

    // ... (imports)

    /**
     * Adds a new expense to a group's 'expenses' subcollection.
     * @param expenseData The data for the new expense.
     */
    export const addExpenseToGroup = async (expenseData: {
      description: string;
      amount: number; // Should be in dollars from the form
      paidBy: string;
      groupId: string;
      participantsUids: string[];
      receiptUrl?: string; // <-- Add optional parameter
    }) => {
      // Destructure the new receiptUrl property
      const { description, amount, paidBy, groupId, participantsUids, receiptUrl } = expenseData;

      if (!description || amount <= 0 || !paidBy || !groupId || participantsUids.length === 0) {
        throw new Error('Missing required expense data.');
      }

      // ... (user lookup and split calculation logic remains the same)
      const userDocRef = doc(db, 'users', paidBy);
      const userDocSnap = await getDoc(userDocRef);
      if (!userDocSnap.exists()) {
        throw new Error('Payer user not found.');
      }
      const paidByDisplayName = userDocSnap.data().displayName;

      const amountInCents = Math.round(amount * 100);
      const splitAmount = Math.round(amountInCents / participantsUids.length);
      const participants = participantsUids.map(uid => ({
          uid,
          amountOwed: splitAmount,
      }));

      // Create the expense document in the subcollection
      const groupExpensesColRef = collection(db, 'groups', groupId, 'expenses');
      await addDoc(groupExpensesColRef, {
        description,
        amount: amountInCents,
        paidBy,
        paidByDisplayName,
        groupId,
        createdAt: serverTimestamp(),
        splitMethod: 'equally',
        participants,
        receiptUrl: receiptUrl || null, // <-- Add the URL to the document
      });
    };

    // ... (rest of the file)
    ```

---

### **Step 4: Update the UI Components**

Let's modify the modal to include a file input and the expense card to display a link to the receipt.

1.  **Modify `AddExpenseModal.tsx`:**
    We'll add state to hold the selected file, a file input field, and update the `handleSubmit` logic to perform the upload before creating the expense document.

    ```tsx
    // src/components/expenses/AddExpenseModal.tsx
    'use client';

    import { useState } from 'react';
    import { useAuth } from '@/context/AuthContext';
    import { addExpenseToGroup, Member } from '@/lib/firebase/firestore';
    import { uploadReceipt } from '@/lib/firebase/storage'; // <-- Import upload function

    interface AddExpenseModalProps {
      // ... (props are the same)
    }

    export default function AddExpenseModal({
      isOpen,
      onClose,
      onExpenseAdded,
      groupId,
      members,
    }: AddExpenseModalProps) {
      const { user } = useAuth();
      const [description, setDescription] = useState('');
      const [amount, setAmount] = useState('');
      const [paidBy, setPaidBy] = useState(user?.uid || '');
      const [receiptFile, setReceiptFile] = useState<File | null>(null); // <-- State for file
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const participantsUids = members.map(m => m.uid);

      const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
          setReceiptFile(e.target.files[0]);
        }
      };

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        // ... (validation is the same)
        if (!user || !description.trim() || !amount || !paidBy) return;
        const numericAmount = parseFloat(amount);
        if (isNaN(numericAmount) || numericAmount <= 0) {
          setError('Please enter a valid amount.');
          return;
        }

        setIsLoading(true);
        setError(null);

        try {
          let receiptUrl = '';
          // 1. If a file is selected, upload it first
          if (receiptFile) {
            receiptUrl = await uploadReceipt(receiptFile, groupId);
          }

          // 2. Add expense data (including the URL) to Firestore
          await addExpenseToGroup({
            description,
            amount: numericAmount,
            paidBy,
            groupId,
            participantsUids,
            receiptUrl, // Pass the URL
          });

          // Reset form and close modal
          setDescription('');
          setAmount('');
          setReceiptFile(null);
          onExpenseAdded();
          onClose();
        } catch (err: any) {
          setError(err.message);
        } finally {
          setIsLoading(false);
        }
      };

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h2 className="text-2xl font-bold mb-4">Add New Expense</h2>
            <form onSubmit={handleSubmit}>
              {/* Description, Amount, Paid By fields are the same */}
              <div className="mb-4">
                <label htmlFor="description" className="label">Description</label>
                <input id="description" type="text" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="e.g., Groceries" required className="input" />
              </div>
              <div className="mb-4">
                <label htmlFor="amount" className="label">Amount ($)</label>
                <input id="amount" type="number" value={amount} onChange={(e) => setAmount(e.target.value)} placeholder="0.00" required className="input" step="0.01" min="0.01" />
              </div>
              <div className="mb-4">
                <label htmlFor="paidBy" className="label">Paid by</label>
                <select id="paidBy" value={paidBy} onChange={(e) => setPaidBy(e.target.value)} className="input">
                  {members.map((member) => ( <option key={member.uid} value={member.uid}>{member.displayName}</option>))}
                </select>
              </div>

              {/* New File Input Field */}
              <div className="mb-4">
                <label htmlFor="receipt" className="label">Receipt (Optional)</label>
                <input
                  id="receipt" type="file" onChange={handleFileChange}
                  accept="image/png, image/jpeg, image/webp"
                  className="input file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                />
              </div>

              <p className="text-sm text-gray-500 mb-4">
                This will be split equally among all {members.length} members.
              </p>
              {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
              <div className="flex justify-end gap-4">
                <button type="button" onClick={onClose} className="button-secondary" disabled={isLoading}>
                  Cancel
                </button>
                <button type="submit" className="button" disabled={isLoading}>
                  {isLoading ? 'Saving...' : 'Add Expense'}
                </button>
              </div>
            </form>
          </div>
        </div>
      );
    }
    ```

2.  **Modify `ExpenseList.tsx`:**
    Update the `ExpenseCard` to conditionally render a "View Receipt" link.

    ```tsx
    // src/components/expenses/ExpenseList.tsx
    'use client';

    import { Expense, getGroupExpenses } from '@/lib/firebase/firestore';
    import { useEffect, useState } from 'react';
    import { Timestamp } from 'firebase/firestore';

    function ExpenseCard({ expense }: { expense: Expense }) {
        const formatDate = (timestamp: Timestamp) => {
            // ... (function is the same)
            if (!timestamp) return 'Date not available';
            return timestamp.toDate().toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
            });
        };

        return (
            <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 flex items-center justify-between">
                <div>
                    <p className="text-xs text-gray-500">{formatDate(expense.createdAt)}</p>
                    <p className="text-lg font-medium text-gray-800">{expense.description}</p>
                    <p className="text-sm text-gray-600">
                        Paid by {expense.paidByDisplayName}
                    </p>
                    {/* Conditionally render the receipt link */}
                    {expense.receiptUrl && (
                        <a
                            href={expense.receiptUrl}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-sm text-blue-600 hover:underline mt-1 inline-block font-medium"
                        >
                            View Receipt
                        </a>
                    )}
                </div>
                <div className="text-right">
                    <p className="text-xl font-semibold text-gray-900">
                        ${(expense.amount / 100).toFixed(2)}
                    </p>
                    <p className="text-xs text-gray-500">
                        Split among {expense.participants.length} people
                    </p>
                </div>
            </div>
        );
    }

    // The rest of the ExpenseList component remains the same
    export default function ExpenseList({ groupId, refreshTrigger }: { groupId: string, refreshTrigger: number }) {
        // ...
    }
    ```

---

### **Summary**

You have now successfully integrated Firebase Storage into the application.

*   **Firebase Storage:** You configured a Storage bucket and set up security rules to allow authenticated users to upload files.
*   **Upload Logic:** A dedicated `storage.ts` service now handles the logic for uploading files and generating a unique, secure URL.
*   **Data Model:** The `Expense` data structure in Firestore was updated to include an optional `receiptUrl`.
*   **User Interface:** The "Add Expense" modal now has a file input, and the expense list will display a link to view the receipt if one was attached.

This feature adds significant value, allowing users to keep a visual record of their shared expenses. The next logical step would be to calculate and display the balances to clearly show who owes money to whom.

**Metadata:**
```json
{
  "subtask_id": "receipt-upload",
  "title": "Add Receipt Upload Functionality",
  "expertise": "Firebase Storage, React File Handling"
}
```

### Algorithm Design, Data Processing, Next.js Specialist

Here is the detailed implementation for developing the debt calculation and dashboard logic.

### **Approach**

To calculate and display who owes whom, we will:

1.  **Create a Calculation Utility:** A dedicated TypeScript module will contain the core logic for processing expenses and calculating balances. This keeps our business logic separate from our UI components.
2.  **Develop a Dashboard Component:** A new React component, `GroupDashboard`, will be created to visually represent the calculated balances and the simplified "settle up" plan.
3.  **Refactor the Group Detail Page:** The main page (`/group/[groupId]/page.tsx`) will be updated to fetch all necessary data (group details and expenses), run the calculation logic, and pass the results to the new dashboard component and the existing expense list.

---

### **Step 1: Create the Debt Calculation Utility**

This utility function will be the brain of our expense splitting logic. It will take the list of group members and all their expenses and return a clean summary of balances and debts.

1.  Create a new folder `src/utils`.
2.  Create a new file `src/utils/debtCalculator.ts`:

    ```typescript
    // src/utils/debtCalculator.ts
    import { Member, Expense } from '@/lib/firebase/firestore';

    // The structure for a member's final balance
    export interface Balance {
      uid: string;
      displayName: string;
      netBalance: number; // in cents. Positive means they are owed, negative means they owe.
    }

    // The structure for a simplified transaction to settle debts
    export interface SimplifiedDebt {
      from: string; // UID of the person who owes
      fromName: string;
      to: string;   // UID of the person to be paid
      toName: string;
      amount: number; // in cents
    }

    /**
     * Calculates the net balance for each member and a simplified list of transactions to settle up.
     * @param members - Array of group members.
     * @param expenses - Array of all expenses in the group.
     * @returns An object containing member balances and simplified debts.
     */
    export function calculateBalances(members: Member[], expenses: Expense[]): { balances: Balance[], simplifiedDebts: SimplifiedDebt[] } {
      const balancesMap = new Map<string, number>();
      members.forEach(member => balancesMap.set(member.uid, 0));

      // 1. Tally up total paid vs. total owed for each member
      expenses.forEach(expense => {
        // The person who paid gets credited the full amount
        const payerBalance = balancesMap.get(expense.paidBy) || 0;
        balancesMap.set(expense.paidBy, payerBalance + expense.amount);

        // Each participant gets debited their share of the cost
        expense.participants.forEach(participant => {
          const participantBalance = balancesMap.get(participant.uid) || 0;
          balancesMap.set(participant.uid, participantBalance - participant.amountOwed);
        });
      });

      // 2. Convert the map into a more usable array of Balance objects
      const finalBalances: Balance[] = members.map(member => ({
        uid: member.uid,
        displayName: member.displayName,
        netBalance: balancesMap.get(member.uid) || 0,
      }));

      // 3. Calculate the simplified list of who-owes-whom
      const simplifiedDebts = simplifyDebts(finalBalances);

      return { balances: finalBalances, simplifiedDebts };
    }

    /**
     * Takes a list of balances and computes the minimum number of transactions to settle all debts.
     * @param balances - The array of final balances for each member.
     * @returns An array of simplified debt transactions.
     */
    function simplifyDebts(balances: Balance[]): SimplifiedDebt[] {
      // Separate members into those who are owed money (creditors) and those who owe (debtors)
      const debtors = balances
        .filter(b => b.netBalance < 0)
        .map(b => ({ ...b, netBalance: -b.netBalance })); // Make balances positive for easier math

      const creditors = balances.filter(b => b.netBalance > 0);

      const transactions: SimplifiedDebt[] = [];

      let debtorIndex = 0;
      let creditorIndex = 0;

      // Loop until all debts or credits are cleared
      while (debtorIndex < debtors.length && creditorIndex < creditors.length) {
        const debtor = debtors[debtorIndex];
        const creditor = creditors[creditorIndex];
        const amountToTransfer = Math.min(debtor.netBalance, creditor.netBalance);

        // Create a transaction if the amount is non-trivial
        if (amountToTransfer > 0.5) { // Use a small threshold to avoid floating point dust
            transactions.push({
              from: debtor.uid,
              fromName: debtor.displayName,
              to: creditor.uid,
              toName: creditor.displayName,
              amount: Math.round(amountToTransfer),
            });
        }

        // Subtract the transferred amount from both parties
        debtor.netBalance -= amountToTransfer;
        creditor.netBalance -= amountToTransfer;

        // If a debtor has paid off their full amount, move to the next debtor
        if (debtor.netBalance < 0.5) {
          debtorIndex++;
        }
        // If a creditor has been fully paid, move to the next creditor
        if (creditor.netBalance < 0.5) {
          creditorIndex++;
        }
      }

      return transactions;
    }
    ```

### **Step 2: Create the Group Dashboard UI Component**

This component will display the summary of balances and the settlement plan.

1.  Create a new folder `src/components/dashboard`.
2.  Create a new file `src/components/dashboard/GroupDashboard.tsx`:

    ```tsx
    // src/components/dashboard/GroupDashboard.tsx
    'use client';

    import { useAuth } from '@/context/AuthContext';
    import { Balance, SimplifiedDebt } from '@/utils/debtCalculator';

    interface GroupDashboardProps {
      balances: Balance[];
      debts: SimplifiedDebt[];
    }

    // Helper to format cents into a currency string (e.g., 1234 -> "$12.34")
    const formatCurrency = (amountInCents: number) => {
      const dollars = amountInCents / 100;
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(dollars);
    };

    export default function GroupDashboard({ balances, debts }: GroupDashboardProps) {
      const { user } = useAuth();

      return (
        <div className="bg-white p-6 rounded-lg shadow-md border border-gray-200 mb-8">
          <h2 className="text-2xl font-bold text-gray-800 mb-4">Group Summary</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
            {/* Column 1: Member Balances */}
            <div>
              <h3 className="text-lg font-semibold mb-3">Balances</h3>
              <ul className="space-y-2">
                {balances.map(balance => {
                  const isCurrentUser = balance.uid === user?.uid;
                  const isOwed = balance.netBalance > 0;
                  const isOwing = balance.netBalance < 0;

                  let text = 'is settled up';
                  let textColor = 'text-gray-500';
                  if (isOwed) {
                    text = `is owed ${formatCurrency(balance.netBalance)}`;
                    textColor = 'text-green-600';
                  } else if (isOwing) {
                    text = `owes ${formatCurrency(Math.abs(balance.netBalance))}`;
                    textColor = 'text-red-600';
                  }

                  return (
                    <li key={balance.uid} className={`flex justify-between items-center p-2 rounded ${isCurrentUser ? 'bg-blue-50' : ''}`}>
                      <span className={`font-medium ${isCurrentUser ? 'text-blue-800' : 'text-gray-700'}`}>
                        {isCurrentUser ? 'You' : balance.displayName}
                      </span>
                      <span className={`font-semibold ${textColor}`}>
                        {text}
                      </span>
                    </li>
                  );
                })}
              </ul>
            </div>

            {/* Column 2: Settlement Plan */}
            <div>
              <h3 className="text-lg font-semibold mb-3">How to Settle Up</h3>
              {debts.length > 0 ? (
                <ul className="space-y-3">
                  {debts.map((debt, index) => (
                    <li key={index} className="flex items-center gap-3 text-gray-800">
                      <span className="font-medium">{debt.fromName}</span>
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 8l4 4m0 0l-4 4m4-4H3" /></svg>
                      <span className="font-medium">{debt.toName}</span>
                      <span className="ml-auto font-bold text-blue-700">
                        {formatCurrency(debt.amount)}
                      </span>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-600 italic">Everyone is settled up!</p>
              )}
            </div>
          </div>
        </div>
      );
    }
    ```

### **Step 3: Refactor the Group Detail Page and Expense List**

Now, we'll modify the group detail page to orchestrate the data fetching and calculation. The `ExpenseList` component will also be simplified to just display data it receives via props.

1.  **Update `ExpenseList.tsx` to be a "dumb" component:**
    Modify `src/components/expenses/ExpenseList.tsx` to remove its data-fetching logic.

    ```tsx
    // src/components/expenses/ExpenseList.tsx
    'use client';

    import { Expense } from '@/lib/firebase/firestore';
    import { Timestamp } from 'firebase/firestore';

    function ExpenseCard({ expense }: { expense: Expense }) {
      const formatDate = (timestamp: Timestamp) => {
        if (!timestamp) return 'Date not available';
        return timestamp.toDate().toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
        });
      };

      return (
        <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 flex items-center justify-between">
          <div>
            <p className="text-xs text-gray-500">{formatDate(expense.createdAt)}</p>
            <p className="text-lg font-medium text-gray-800">{expense.description}</p>
            <p className="text-sm text-gray-600">
              Paid by {expense.paidByDisplayName}
            </p>
          </div>
          <div className="text-right">
            <p className="text-xl font-semibold text-gray-900">
              ${(expense.amount / 100).toFixed(2)}
            </p>
            <p className="text-xs text-gray-500">
              Split among {expense.participants.length} people
            </p>
          </div>
        </div>
      );
    }

    // This component now just receives the expenses array as a prop
    export default function ExpenseList({ expenses }: { expenses: Expense[] }) {
      if (expenses.length === 0) {
        return (
          <div className="text-center py-10 px-6 bg-gray-50 rounded-lg">
            <h3 className="text-lg font-medium text-gray-800">No expenses yet!</h3>
            <p className="text-gray-600 mt-1">
              Add an expense to get started.
            </p>
          </div>
        );
      }

      return (
        <div className="space-y-4">
          {expenses.map((expense) => (
            <ExpenseCard key={expense.id} expense={expense} />
          ))}
        </div>
      );
    }
    ```

2.  **Update the Group Detail Page (`/group/[groupId]/page.tsx`)**
    This page will now fetch both group details and expenses, perform the balance calculation, and pass the data down to the `GroupDashboard` and `ExpenseList` components.

    ```tsx
    // src/app/group/[groupId]/page.tsx
    'use client';

    import { useEffect, useState } from 'react';
    import { useParams, useRouter } from 'next/navigation';
    import Link from 'next/link';
    import ProtectedRoute from '@/components/ProtectedRoute';
    import { useAuth } from '@/context/AuthContext';
    import { Group, Expense, getGroupDetails, getGroupExpenses } from '@/lib/firebase/firestore';
    import AddExpenseModal from '@/components/expenses/AddExpenseModal';
    import ExpenseList from '@/components/expenses/ExpenseList';
    import GroupDashboard from '@/components/dashboard/GroupDashboard';
    import { calculateBalances, Balance, SimplifiedDebt } from '@/utils/debtCalculator';

    function GroupDetailPage() {
      const { user } = useAuth();
      const router = useRouter();
      const params = useParams();
      const groupId = params.groupId as string;

      const [group, setGroup] = useState<Group | null>(null);
      const [expenses, setExpenses] = useState<Expense[]>([]);
      const [balances, setBalances] = useState<Balance[]>([]);
      const [debts, setDebts] = useState<SimplifiedDebt[]>([]);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [refreshTrigger, setRefreshTrigger] = useState(0);

      useEffect(() => {
        if (!groupId || !user) return;

        const fetchGroupData = async () => {
          setIsLoading(true);
          setError(null);
          try {
            // Fetch group details and expenses in parallel for efficiency
            const [groupDetails, groupExpenses] = await Promise.all([
              getGroupDetails(groupId),
              getGroupExpenses(groupId),
            ]);

            if (!groupDetails) {
              setError('Group not found.');
              setIsLoading(false);
              return;
            }

            const isMember = groupDetails.members.some(member => member.uid === user.uid);
            if (!isMember) {
              setError('You are not a member of this group.');
              setIsLoading(false);
              return;
            }

            setGroup(groupDetails);
            setExpenses(groupExpenses);

            // Calculate balances once all data is fetched
            const { balances, simplifiedDebts } = calculateBalances(groupExpenses,
              groupDetails.members
            );
            setBalances(balances);
            setSimplifiedDebts(simplifiedDebts);

          } catch (err) {
            setError('Failed to load group data.');
            console.error(err);
          } finally {
            setIsLoading(false);
          }
        };

        fetchGroupData();
      }, [groupId, user, router, refreshTrigger]); // Add refreshTrigger to re-run on changes

      const handleExpenseAdded = () => {
        // Increment the trigger to force a full refetch of data and recalculation
        setRefreshTrigger(prev => prev + 1);
      };

      if (isLoading) {
        return <div className="p-8 text-center">Loading group details and expenses...</div>;
      }
      if (error) {
        return <div className="p-8 text-red-500 text-center">{error}</div>;
      }
      if (!group) {
        return <div className="p-8 text-center">Group not found.</div>;
      }

      return (
        <div className="min-h-screen bg-gray-50">
          <header className="bg-white shadow-sm">
            <div className="max-w-4xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
              <div className="flex items-center gap-4">
                <Link href="/dashboard" className="text-blue-600 hover:underline">
                    &larr; Back to Dashboard
                </Link>
              </div>
              <h1 className="text-3xl font-bold text-gray-900 mt-2">{group.groupName}</h1>
            </div>
          </header>

          <main className="py-8">
            <div className="max-w-4xl mx-auto sm:px-6 lg:px-8 space-y-8">
              {/* Balance Summary Section */}
              <div className="px-4 sm:px-0">
                <BalanceSummary debts={simplifiedDebts} members={group.members} />
              </div>

              {/* Expenses Section */}
              <div>
                <div className="px-4 sm:px-0 mb-6 flex justify-between items-center">
                  <h2 className="text-xl font-semibold text-gray-800">Expenses</h2>
                  <button onClick={() => setIsModalOpen(true)} className="button">
                    + Add Expense
                  </button>
                </div>
                <div className="px-4 sm:px-0">
                  {/* Pass expenses directly to avoid re-fetching */}
                  <ExpenseList expenses={expenses} isLoading={isLoading} />
                </div>
              </div>
            </div>
          </main>

          {isModalOpen && (
            <AddExpenseModal
              isOpen={isModalOpen}
              onClose={() => setIsModalOpen(false)}
              onExpenseAdded={handleExpenseAdded}
              groupId={group.id}
              members={group.members}
            />
          )}
        </div>
      );
    }

    export default function GroupPage() {
      return (
        <ProtectedRoute>
          <GroupDetailPage />
        </ProtectedRoute>
      );
    }
    ```

### **Step 2: Create the Debt Calculation Logic**

This is the core of this task. We'll create a new utility file to house the algorithm that calculates balances and simplifies debts.

*   Create a new file: `src/lib/debt-calculator.ts`

    ```typescript
    // src/lib/debt-calculator.ts

    import { Expense, Member } from './firebase/firestore';

    export interface Balance {
      uid: string;
      displayName: string;
      netBalance: number; // in cents. > 0 means they are owed money, < 0 means they owe money
    }

    export interface SimplifiedDebt {
      from: string; // UID of the person who owes
      to: string;   // UID of the person who is owed
      amount: number; // in cents
    }

    /**
     * Calculates net balances and simplifies debts for a group.
     * @param expenses An array of all expense objects for the group.
     * @param members An array of all member objects in the group.
     * @returns An object containing final balances and a list of simplified debt transactions.
     */
    export const calculateBalances = (
      expenses: Expense[],
      members: Member[]
    ): { balances: Balance[]; simplifiedDebts: SimplifiedDebt[] } => {
      if (!members || members.length === 0) {
        return { balances: [], simplifiedDebts: [] };
      }

      // Step 1: Calculate the net balance for each member
      const balanceMap = new Map<string, number>();
      members.forEach(member => balanceMap.set(member.uid, 0));

      expenses.forEach(expense => {
        // Credit the payer by the full amount of the expense
        const payerBalance = balanceMap.get(expense.paidBy) || 0;
        balanceMap.set(expense.paidBy, payerBalance + expense.amount);

        // Debit each participant by their share of the expense
        expense.participants.forEach(participant => {
          const participantBalance = balanceMap.get(participant.uid) || 0;
          balanceMap.set(participant.uid, participantBalance - participant.amountOwed);
        });
      });

      // Convert map to an array of Balance objects for easier processing
      const finalBalances: Balance[] = members.map(member => ({
        uid: member.uid,
        displayName: member.displayName,
        netBalance: Math.round(balanceMap.get(member.uid) || 0), // Round to avoid floating point issues
      }));

      // Step 2: Simplify the debts using a greedy algorithm
      const simplifiedDebts = simplifyDebts(finalBalances);

      return { balances: finalBalances, simplifiedDebts };
    };


    /**
     * Simplifies a list of balances into the minimum number of transactions.
     * @param balances An array of balance objects.
     * @returns An array of simplified debt objects.
     */
    function simplifyDebts(balances: Balance[]): SimplifiedDebt[] {
      // Create copies to avoid mutating the original array
      const debtors = balances.filter(b => b.netBalance < 0).map(b => ({ ...b }));
      const creditors = balances.filter(b => b.netBalance > 0).map(b => ({ ...b }));
      
      const transactions: SimplifiedDebt[] = [];

      // Loop until all debts are settled
      while (debtors.length > 0 && creditors.length > 0) {
        const debtor = debtors[0];
        const creditor = creditors[0];

        const amountToSettle = Math.min(Math.abs(debtor.netBalance), creditor.netBalance);

        // Create a transaction record
        transactions.push({
          from: debtor.uid,
          to: creditor.uid,
          amount: amountToSettle,
        });

        // Update balances
        debtor.netBalance += amountToSettle;
        creditor.netBalance -= amountToSettle;

        // If a member's balance is settled (or very close to 0), remove them from their respective list
        if (Math.abs(debtor.netBalance) < 1) { // Use a small threshold for cents
          debtors.shift();
        }
        if (Math.abs(creditor.netBalance) < 1) {
          creditors.shift();
        }
      }

      return transactions;
    };
    ```

### **Step 3: Create the Balance Summary UI Component**

This component will receive the calculated debts and display them in a user-friendly format.

*   Create a new file: `src/components/expenses/BalanceSummary.tsx`

    ```tsx
    // src/components/expenses/BalanceSummary.tsx
    'use client';

    import { Member } from '@/lib/firebase/firestore';
    import { SimplifiedDebt } from '@/lib/debt-calculator';

    interface BalanceSummaryProps {
      debts: SimplifiedDebt[];
      members: Member[];
    }

    export default function BalanceSummary({ debts, members }: BalanceSummaryProps) {
      // Create a map for quick lookup of member names by UID
      const memberMap = new Map(members.map(m => [m.uid, m.displayName]));

      if (debts.length === 0) {
        return (
          <div className="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-md" role="alert">
            <p className="font-bold">All Settled Up!</p>
            <p>There are no outstanding debts in the group.</p>
          </div>
        );
      }

      return (
        <div className="bg-white p-6 rounded-lg shadow-md border border-gray-200">
          <h3 className="text-xl font-semibold text-gray-800 mb-4">Who Owes Who</h3>
          <ul className="space-y-3">
            {debts.map((debt, index) => {
              const fromName = memberMap.get(debt.from) || 'Unknown User';
              const toName = memberMap.get(debt.to) || 'Unknown User';
              const amount = (debt.amount / 100).toFixed(2);

              return (
                <li key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                  <span className="text-gray-700">
                    <span className="font-semibold text-red-600">{fromName}</span> owes{' '}
                    <span className="font-semibold text-green-600">{toName}</span>
                  </span>
                  <span className="font-bold text-lg text-gray-900">
                    ${amount}
                  </span>
                </li>
              );
            })}
          </ul>
        </div>
      );
    }
    ```

### **Step 4: Refactor `ExpenseList` to be a Presentational Component**

To improve performance and simplify logic, we'll modify `ExpenseList` to no longer fetch its own data. Instead, it will receive the list of expenses as a prop from its parent, `GroupDetailPage`.

*   Update the file: `src/components/expenses/ExpenseList.tsx`

    ```tsx
    // src/components/expenses/ExpenseList.tsx
    'use client';

    import { Expense } from '@/lib/firebase/firestore';
    import { Timestamp } from 'firebase/firestore';

    function ExpenseCard({ expense }: { expense: Expense }) {
        const formatDate = (timestamp: Timestamp) => {
            if (!timestamp) return 'Date not available';
            return timestamp.toDate().toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
            });
        };

        return (
            <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 flex items-center justify-between">
                <div>
                    <p className="text-xs text-gray-500">{formatDate(expense.createdAt)}</p>
                    <p className="text-lg font-medium text-gray-800">{expense.description}</p>
                    <p className="text-sm text-gray-600">
                        Paid by {expense.paidByDisplayName}
                    </p>
                </div>
                <div className="text-right">
                    <p className="text-xl font-semibold text-gray-900">
                        ${(expense.amount / 100).toFixed(2)}
                    </p>
                    <p className="text-xs text-gray-500">
                        Split among {expense.participants.length} people
                    </p>
                </div>
            </div>
        );
    }

    // Refactored to accept expenses and loading state as props
    export default function ExpenseList({ expenses, isLoading }: { expenses: Expense[], isLoading: boolean }) {
      if (isLoading) {
        return <p>Loading expenses...</p>;
      }

      return (
        <div>
          {expenses.length > 0 ? (
            <div className="space-y-4">
              {expenses.map((expense) => (
                <ExpenseCard key={expense.id} expense={expense} />
              ))}
            </div>
          ) : (
            <div className="text-center py-10 px-6 bg-gray-50 rounded-lg">
              <h3 className="text-lg font-medium text-gray-800">No expenses yet!</h3>
              <p className="text-gray-600 mt-1">
                Add an expense to get started.
              </p>
            </div>
          )}
        </div>
      );
    }
    ```

---

### **Summary**

You have successfully implemented the debt calculation and dashboard logic.

*   **Core Algorithm:** A robust `calculateBalances` function in `src/lib/debt-calculator.ts` now processes all expenses to determine each member's net balance.
*   **Debt Simplification:** The algorithm includes a greedy approach to simplify debts, minimizing the number of transactions required to settle up (e.g., instead of A owes B $10 and B owes C $10, it calculates that A owes C $10).
*   **Integrated Dashboard:** The group detail page (`/group/[groupId]`) now fetches all necessary data, performs the calculations, and displays a clear "Who Owes Who" summary at the top using the new `BalanceSummary` component.
*   **Efficiency:** The `ExpenseList` component has been refactored to be a presentational component, preventing redundant data fetching and ensuring the entire page updates atomically when a new expense is added.

The application now provides the core value of an expense splitter: clarity on who owes whom. The next steps could involve adding features like settling debts, viewing personal balance summaries, or handling more complex split methods.

**Metadata:**
```json
{
  "subtask_id": "debt-calculation",
  "title": "Develop Debt Calculation and Dashboard Logic",
  "expertise": "Algorithm Design, Data Processing, Next.js"
}
```

### UI/UX Design, CSS, Tailwind CSS Specialist

Excellent. The application is fully functional, but its appearance is basic. A polished, intuitive user interface is crucial for a finance app to feel trustworthy and be pleasant to use.

In this step, we will overhaul the UI/UX using **Tailwind CSS**. We'll establish a consistent design system with a defined color palette, component styles, and responsive layouts to create a professional and modern look and feel.

---

### **Step 1: Enhance Tailwind Configuration and Base Styles**

First, let's define our color palette and refine the base styles for the entire application.

1.  **Install Heroicons:** We'll use this popular icon library to add visual cues to our UI.
    ```bash
    npm install @heroicons/react
    ```

2.  **Update `tailwind.config.ts`:** We'll extend the default theme with our custom color scheme.

    ```ts
    // tailwind.config.ts
    import type { Config } from 'tailwindcss'

    const config: Config = {
      content: [
        './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
        './src/components/**/*.{js,ts,jsx,tsx,mdx}',
        './src/app/**/*.{js,ts,jsx,tsx,mdx}',
      ],
      theme: {
        extend: {
          colors: {
            brand: {
              primary: '#4f46e5', // Indigo 600
              secondary: '#6366f1', // Indigo 500
              light: '#e0e7ff', // Indigo 100
            },
            success: '#16a34a', // Green 600
            danger: '#dc2626', // Red 600
            light: '#f8fafc', // Slate 50
          },
        },
      },
      plugins: [
        require('@tailwindcss/forms'), // A plugin for better default form styles
      ],
    }
    export default config
    ```
    *Note: You might need to install `@tailwindcss/forms`: `npm install -D @tailwindcss/forms`*

3.  **Refine `globals.css`:** Let's clean up the global stylesheet. We'll set a background color for the app and refine our component layer for better consistency.

    ```css
    /* src/app/globals.css */
    @tailwind base;
    @tailwind components;
    @tailwind utilities;

    /* Apply a default background color and font smoothing */
    body {
      @apply bg-light antialiased;
    }

    @layer components {
      /* We will apply styles more directly in components, but keep some core ones here */
      .button {
        @apply inline-flex items-center justify-center rounded-md bg-brand-primary px-4 py-2 text-sm font-semibold text-white shadow-sm transition-colors hover:bg-brand-secondary focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-brand-primary disabled:opacity-50 disabled:cursor-not-allowed;
      }
      .button-secondary {
        @apply inline-flex items-center justify-center rounded-md bg-white px-4 py-2 text-sm font-semibold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 transition-colors hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed;
      }
      .input {
        @apply block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-brand-primary sm:text-sm sm:leading-6;
      }
      .label {
        @apply block text-sm font-medium leading-6 text-gray-900;
      }
      .card {
        @apply bg-white rounded-lg shadow-md border border-gray-200;
      }
    }
    ```

---

### **Step 2: Create a Reusable Layout Component**

To ensure a consistent header and page structure for logged-in users, we'll create a `MainLayout` component.

*   Create a new file: `src/components/layout/MainLayout.tsx`

    ```tsx
    // src/components/layout/MainLayout.tsx
    'use client';

    import { useAuth } from '@/context/AuthContext';
    import Link from 'next/link';
    import { ArrowRightOnRectangleIcon } from '@heroicons/react/24/outline';

    interface MainLayoutProps {
      children: React.ReactNode;
      pageTitle: string;
      backButtonHref?: string;
    }

    export default function MainLayout({ children, pageTitle, backButtonHref }: MainLayoutProps) {
      const { user, logout } = useAuth();

      return (
        <div className="min-h-screen bg-light">
          <header className="bg-white shadow-sm sticky top-0 z-40">
            <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
              <div className="flex h-16 justify-between">
                <div className="flex items-center">
                  <Link href="/dashboard" className="flex-shrink-0 text-2xl font-bold text-brand-primary">
                    SplitEase
                  </Link>
                </div>
                <div className="flex items-center gap-4">
                  {user && (
                    <>
                      <p className="text-sm text-gray-600 hidden sm:block">
                        {user.email}
                      </p>
                      <button
                        onClick={logout}
                        className="button-secondary p-2"
                        title="Logout"
                      >
                        <ArrowRightOnRectangleIcon className="h-5 w-5" />
                      </button>
                    </>
                  )}
                </div>
              </div>
            </div>
          </header>

          <main className="py-8">
            <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
              {children}
            </div>
          </main>
        </div>
      );
    }
    ```

---

### **Step 3: Update and Style the Dashboard Page**

Let's apply our new layout and styles to the main dashboard.

1.  **Restyle `GroupCard` in `GroupList.tsx`:** Make the cards cleaner and more interactive.

    ```tsx
    // src/components/groups/GroupList.tsx
    'use client';

    import { Group, getUserGroups } from '@/lib/firebase/firestore';
    import Link from 'next/link';
    import { useEffect, useState } from 'react';
    import { useAuth } from '@/context/AuthContext';
    import { UsersIcon, ClipboardDocumentIcon, CheckIcon } from '@heroicons/react/24/outline';

    function GroupCard({ group }: { group: Group }) {
      const [copied, setCopied] = useState(false);

      const copyToClipboard = (e: React.MouseEvent) => {
        e.preventDefault(); // Prevent link navigation
        navigator.clipboard.writeText(group.inviteCode).then(() => {
          setCopied(true);
          setTimeout(() => setCopied(false), 2000); // Reset after 2 seconds
        });
      };

      return (
        <Link href={`/group/${group.id}`} className="group block">
          <div className="card h-full p-6 transition-all group-hover:shadow-xl group-hover:-translate-y-1">
            <h3 className="text-xl font-bold text-gray-800">{group.groupName}</h3>
            <div className="mt-2 flex items-center text-sm text-gray-500">
              <UsersIcon className="h-4 w-4 mr-2" />
              <span>{group.members.length} member{group.members.length !== 1 ? 's' : ''}</span>
            </div>
            <div className="mt-4 pt-4 border-t border-gray-100">
              <p className="text-xs font-semibold text-gray-500 uppercase">Invite Code</p>
              <div className="mt-1 flex items-center justify-between gap-2 p-2 bg-gray-50 rounded-md">
                <span className="font-mono text-lg tracking-widest text-gray-700">{group.inviteCode}</span>
                <button onClick={copyToClipboard} className="button-secondary p-2" title="Copy code">
                  {copied ? <CheckIcon className="h-5 w-5 text-success" /> : <ClipboardDocumentIcon className="h-5 w-5" />}
                </button>
              </div>
            </div>
          </div>
        </Link>
      );
    }

    // ... (rest of GroupList component is the same, just remove the old GroupCard)
    ```

2.  **Update `dashboard/page.tsx`:** Use the `MainLayout` and add a proper header.

    ```tsx
    // src/app/dashboard/page.tsx
    'use client';

    import { useState } from 'react';
    import ProtectedRoute from '@/components/ProtectedRoute';
    import CreateGroupModal from '@/components/groups/CreateGroupModal';
    import GroupList from '@/components/groups/GroupList';
    import MainLayout from '@/components/layout/MainLayout';
    import { PlusIcon } from '@heroicons/react/20/solid';

    function Dashboard() {
      const [isModalOpen, setIsModalOpen] = useState(false);

      return (
        <MainLayout pageTitle="Dashboard">
          <div className="px-4 sm:px-0 mb-6 flex justify-between items-center">
            <h1 className="text-3xl font-bold tracking-tight text-gray-900">Your Groups</h1>
            <button onClick={() => setIsModalOpen(true)} className="button">
              <PlusIcon className="h-5 w-5 mr-1" />
              Create Group
            </button>
          </div>

          <div className="px-4 sm:px-0">
            <GroupList />
          </div>

          <CreateGroupModal
            isOpen={isModalOpen}
            onClose={() => setIsModalOpen(false)}
            onGroupCreated={() => {
              window.location.reload();
            }}
          />
        </MainLayout>
      );
    }

    export default function DashboardPage() {
      return (
        <ProtectedRoute>
          <Dashboard />
        </ProtectedRoute>
      );
    }
    ```

---

### **Step 4: Update and Style the Group Detail Page**

This page has the most components and will benefit greatly from a cleaner design.

1.  **Restyle `BalanceSummary.tsx`:** Make the "who owes who" section visually clear.

    ```tsx
    // src/components/expenses/BalanceSummary.tsx
    'use client';

    import { Member } from '@/lib/firebase/firestore';
    import { SimplifiedDebt } from '@/lib/debt-calculator';
    import { ArrowLongRightIcon } from '@heroicons/react/24/solid';

    interface BalanceSummaryProps {
      debts: SimplifiedDebt[];
      members: Member[];
    }

    export default function BalanceSummary({ debts, members }: BalanceSummaryProps) {
      const memberMap = new Map(members.map(m => [m.uid, m.displayName]));

      if (debts.length === 0) {
        return (
          <div className="card p-6 bg-green-50 border-green-200">
            <h3 className="text-xl font-bold text-green-800">All Settled Up!</h3>
            <p className="mt-1 text-green-700">There are no outstanding debts in this group.</p>
          </div>
        );
      }

      return (
        <div className="card p-6">
          <h3 className="text-xl font-bold text-gray-800 mb-4">How to Settle Up</h3>
          <ul className="space-y-4">
            {debts.map((debt, index) => {
              const fromName = memberMap.get(debt.from) || 'Unknown User';
              const toName = memberMap.get(debt.to) || 'Unknown User';
              const amount = (debt.amount / 100).toFixed(2);

              return (
                <li key={index} className="flex flex-col sm:flex-row items-center justify-between p-4 bg-gray-50 rounded-lg">
                  <div className="flex items-center gap-3 text-lg">
                    <span className="font-semibold text-danger">{fromName}</span>
                    <ArrowLongRightIcon className="h-6 w-6 text-gray-400" />
                    <span className="font-semibold text-success">{toName}</span>
                  </div>
                  <span className="mt-2 sm:mt-0 font-bold text-2xl text-brand-primary">
                    ${amount}
                  </span>
                </li>
              );
            })}
          </ul>
        </div>
      );
    }
    ```

2.  **Restyle `ExpenseList.tsx`:** Improve the layout of individual expense items.

    ```tsx
    // src/components/expenses/ExpenseList.tsx
    'use client';

    import { Expense } from '@/lib/firebase/firestore';
    import { Timestamp } from 'firebase/firestore';

    function ExpenseCard({ expense }: { expense: Expense }) {
        const formatDate = (timestamp: Timestamp) => {
            if (!timestamp) return 'Date not available';
            return timestamp.toDate().toLocaleDateString('en-US', {
                year: 'numeric', month: 'short', day: 'numeric',
            });
        };

        return (
            <div className="card p-4 flex items-center justify-between gap-4">
                <div className="flex-1">
                    <p className="font-bold text-lg text-gray-800">{expense.description}</p>
                    <p className="text-sm text-gray-500 mt-1">
                        Paid by <span className="font-medium text-gray-700">{expense.paidByDisplayName}</span> on {formatDate(expense.createdAt)}
                    </p>
                </div>
                <div className="text-right">
                    <p className="text-2xl font-semibold text-gray-900">
                        ${(expense.amount / 100).toFixed(2)}
                    </p>
                    <p className="text-xs text-gray-500">
                        Split among {expense.participants.length}
                    </p>
                </div>
            </div>
        );
    }

    // ... (rest of ExpenseList component is the same)
    ```

3.  **Update `group/[groupId]/page.tsx`:** Integrate the layout and clean up the structure.

    ```tsx
    // src/app/group/[groupId]/page.tsx
    'use client';

    import { useEffect, useState } from 'react';
    import { useParams, useRouter } from 'next/navigation';
    import Link from 'next/link';
    import ProtectedRoute from '@/components/ProtectedRoute';
    import { useAuth } from '@/context/AuthContext';
    import { Group, Expense, getGroupDetails, getGroupExpenses } from '@/lib/firebase/firestore';
    import { calculateBalances, SimplifiedDebt } from '@/lib/debt-calculator';
    import MainLayout from '@/components/layout/MainLayout';
    import BalanceSummary from '@/components/expenses/BalanceSummary';
    import ExpenseList from '@/components/expenses/ExpenseList';
    import AddExpenseModal from '@/components/expenses/AddExpenseModal';
    import { PlusIcon, ArrowLeftIcon } from '@heroicons/react/20/solid';

    function GroupDetailPage() {
      // ... (all state and useEffect hooks remain the same)
      const { user } = useAuth();
      const router = useRouter();
      const params = useParams();
      const groupId = params.groupId as string;

      const [group, setGroup] = useState<Group | null>(null);
      const [expenses, setExpenses] = useState<Expense[]>([]);
      const [debts, setDebts] = useState<SimplifiedDebt[]>([]);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [refreshTrigger, setRefreshTrigger] = useState(0);

      useEffect(() => {
        if (!groupId || !user) return;
        const fetchGroupData = async () => {
          // ... (fetch logic remains identical)
        };
        fetchGroupData();
      }, [groupId, user, router, refreshTrigger]);

      const handleExpenseAdded = () => {
        setRefreshTrigger(prev => prev + 1);
      };

      if (isLoading) { /* ... */ }
      if (error) { /* ... */ }
      if (!group) { /* ... */ }

      return (
        <MainLayout pageTitle={group.groupName}>
          <div className="space-y-8">
            {/* Page Header */}
            <div className="px-4 sm:px-0">
                <Link href="/dashboard" className="inline-flex items-center gap-2 text-sm font-medium text-gray-600 hover:text-brand-primary mb-4">
                    <ArrowLeftIcon className="h-4 w-4" />
                    Back to All Groups
                </Link>
                <h1 className="text-3xl font-bold tracking-tight text-gray-900">{group.groupName}</h1>
            </div>

            {/* Balance Summary */}
            <div className="px-4 sm:px-0">
              <BalanceSummary debts={debts} members={group.members} />
            </div>

            {/* Expenses Section */}
            <div>
              <div className="px-4 sm:px-0 mb-6 flex justify-between items-center">
                <h2 className="text-2xl font-bold text-gray-900">Expenses</h2>
                <button onClick={() => setIsModalOpen(true)} className="button">
                  <PlusIcon className="h-5 w-5 mr-1" />
                  Add Expense
                </button>
              </div>
              <div className="px-4 sm:px-0">
                <ExpenseList expenses={expenses} isLoading={isLoading} />
              </div>
            </div>
          </div>

          {isModalOpen && (
            <AddExpenseModal
              isOpen={isModalOpen}
              onClose={() => setIsModalOpen(false)}
              onExpenseAdded={handleExpenseAdded}
              groupId={group.id}
              members={group.members}
            />
          )}
        </MainLayout>
      );
    }

    // ... (default export remains the same)
    ```

---

### **Step 5: Style the Modals**

Finally, let's give our modals a professional look.

*   **Update `CreateGroupModal.tsx` and `AddExpenseModal.tsx`:** The styling is nearly identical for both. Here is the updated JSX for `CreateGroupModal`. Apply similar changes to `AddExpenseModal`.

    ```tsx
    // src/components/groups/CreateGroupModal.tsx
    'use client';

    import { useState } from 'react';
    import { useAuth } from '@/context/AuthContext';
    import { createGroup } from '@/lib/firebase/firestore';
    import { XMarkIcon } from '@heroicons/react/24/outline';

    // ... (interface and function signature)
    export default function CreateGroupModal({ isOpen, onClose, onGroupCreated }: CreateGroupModalProps) {
        // ... (state hooks and handleSubmit logic remain the same)

        if (!isOpen) return null;

        return (
            <div className="relative z-50" aria-labelledby="modal-title" role="dialog" aria-modal="true">
                {/* Backdrop */}
                <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>

                <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
                    <div className="flex min-h-full items-center justify-center p-4 text-center sm:items-center sm:p-0">
                        <div className="relative transform overflow-hidden rounded-lg bg-white text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg">
                            <div className="bg-white px-4 pb-4 pt-5 sm:p-6 sm:pb-4">
                                <div className="sm:flex sm:items-start">
                                    <div className="w-full mt-3 text-center sm:ml-4 sm:mt-0 sm:text-left">
                                        <div className="flex justify-between items-center">
                                            <h3 className="text-lg font-semibold leading-6 text-gray-900" id="modal-title">
                                                Create a New Group
                                            </h3>
                                            <button onClick={onClose} className="p-1 rounded-full hover:bg-gray-100">
                                                <XMarkIcon className="h-6 w-6 text-gray-500" />
                                            </button>
                                        </div>
                                        <div className="mt-4">
                                            <form onSubmit={handleSubmit}>
                                                <div className="mb-4">
                                                    <label htmlFor="groupName" className="label">Group Name</label>
                                                    <input
                                                        id="groupName" type="text" value={groupName}
                                                        onChange={(e) => setGroupName(e.target.value)}
                                                        placeholder="e.g., Apartment Roommates" required className="input mt-1"
                                                    />
                                                </div>
                                                {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
                                                <div className="mt-6 flex justify-end gap-4">
                                                    <button type="button" onClick={onClose} className="button-secondary" disabled={isLoading}>
                                                        Cancel
                                                    </button>
                                                    <button type="submit" className="button" disabled={isLoading}>
                                                        {isLoading ? 'Creating...' : 'Create Group'}
                                                    </button>
                                                </div>
                                            </form>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    ```

### **Summary**

By systematically applying a design system through Tailwind CSS, you have transformed the application from a functional prototype into a polished, professional-looking product.

*   **Consistent Design:** A defined color palette and component styles (`button`, `card`, `input`) create a cohesive user experience.
*   **Reusable Layout:** The `MainLayout` component reduces code duplication and ensures every authenticated page has a consistent header and structure.
*   **Improved UX:** The UI is now more intuitive, with clear visual hierarchies, interactive hover states, and helpful icons.
*   **Responsive:** All updated components and layouts are designed to work seamlessly across device sizes, from mobile phones to desktops.

The application is now not only fully functional but also visually appealing and user-friendly, providing a solid foundation for any future features.

**Metadata:**
```json
{
  "subtask_id": "ui-styling",
  "title": "UI/UX Design and Styling",
  "expertise": "UI/UX Design, CSS, Tailwind CSS"
}
```

### Firebase Security Rules Specialist

Excellent. With the application's core logic and UI in place, it's absolutely critical to secure our backend before considering deployment. Firebase Security Rules are the server-side gatekeepers that protect your data from unauthorized access, ensuring users can only read and write data they are permitted to.

We will write and deploy rules for both Firestore and Firebase Storage.

---

### **A Quick Note on Data Modeling for Security**

For our security rules to work efficiently, we need to make a small but important adjustment to our Firestore data model. When checking if a user is a member of a group, it's much more efficient to check against a simple list of UIDs rather than an array of objects.

**Action Required:** Ensure that whenever you create or update a group's members, you also maintain a simple array of UIDs.

Your `Group` document in Firestore should look like this:

```json
// /groups/{groupId}
{
  "groupName": "Apartment Roommates",
  "ownerId": "user_uid_of_creator",
  "inviteCode": "ABC123",
  "members": [
    { "uid": "user_uid_of_creator", "displayName": "Alice" },
    { "uid": "another_user_uid", "displayName": "Bob" }
  ],
  "memberUids": ["user_uid_of_creator", "another_user_uid"] // <-- ADD THIS FIELD
}
```

You'll need to update your `createGroup` and any "join group" functions to maintain this `memberUids` array. This is essential for the following rules to work.

---

### **Step 1: Write Firestore Security Rules**

These rules define who can read, write, update, and delete documents in your Firestore database.

1.  Go to your **Firebase Console**.
2.  In the "Build" menu, click on **Firestore Database**.
3.  Select the **Rules** tab.
4.  Replace the existing content (which is likely in test mode) with the following rules:

```javascript
// firestore.rules

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if the requesting user's UID is in the group's `memberUids` array.
    // This is why the `memberUids` array in our data model is crucial.
    function isGroupMember(groupId) {
      return request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUids;
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      // A user can read, create, and update their own profile document. No one else can.
      allow read, create, update: if isAuthenticated() && request.auth.uid == userId;
      // Disallow client-side deletion of user profiles for data integrity.
      allow delete: if false;
    }

    // Rules for the 'groups' collection
    match /groups/{groupId} {
      // READ: Allow if the user is a member of the group.
      allow read: if isAuthenticated() && isGroupMember(groupId);

      // CREATE: Allow if the user is authenticated, they are the owner, and they are in the member list.
      allow create: if isAuthenticated()
                    && request.resource.data.ownerId == request.auth.uid
                    && request.auth.uid in request.resource.data.memberUids;

      // UPDATE: Allow if the user is a member. The app's client-side logic will handle
      // specific actions like joining with an invite code or changing the group name.
      allow update: if isAuthenticated() && isGroupMember(groupId);

      // DELETE: Only the group owner can delete the group.
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;

      // Rules for the 'expenses' subcollection
      match /expenses/{expenseId} {
        // LIST/READ: Allow if the user is a member of the parent group.
        allow list, read: if isAuthenticated() && isGroupMember(groupId);

        // CREATE: Allow if the user is a group member and they are the one marked as 'paidBy'.
        allow create: if isAuthenticated()
                      && isGroupMember(groupId)
                      && request.resource.data.paidBy == request.auth.uid;

        // UPDATE: Allow only if the user is the one who originally paid for the expense.
        allow update: if isAuthenticated()
                      && isGroupMember(groupId)
                      && resource.data.paidBy == request.auth.uid;

        // DELETE: Allow if the user paid for the expense OR is the group owner.
        allow delete: if isAuthenticated()
                      && isGroupMember(groupId)
                      && (resource.data.paidBy == request.auth.uid || get(/databases/$(database)/documents/groups/$(groupId)).data.ownerId == request.auth.uid);
      }
    }
  }
}
```

5.  Click **Publish**.

#### **Explanation of Firestore Rules:**

*   **`users` collection:** Ensures a user can only ever access and modify their own user document.
*   **`groups` collection:**
    *   `read`: You can only get details of a group if you are a member. This prevents users from snooping on groups they don't belong to.
    *   `create`: Enforces that the person creating the group is correctly listed as the owner and a member.
    *   `delete`: Restricts deletion to the group's original creator (`ownerId`).
*   **`expenses` subcollection:**
    *   `list`, `read`: Leverages the `isGroupMember` function to ensure only group members can see the expenses within that group.
    *   `create`: A user can only add an expense where they are listed as the payer (`paidBy`). This prevents a user from creating an expense and saying someone else paid for it.
    *   `delete`: Allows either the person who paid or the group owner to delete an expense, providing flexibility.

---

### **Step 2: Write Firebase Storage Security Rules**

These rules protect the receipt images that users upload, ensuring they are only accessible to the correct group members.

1.  Go to your **Firebase Console**.
2.  In the "Build" menu, click on **Storage**.
3.  Select the **Rules** tab.
4.  Replace the existing content with the following rules. We will enforce a file path structure of `receipts/{groupId}/{expenseId}/{fileName}`.

```javascript
// storage.rules

rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {

    // Helper function to check group membership by reading from Firestore.
    function isGroupMember(groupId) {
      return exists(/databases/(default)/documents/groups/$(groupId)) &&
             request.auth.uid in get(/databases/(default)/documents/groups/$(groupId)).data.memberUids;
    }

    // Helper function to check if the user is the owner of the expense or the group.
    function canModifyExpenseAsset(groupId, expenseId) {
      let expense = get(/databases/(default)/documents/groups/$(groupId)/expenses/$(expenseId)).data;
      let group = get(/databases/(default)/documents/groups/$(groupId)).data;
      return request.auth.uid == expense.paidBy || request.auth.uid == group.ownerId;
    }

    // Rules for receipt images. Path structure: /receipts/{groupId}/{expenseId}/{anyFileName}
    match /receipts/{groupId}/{expenseId}/{fileName} {

      // READ (Download): Allow if the user is authenticated and a member of the group.
      allow read: if request.auth != null && isGroupMember(groupId);

      // CREATE (Upload): Allow if the user is a member and the file is a reasonably sized image.
      allow create: if request.auth != null
                     && isGroupMember(groupId)
                     && request.resource.size < 5 * 1024 * 1024 // Max 5MB
                     && request.resource.contentType.matches('image/.*'); // Only allow images

      // UPDATE: Disallow overwriting files for simplicity and security.
      allow update: if false;

      // DELETE: Only allow deletion by the person who paid for the expense or the group owner.
      allow delete: if request.auth != null && canModifyExpenseAsset(groupId, expenseId);
    }
  }
}
```

5.  Click **Publish**.

#### **Explanation of Storage Rules:**

*   **Cross-Service Communication:** These rules demonstrate a powerful feature of Firebase: they can read your Firestore database (`get()` and `exists()`) to make authorization decisions for Storage.
*   **Path-Based Security:** The rules are tied to the file path. By enforcing a structure like `/receipts/{groupId}/{expenseId}/...`, we can extract the `groupId` and `expenseId` to check permissions.
*   **Upload Validation:** We add important server-side checks to ensure users can only upload images (`image/.*`) and that those images aren't excessively large (max 5MB), protecting your storage costs and server resources.
*   **Scoped Deletion:** The `delete` rule is very specific. It reads the corresponding expense document in Firestore to ensure only the person who paid (or the group owner) can delete the associated receipt.

---

### **Summary**

You have now implemented a robust security layer for your application. These rules run on the Firebase servers and cannot be bypassed by client-side code, providing a strong guarantee that:

*   User data is private and accessible only by the owner.
*   Group data (details, expenses, receipts) is confined to its members.
*   Specific actions like creating or deleting expenses are restricted to authorized users (the payer or group owner).
*   File uploads are validated for type and size.

Your application is now significantly more secure and ready for real-world use.

**Metadata:**
```json
{
  "subtask_id": "security-rules",
  "title": "Implement Firebase Security Rules",
  "expertise": "Firebase Security Rules"
}
```

### Vercel, CI/CD Specialist

With our application's logic complete and its backend secured with robust Firebase rules, the final step is to deploy it to the web for everyone to use. We will use **Vercel**, the platform created by the makers of Next.js, which offers a seamless and powerful deployment experience.

### **Why Vercel?**

*   **Optimized for Next.js:** Vercel is designed to host Next.js apps, providing the best performance, including serverless functions, edge caching, and automatic code splitting.
*   **Continuous Deployment (CI/CD):** Once set up, every `git push` to your main branch will automatically trigger a new deployment, keeping your live app in sync with your code.
*   **Free Tier:** Vercel offers a generous free "Hobby" plan that is perfect for personal projects and MVPs.
*   **Global CDN:** Your application is automatically distributed across a global network, ensuring fast load times for users anywhere in the world.

---

### **Step 1: Prepare Your Project for Deployment**

Before deploying, we need to ensure our project is set up correctly.

#### **1.1. Create a Git Repository**

Vercel deploys directly from a Git repository. If your code isn't already in one, now is the time.

1.  **Initialize Git:** If you haven't already, run this in your project's root directory:
    ```bash
    git init
    ```
2.  **Create a `.gitignore` file:** This file tells Git which files to ignore. It's crucial for security and efficiency. Create a file named `.gitignore` in your project root and add the following:
    ```
    # Dependencies
    /node_modules

    # Local Environment Variables
    .env.local

    # Next.js build output
    /.next/
    /out/

    # Production log
    /npm-debug.log*
    /yarn-debug.log*
    /yarn-error.log*

    # Editor directories and files
    .vscode
    .idea
    *.suo
    *.ntvs*
    *.njsproj
    *.sln
    *.sw?
    ```
    **Crucially, ensure `.env.local` is in this file. You must never commit your secret keys to a public repository.**

3.  **Push to GitHub/GitLab/Bitbucket:**
    *   Create a new repository on your preferred platform (e.g., GitHub).
    *   Follow the instructions provided by the platform to connect your local repository and push your code. The commands will look something like this:
        ```bash
        git add .
        git commit -m "Initial commit for deployment"
        git branch -M main
        git remote add origin <your-repository-url.git>
        git push -u origin main
        ```

#### **1.2. Verify Environment Variables**

Your application relies on environment variables to connect to Firebase. Locally, you have them in `.env.local`. For production on Vercel, we will configure them in the Vercel dashboard.

Make sure you have all the necessary keys from your Firebase project settings ready:
*   `NEXT_PUBLIC_FIREBASE_API_KEY`
*   `NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN`
*   `NEXT_PUBLIC_FIREBASE_PROJECT_ID`
*   `NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET`
*   `NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID`
*   `NEXT_PUBLIC_FIREBASE_APP_ID`

---

### **Step 2: Deploying with Vercel**

Now for the exciting part!

1.  **Sign Up for Vercel:** Go to [vercel.com](https://vercel.com/) and sign up. The easiest way is to **Continue with GitHub** (or your chosen Git provider). This grants Vercel access to your repositories.

2.  **Import Your Project:**
    *   From your Vercel dashboard, click **"Add New..."** and select **"Project"**.
    *   Vercel will display a list of your Git repositories. Find your expense-splitter app repository and click the **"Import"** button next to it.

    

3.  **Configure Your Project:**
    *   Vercel will automatically detect that you're using Next.js and pre-fill the **Framework Preset** and **Build and Output Settings**. You do not need to change these.
    *   Expand the **Environment Variables** section. This is the most important step.
    *   Carefully copy each key-value pair from your local `.env.local` file into the Vercel UI. For each variable:
        *   Enter the name (e.g., `NEXT_PUBLIC_FIREBASE_API_KEY`).
        *   Enter the value (e.g., `AIzaSy...`).
        *   Click **"Add"**.
    *   Repeat this for all your Firebase environment variables. The `NEXT_PUBLIC_` prefix is essential for Next.js to expose these variables to the browser.

    

4.  **Deploy!**
    *   Once all variables are added, click the **"Deploy"** button.
    *   Vercel will now begin the deployment process. It will:
        1.  Clone your repository.
        2.  Install all dependencies (`npm install`).
        3.  Run the build command (`next build`).
        4.  Deploy the static assets, serverless functions, and edge configuration.
    *   You can watch the build logs in real-time.

---

### **Step 3: Celebrate and Verify**

If all goes well, you'll be greeted with a "Congratulations!" screen and some celebratory confetti!



*   **Visit Your Live App:** Vercel provides you with a public URL (e.g., `your-project-name.vercel.app`). Click the screenshot or the "Visit" button to see your application live on the internet.
*   **Thoroughly Test:** Perform all the key user actions to ensure everything works in the production environment:
    *   Sign up for a new account.
    *   Log out and log back in.
    *   Create a new group.
    *   Invite another user (you can use a different browser or incognito mode to test this).
    *   Add an expense with a receipt upload.
    *   Verify that the receipt image loads correctly.
    *   Check the "Who Owes Who" calculations.

### **Automatic Deployments and Custom Domains**

You are now set up with a professional-grade deployment workflow.

*   **Automatic Deployments:** From now on, every time you `git push` to your `main` branch, Vercel will automatically build and deploy the changes, updating your live application. No manual steps are needed!
*   **Preview Deployments:** If you create a new branch and open a Pull Request on GitHub, Vercel will automatically create a unique "preview" deployment for that PR. This allows you to test changes in a production-like environment before merging them into the main branch.
*   **(Optional) Custom Domain:** To make your app look more professional, you can add a custom domain. In your Vercel project's **Settings** tab, go to **Domains**. Enter the domain you own, and Vercel will provide you with the DNS records you need to configure with your domain registrar (e.g., GoDaddy, Namecheap). Vercel will also automatically provision and renew a free SSL certificate for your domain.

Congratulations! You have successfully built and deployed a full-stack, secure, and scalable personal finance application using Next.js, Firebase, and Vercel.

**Metadata:**
```json
{
  "subtask_id": "deployment",
  "title": "Deploy the Application to Vercel",
  "expertise": "Vercel, CI/CD"
}
```

### Results Integrator

Of course. Let's build out the Expense Splitter App. This is an excellent project that combines user authentication, database management, file storage, and core business logic, making it a perfect showcase for Next.js and Firebase.

Here is a comprehensive, step-by-step guide to building the application from project initialization to final deployment.

### **Executive Summary**

We will construct a full-stack Expense Splitter web application using the Next.js App Router for the frontend and Firebase for the backend. The application will allow users to register, create groups, invite members, add shared expenses with optional receipt uploads, and automatically view a simplified breakdown of who owes whom. The project is broken down into four key phases:

1.  **Foundation & Setup:** Initializing the Next.js project, configuring Firebase services (Auth, Firestore, Storage), and designing the database schema.
2.  **Core Functionality:** Implementing user authentication, creating protected routes, and building the features for creating, viewing, and managing groups.
3.  **Expense & Calculation Logic:** Developing the systems for adding expenses, uploading receipts, and implementing the core algorithm to calculate and display group balances.
4.  **Polishing & Deployment:** Applying a professional UI/UX design, securing the backend with robust rules, and deploying the final application to the web using Vercel.

---

### **Phase 1: Project Foundation and Data Modeling**

First, we'll set up our development environment and design the database structure that will power the entire application.

#### **1. Project Initialization (Next.js)**

Begin by creating a new Next.js project with the recommended modern stack.

1.  **Create the App:** Open your terminal and run:
    ```bash
    npx create-next-app@latest expense-splitter
    ```
2.  **Select Options:** Use the following settings for a robust setup:
    *   TypeScript: **Yes**
    *   ESLint: **Yes**
    *   Tailwind CSS: **Yes**
    *   `src/` directory: **Yes**
    *   App Router: **Yes**
    *   Customize import alias: **No**
3.  **Navigate and Install Firebase:**
    ```bash
    cd expense-splitter
    npm install firebase
    ```

#### **2. Firebase Backend Configuration**

Next, set up the necessary Firebase services.

1.  **Create a Firebase Project:** Go to the [Firebase Console](https://console.firebase.google.com/), click "Add project," and follow the setup wizard.
2.  **Enable Services:**
    *   **Firestore Database:** From the "Build" menu, create a Firestore database. Start in **Test mode** for now; we will secure it later.
    *   **Authentication:** Go to the Authentication service and enable the **Email/Password** and **Google** sign-in providers.
    *   **Storage:** Go to the Storage service and create a storage bucket, also starting in **Test mode**.
3.  **Connect App to Firebase:**
    *   In your Firebase project settings, register a new **Web app (`</>`)**.
    *   Firebase will provide a `firebaseConfig` object. Copy these credentials.
4.  **Set Up Environment Variables:**
    *   In your project root, create a file named `.env.local`.
    *   Add your Firebase credentials, prefixed with `NEXT_PUBLIC_`:
        ```.env.local
        NEXT_PUBLIC_FIREBASE_API_KEY="AIzaSy..."
        NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="your-project-id.firebaseapp.com"
        NEXT_PUBLIC_FIREBASE_PROJECT_ID="your-project-id"
        // ...and so on for all keys.
        ```
5.  **Create Firebase Initializer:** Centralize your Firebase configuration. Create `src/lib/firebase/config.ts`:
    ```typescript
    // src/lib/firebase/config.ts
    import { initializeApp, getApps, getApp } from "firebase/app";
    import { getAuth } from "firebase/auth";
    import { getFirestore } from "firebase/firestore";
    import { getStorage } from "firebase/storage";

    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    };

    const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
    const db = getFirestore(app);
    const auth = getAuth(app);
    const storage = getStorage(app);

    export { app, db, auth, storage };
    ```

#### **3. Firestore Schema Design**

A well-planned schema is essential for performance and scalability. We'll use three top-level collections.

*   **`users` Collection:** Stores individual user profiles. The Document ID will be the user's UID from Firebase Auth.
    *   Path: `/users/{userId}`
    *   Fields: `uid`, `email`, `displayName`, `photoURL`, `createdAt`, `groups` (Array of group IDs).

*   **`groups` Collection:** Stores information about each expense-sharing group.
    *   Path: `/groups/{groupId}`
    *   Fields: `groupName`, `createdBy` (user UID), `createdAt`, `inviteCode`, `members` (Array of member objects with `uid`, `displayName`, `photoURL`), and `memberUids` (a simple Array of member UIDs for efficient security rule checks).

*   **`expenses` Subcollection:** Each group document will contain a subcollection of its expenses. This is a highly efficient way to query for all expenses related to a single group.
    *   Path: `/groups/{groupId}/expenses/{expenseId}`
    *   Fields: `description`, `amount` (in cents), `createdAt`, `paidBy` (user UID), `paidByDisplayName`, `receiptUrl` (optional), `splitMethod`, and `participants` (Array of objects detailing who owes what, e.g., `{ uid, amountOwed }`).

**Note on Balances:** We will not store running balances in the database. Instead, balances will be calculated dynamically on the client side by fetching all expenses for a group. This approach is more robust and less prone to data synchronization errors.

---

### **Phase 2: User Authentication and Group Management**

With the foundation laid, we'll build the app's core interactive features.

#### **1. Global Authentication State**

We'll use React Context to manage the user's authentication state across the entire application. This context will also handle the crucial task of creating a user document in Firestore the first time a user signs in.

*   Create `src/context/AuthContext.tsx`. This provider will:
    *   Use Firebase's `onAuthStateChanged` listener to track the current user.
    *   When a user logs in, it will check if a corresponding document exists in `/users/{uid}`. If not, it creates one.
    *   Provide the `user` object, a `loading` state, and a `logout` function to all child components.
*   Wrap the application's root layout (`src/app/layout.tsx`) with this `AuthProvider` to make it globally accessible.

#### **2. Authentication Pages and Protected Routes**

Users need a way to sign in, sign up, and be restricted from accessing content they aren't authorized to see.

1.  **Create Auth Pages:** Build the UI for `/login` and `/signup` pages using simple forms. These forms will use the Firebase SDK functions (`signInWithEmailAndPassword`, `createUserWithEmailAndPassword`, `signInWithPopup` for Google) to handle authentication.
2.  **Implement Protected Routes:** Create a `ProtectedRoute` component (`src/components/ProtectedRoute.tsx`). This component will:
    *   Use the `useAuth` hook to access the current user and loading state.
    *   If `loading` is true, it can show a spinner.
    *   If `loading` is false and no `user` exists, it will redirect to the `/login` page using Next.js's `useRouter`.
    *   Wrap any page that requires authentication (like the dashboard) with this `ProtectedRoute` component.

#### **3. Group Management Features**

Once authenticated, users should be able to create and view their groups.

1.  **Firestore Service Functions:** Create a file `src/lib/firebase/firestore.ts` to house all database interactions.
    *   `createGroup(groupName, user)`: Creates a new document in the `groups` collection, populates it with the creator's info, generates a unique invite code (using a library like `nanoid`), and adds the new group's ID to the creator's document in the `users` collection.
    *   `getUserGroups(userId)`: Fetches the user's document, retrieves their list of group IDs, and then queries the `groups` collection to get the full details for each group.
2.  **UI Components:**
    *   **CreateGroupModal:** A modal form that takes a group name and calls the `createGroup` service function on submission.
    *   **GroupList:** A component that calls `getUserGroups` and maps over the results to display a list of `GroupCard` components. Each card shows the group's name, number of members, and the invite code.
3.  **Dashboard Page:** Update the `/dashboard` page to be the main hub. It will display a "Create Group" button that opens the modal and will render the `GroupList` component.

---

### **Phase 3: Expense Tracking and Debt Calculation**

This is the core "splitter" functionality of the application.

#### **1. Expense Creation and Receipt Uploads**

We'll build a dedicated page for each group where users can add and view expenses.

1.  **Create Dynamic Group Page:** Create a dynamic route at `src/app/group/[groupId]/page.tsx`. This page will be the central view for a single group.
2.  **Extend Firestore Service:** Add functions to `firestore.ts`:
    *   `getGroupDetails(groupId)`: Fetches a single group's document.
    *   `addExpenseToGroup(expenseData)`: Creates a new document in the `/groups/{groupId}/expenses` subcollection.
    *   `getGroupExpenses(groupId)`: Fetches all documents from a group's `expenses` subcollection.
3.  **Implement Receipt Uploads:**
    *   Create a storage service file, `src/lib/firebase/storage.ts`.
    *   Implement an `uploadReceipt(file, groupId)` function that uses Firebase Storage to upload an image to a path like `receipts/{groupId}/{unique_file_name}` and returns the public download URL. Use `uuid` to generate unique file names.
4.  **Build UI Components:**
    *   **AddExpenseModal:** A comprehensive modal form with fields for description, amount, who paid (a dropdown of group members), and an optional file input for the receipt. On submit, it will first upload the receipt (if present) to get the URL, then call `addExpenseToGroup` with all the data.
    *   **ExpenseList:** A component that displays a list of expenses for the group. Each item shows the description, amount, payer, and a link to "View Receipt" if a `receiptUrl` exists.

#### **2. Debt Calculation Logic**

The "magic" happens here. We'll write a pure function to process expenses and determine who owes whom.

1.  **Create Calculation Utility:** Create a file `src/utils/debtCalculator.ts`.
2.  **Implement `calculateBalances` Function:** This function will accept two arguments: an array of `expenses` and an array of group `members`.
    *   **Step 1: Tally Balances:** It iterates through all expenses. For each expense, it credits the `paidBy` user with the full amount and debits each `participant` by their `amountOwed`. This results in a map of each user's net balance (positive means they are owed money, negative means they owe money).
    *   **Step 2: Simplify Debts:** It implements a greedy algorithm to simplify the list of debts. It separates users into debtors (negative balance) and creditors (positive balance) and creates the minimum number of transactions required to settle all balances. For example, if A owes B $10 and B owes C $10, the algorithm simplifies this to A pays C $10.
3.  **Create Balance Summary UI:** Build a `BalanceSummary` component that takes the simplified debt list and displays it in a clear, human-readable format (e.g., "Alice owes Bob $15.50").

#### **3. Integrate on Group Page**

Update the dynamic group page (`/group/[groupId]/page.tsx`) to tie everything together.

*   On page load, it will fetch both the group details and all its expenses in parallel.
*   It will then pass this data to the `calculateBalances` function.
*   Finally, it will render the `BalanceSummary` component with the calculated debts at the top of the page, followed by the full `ExpenseList`.

---

### **Phase 4: UI/UX, Security, and Deployment**

The final phase focuses on making the app professional, secure, and publicly accessible.

#### **1. UI/UX Design and Styling**

We'll use Tailwind CSS to create a consistent, modern, and responsive design.

1.  **Establish a Design System:** Extend the `tailwind.config.ts` file with a custom color palette (e.g., `brand.primary`, `success`, `danger`). Refine base styles in `globals.css` for buttons, inputs, and cards.
2.  **Create a Reusable Layout:** Build a `MainLayout` component that includes a consistent header with the app logo, user information, and a logout button. Use this layout on all authenticated pages.
3.  **Refine Components:** Systematically style all components—modals, cards, forms, and lists—using the defined color palette and utility classes. Add hover effects, transitions, and icons (e.g., from `heroicons`) to improve user experience.

#### **2. Firebase Security Rules**

This is a critical, non-negotiable step before deployment to protect user data.

1.  **Firestore Rules:** In the Firebase console, go to Firestore > Rules. Replace the test rules with production rules that enforce:
    *   **Users:** A user can only read and write their own document (`/users/{userId}`).
    *   **Groups:** A user can only read/write group data if their UID is present in the group's `memberUids` array.
    *   **Expenses:** A user can only create an expense if they are a member of the group and are listed as the payer.
2.  **Storage Rules:** Go to Storage > Rules. Implement rules that:
    *   Allow image uploads only for authenticated users who are members of the corresponding group.
    *   Validate uploads to ensure they are images and within a reasonable size limit (e.g., < 5MB).
    *   Allow reads (downloads) only for members of the group.

#### **3. Deployment to Vercel**

Finally, we'll deploy the application to the web.

1.  **Prepare for Deployment:**
    *   Initialize a Git repository and push your project to a provider like GitHub.
    *   Ensure your `.gitignore` file includes `.env.local` to prevent committing secret keys.
2.  **Import to Vercel:**
    *   Sign up for Vercel using your GitHub account.
    *   Import your project repository from the Vercel dashboard.
3.  **Configure Environment Variables:** In the Vercel project settings, navigate to "Environment Variables." Copy every key-value pair from your local `.env.local` file into Vercel's UI. This securely provides your production deployment with the Firebase credentials.
4.  **Deploy:** Click the "Deploy" button. Vercel will automatically build and deploy your application, providing you with a public URL (e.g., `expense-splitter.vercel.app`).

Congratulations! You have now successfully designed, built, secured, and deployed a feature-rich Expense Splitter application. With Vercel's CI/CD, every future `git push` to your main branch will automatically trigger a new deployment, keeping your live application up-to-date.

**Metadata:**
```json
{
  "subtask_count": 10
}
```
